// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PBMidLayer.proto

#ifndef PROTOBUF_PBMidLayer_2eproto__INCLUDED
#define PROTOBUF_PBMidLayer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace PBMidLayer {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_PBMidLayer_2eproto();
void protobuf_AssignDesc_PBMidLayer_2eproto();
void protobuf_ShutdownFile_PBMidLayer_2eproto();

class HeadMsg;
class ConnectRequest;
class ConnectResponse;
class ConnectRelease;
class EchoReqRes;
class CallProcessRequest;
class CallProcessResponse;
class HistorySearchRequest;
class TaskAttribute;
class HistorySearchResponse;
class HistoryTransRequest;
class HistoryTransResponse;
class FileLocationNotify;
class TargetQueryRequest;
class TargetQueryResponse;
class SetRuleRequest;
class SetRuleResponse;
class QueryRuleRequest;
class QueryRuleResponse;
class SetSysParaRequest;
class SetSysParaResponse;
class QuerySysParaRequest;
class QuerySysParaResponse;
class AlarmNotify;
class StatusNotify;
class ObjectManageRequest;
class ObjectManageNotify;
class ObjectManageResponse;
class FeedbackNotify;
class SearchRequest;
class SearchAbortRequest;
class SearchResultNotify;
class SearchResponse;
class SearchStateRequest;
class SearchStateResponse;
class GetFileRequest;
class GetFileResponse;
class AddLangSampRequest;
class AddLangSampResponse;
class OperationStatus;
class PreprocessResult;
class SpeakerResult;
class SpeakerItem;
class KeywordResult;
class KeywordSnippet;
class TranscriptResult;
class SegmentTranscript;
class SpeakerRule;
class KeywordRule;
class SpeechSegRule;
class LanguageInfo;
class TrainInfo;
class PhoneNumber;
class SearchTaskState;
class SystemCode;
class SearchFileResult;
class SpeechSegResult;
class SpeechSegItem;
class VADResult;
class VADItem;
class DTMFResult;
class DTMFItem;
class SystemStateItem;
class FileDataNotify;

enum MsgType {
  MSG_UNKNOWN = 0,
  MSG_CONNECT_REQ = 1,
  MSG_CONNECT_RESP = 2,
  MSG_CONNECT_RELEASE = 8,
  MSG_ECHO_REQ = 17,
  MSG_ECHO_RESP = 18,
  MSG_CALL_PROCESS_REQ = 33,
  MSG_CALL_PROCESS_RESP = 34,
  MSG_HISTORY_SEARCH_REQ = 65,
  MSG_HISTORY_SEARCH_RESP = 66,
  MSG_HISTORY_TRANS_REQ = 67,
  MSG_HISTORY_TRANS_RESP = 68,
  MSG_FILE_LOCATION_NOTIFY = 69,
  MSG_TARGET_QUERY_REQ = 71,
  MSG_TARGET_QUERY_RESP = 72,
  MSG_SET_RULE_REQ = 4097,
  MSG_SET_RULE_RESP = 4098,
  MSG_QUERY_RULE_REQ = 4099,
  MSG_QUERY_RULE_RESP = 4100,
  MSG_SET_SYSPARA_REQ = 4105,
  MSG_SET_SYSPARA_RESP = 4106,
  MSG_QUERY_SYSPARA_REQ = 4113,
  MSG_QUERY_SYSPARA_RESP = 4114,
  MSG_ALARM_NOTIFY = 4116,
  MSG_STAT_NOTIFY = 4118,
  MSG_OBJECT_MANAGE_REQ = 4119,
  MSG_OBJECT_MANAGE_RESP = 4120,
  MSG_FEED_BACK_NOTIFY = 4121,
  MSG_SEARCH_REQ = 1025,
  MSG_SEARCH_ABORT_REQ = 1026,
  MSG_SEARCH_RESULT = 1027,
  MSG_SEARCH_RESP = 1028,
  MSG_SEARCH_STATE_REQ = 1029,
  MSG_SEARCH_STATE_RESP = 1030,
  MSG_GET_FILE_REQ = 1031,
  MSG_GET_FILE_RESP = 1032,
  MSG_ADD_LANG_SAMP_REQ = 1033,
  MSG_ADD_LANG_SAMP_RESP = 1034,
  MSG_OBJECT_MANAGE_NOTIFY = 1035
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = MSG_UNKNOWN;
const MsgType MsgType_MAX = MSG_FEED_BACK_NOTIFY;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum AudioRecordMode {
  ARM_Unknown = 0,
  ARM_Combination = 1,
  ARM_Separation = 2
};
bool AudioRecordMode_IsValid(int value);
const AudioRecordMode AudioRecordMode_MIN = ARM_Unknown;
const AudioRecordMode AudioRecordMode_MAX = ARM_Separation;
const int AudioRecordMode_ARRAYSIZE = AudioRecordMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* AudioRecordMode_descriptor();
inline const ::std::string& AudioRecordMode_Name(AudioRecordMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    AudioRecordMode_descriptor(), value);
}
inline bool AudioRecordMode_Parse(
    const ::std::string& name, AudioRecordMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioRecordMode>(
    AudioRecordMode_descriptor(), name, value);
}
enum AudioChannelType {
  ACT_Unknown = 0,
  ACT_Pcm = 1,
  ACT_Voip = 2,
  ACT_TwoLines = 3,
  ACT_AirSignal = 4,
  ACT_WX = 5
};
bool AudioChannelType_IsValid(int value);
const AudioChannelType AudioChannelType_MIN = ACT_Unknown;
const AudioChannelType AudioChannelType_MAX = ACT_WX;
const int AudioChannelType_ARRAYSIZE = AudioChannelType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AudioChannelType_descriptor();
inline const ::std::string& AudioChannelType_Name(AudioChannelType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AudioChannelType_descriptor(), value);
}
inline bool AudioChannelType_Parse(
    const ::std::string& name, AudioChannelType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioChannelType>(
    AudioChannelType_descriptor(), name, value);
}
enum AudioTransFlag {
  ATF_Unknown = 0,
  ATF_Trans = 1,
  ATF_NotTrans = 2
};
bool AudioTransFlag_IsValid(int value);
const AudioTransFlag AudioTransFlag_MIN = ATF_Unknown;
const AudioTransFlag AudioTransFlag_MAX = ATF_NotTrans;
const int AudioTransFlag_ARRAYSIZE = AudioTransFlag_MAX + 1;

const ::google::protobuf::EnumDescriptor* AudioTransFlag_descriptor();
inline const ::std::string& AudioTransFlag_Name(AudioTransFlag value) {
  return ::google::protobuf::internal::NameOfEnum(
    AudioTransFlag_descriptor(), value);
}
inline bool AudioTransFlag_Parse(
    const ::std::string& name, AudioTransFlag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioTransFlag>(
    AudioTransFlag_descriptor(), name, value);
}
enum AudioFileTag {
  AFT_Unknown = 0,
  AFT_Combination = 1,
  AFT_Caller_ClusterA = 2,
  AFT_Callee_ClusterB = 3,
  AFT_Third_ClusterC = 4,
  AFT_NoTag = 5
};
bool AudioFileTag_IsValid(int value);
const AudioFileTag AudioFileTag_MIN = AFT_Unknown;
const AudioFileTag AudioFileTag_MAX = AFT_NoTag;
const int AudioFileTag_ARRAYSIZE = AudioFileTag_MAX + 1;

const ::google::protobuf::EnumDescriptor* AudioFileTag_descriptor();
inline const ::std::string& AudioFileTag_Name(AudioFileTag value) {
  return ::google::protobuf::internal::NameOfEnum(
    AudioFileTag_descriptor(), value);
}
inline bool AudioFileTag_Parse(
    const ::std::string& name, AudioFileTag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioFileTag>(
    AudioFileTag_descriptor(), name, value);
}
enum RecognitionType {
  RT_UnknownResult = 0,
  RT_SpeakerResult = 1,
  RT_KeywordResult = 2,
  RT_PreprocessResult = 3,
  RT_TranscriptResult = 4
};
bool RecognitionType_IsValid(int value);
const RecognitionType RecognitionType_MIN = RT_UnknownResult;
const RecognitionType RecognitionType_MAX = RT_TranscriptResult;
const int RecognitionType_ARRAYSIZE = RecognitionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RecognitionType_descriptor();
inline const ::std::string& RecognitionType_Name(RecognitionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RecognitionType_descriptor(), value);
}
inline bool RecognitionType_Parse(
    const ::std::string& name, RecognitionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecognitionType>(
    RecognitionType_descriptor(), name, value);
}
enum PriorityType {
  PT_Unknown = 0,
  PT_High = 1,
  PT_Normal = 2,
  PT_Low = 3
};
bool PriorityType_IsValid(int value);
const PriorityType PriorityType_MIN = PT_Unknown;
const PriorityType PriorityType_MAX = PT_Low;
const int PriorityType_ARRAYSIZE = PriorityType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PriorityType_descriptor();
inline const ::std::string& PriorityType_Name(PriorityType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PriorityType_descriptor(), value);
}
inline bool PriorityType_Parse(
    const ::std::string& name, PriorityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PriorityType>(
    PriorityType_descriptor(), name, value);
}
enum SearchCondition {
  SC_Unknown = 0,
  SC_SpeakerResult = 1,
  SC_KeywordResult = 2,
  SC_LanguageResult = 3,
  SC_TranscriptResult = 4,
  SC_VAD = 5,
  SC_DTMF = 6,
  SC_SpeechSegment = 7
};
bool SearchCondition_IsValid(int value);
const SearchCondition SearchCondition_MIN = SC_Unknown;
const SearchCondition SearchCondition_MAX = SC_SpeechSegment;
const int SearchCondition_ARRAYSIZE = SearchCondition_MAX + 1;

const ::google::protobuf::EnumDescriptor* SearchCondition_descriptor();
inline const ::std::string& SearchCondition_Name(SearchCondition value) {
  return ::google::protobuf::internal::NameOfEnum(
    SearchCondition_descriptor(), value);
}
inline bool SearchCondition_Parse(
    const ::std::string& name, SearchCondition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SearchCondition>(
    SearchCondition_descriptor(), name, value);
}
enum SpeechType {
  ST_Unknown = 0,
  ST_Voice = 1,
  ST_DTMF = 2,
  ST_Music = 3,
  ST_Quiet = 4,
  ST_NonVoice = 5
};
bool SpeechType_IsValid(int value);
const SpeechType SpeechType_MIN = ST_Unknown;
const SpeechType SpeechType_MAX = ST_NonVoice;
const int SpeechType_ARRAYSIZE = SpeechType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SpeechType_descriptor();
inline const ::std::string& SpeechType_Name(SpeechType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SpeechType_descriptor(), value);
}
inline bool SpeechType_Parse(
    const ::std::string& name, SpeechType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpeechType>(
    SpeechType_descriptor(), name, value);
}
enum AudioEncodingTag {
  AET_Unknown = 0,
  AET_ALaw = 1,
  AET_Gsm610 = 2,
  AET_G726 = 3,
  AET_LinearPCM = 4,
  AET_G723_16 = 5,
  AET_G723_15 = 6,
  AET_G729 = 7,
  AET_ULaw = 8,
  AET_INTEL_G723 = 9,
  AET_INTEL_G729 = 10,
  AET_INTEL_GSM690 = 11,
  AET_AMR_NB = 12,
  AET_GSM_EFR = 13
};
bool AudioEncodingTag_IsValid(int value);
const AudioEncodingTag AudioEncodingTag_MIN = AET_Unknown;
const AudioEncodingTag AudioEncodingTag_MAX = AET_GSM_EFR;
const int AudioEncodingTag_ARRAYSIZE = AudioEncodingTag_MAX + 1;

const ::google::protobuf::EnumDescriptor* AudioEncodingTag_descriptor();
inline const ::std::string& AudioEncodingTag_Name(AudioEncodingTag value) {
  return ::google::protobuf::internal::NameOfEnum(
    AudioEncodingTag_descriptor(), value);
}
inline bool AudioEncodingTag_Parse(
    const ::std::string& name, AudioEncodingTag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioEncodingTag>(
    AudioEncodingTag_descriptor(), name, value);
}
enum OperationType {
  OT_Unknown = 0,
  OT_Create = 1,
  OT_Delete = 2,
  OT_Update = 3
};
bool OperationType_IsValid(int value);
const OperationType OperationType_MIN = OT_Unknown;
const OperationType OperationType_MAX = OT_Update;
const int OperationType_ARRAYSIZE = OperationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OperationType_descriptor();
inline const ::std::string& OperationType_Name(OperationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OperationType_descriptor(), value);
}
inline bool OperationType_Parse(
    const ::std::string& name, OperationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OperationType>(
    OperationType_descriptor(), name, value);
}
enum RuleType {
  RT_Unknown = 0,
  RT_Speaker = 1,
  RT_Keyword = 2,
  RT_SpeechSegment = 3
};
bool RuleType_IsValid(int value);
const RuleType RuleType_MIN = RT_Unknown;
const RuleType RuleType_MAX = RT_SpeechSegment;
const int RuleType_ARRAYSIZE = RuleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RuleType_descriptor();
inline const ::std::string& RuleType_Name(RuleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RuleType_descriptor(), value);
}
inline bool RuleType_Parse(
    const ::std::string& name, RuleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RuleType>(
    RuleType_descriptor(), name, value);
}
enum SystemParaType {
  SPT_Unknown = 0,
  SPT_LanguageThreshold = 1,
  SPT_SpeakerThreshold = 2,
  SPT_KeywordThreshold = 3,
  SPT_LanguageRetCount = 4,
  SPT_SpeakerRetCount = 5
};
bool SystemParaType_IsValid(int value);
const SystemParaType SystemParaType_MIN = SPT_Unknown;
const SystemParaType SystemParaType_MAX = SPT_SpeakerRetCount;
const int SystemParaType_ARRAYSIZE = SystemParaType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SystemParaType_descriptor();
inline const ::std::string& SystemParaType_Name(SystemParaType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SystemParaType_descriptor(), value);
}
inline bool SystemParaType_Parse(
    const ::std::string& name, SystemParaType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SystemParaType>(
    SystemParaType_descriptor(), name, value);
}
enum AlarmLevel {
  AL_Unknown = 0,
  AL_General = 1,
  AL_Important = 2,
  AL_Urgent = 3
};
bool AlarmLevel_IsValid(int value);
const AlarmLevel AlarmLevel_MIN = AL_Unknown;
const AlarmLevel AlarmLevel_MAX = AL_Urgent;
const int AlarmLevel_ARRAYSIZE = AlarmLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* AlarmLevel_descriptor();
inline const ::std::string& AlarmLevel_Name(AlarmLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    AlarmLevel_descriptor(), value);
}
inline bool AlarmLevel_Parse(
    const ::std::string& name, AlarmLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AlarmLevel>(
    AlarmLevel_descriptor(), name, value);
}
enum AudioRecogFlag {
  ARF_Unknown = 0,
  ARF_Preprocess = 1,
  ARF_Speaker = 2,
  ARF_Keyword = 4,
  ARF_Transcript = 8,
  ARF_VAD = 16,
  ARF_SpeechSegment = 32,
  ARF_DTMF = 64
};
bool AudioRecogFlag_IsValid(int value);
const AudioRecogFlag AudioRecogFlag_MIN = ARF_Unknown;
const AudioRecogFlag AudioRecogFlag_MAX = ARF_DTMF;
const int AudioRecogFlag_ARRAYSIZE = AudioRecogFlag_MAX + 1;

const ::google::protobuf::EnumDescriptor* AudioRecogFlag_descriptor();
inline const ::std::string& AudioRecogFlag_Name(AudioRecogFlag value) {
  return ::google::protobuf::internal::NameOfEnum(
    AudioRecogFlag_descriptor(), value);
}
inline bool AudioRecogFlag_Parse(
    const ::std::string& name, AudioRecogFlag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioRecogFlag>(
    AudioRecogFlag_descriptor(), name, value);
}
enum FileAcquireMethod {
  FAM_Unknown = 0,
  FAM_URL = 1,
  FAM_Data = 2
};
bool FileAcquireMethod_IsValid(int value);
const FileAcquireMethod FileAcquireMethod_MIN = FAM_Unknown;
const FileAcquireMethod FileAcquireMethod_MAX = FAM_Data;
const int FileAcquireMethod_ARRAYSIZE = FileAcquireMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileAcquireMethod_descriptor();
inline const ::std::string& FileAcquireMethod_Name(FileAcquireMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileAcquireMethod_descriptor(), value);
}
inline bool FileAcquireMethod_Parse(
    const ::std::string& name, FileAcquireMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileAcquireMethod>(
    FileAcquireMethod_descriptor(), name, value);
}
enum SearchTaskType {
  STT_Unknown = 0,
  STT_CondToVoice = 1,
  STT_VoiceToVoice = 2,
  STT_VoiceToObject = 3
};
bool SearchTaskType_IsValid(int value);
const SearchTaskType SearchTaskType_MIN = STT_Unknown;
const SearchTaskType SearchTaskType_MAX = STT_VoiceToObject;
const int SearchTaskType_ARRAYSIZE = SearchTaskType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SearchTaskType_descriptor();
inline const ::std::string& SearchTaskType_Name(SearchTaskType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SearchTaskType_descriptor(), value);
}
inline bool SearchTaskType_Parse(
    const ::std::string& name, SearchTaskType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SearchTaskType>(
    SearchTaskType_descriptor(), name, value);
}
enum SearchTaskRunState {
  STRS_Unknown = 0,
  STRS_Queue = 1,
  STRS_Running = 2,
  STRS_Finish = 3,
  STRS_Abort = 4,
  STRS_Error = 5
};
bool SearchTaskRunState_IsValid(int value);
const SearchTaskRunState SearchTaskRunState_MIN = STRS_Unknown;
const SearchTaskRunState SearchTaskRunState_MAX = STRS_Error;
const int SearchTaskRunState_ARRAYSIZE = SearchTaskRunState_MAX + 1;

const ::google::protobuf::EnumDescriptor* SearchTaskRunState_descriptor();
inline const ::std::string& SearchTaskRunState_Name(SearchTaskRunState value) {
  return ::google::protobuf::internal::NameOfEnum(
    SearchTaskRunState_descriptor(), value);
}
inline bool SearchTaskRunState_Parse(
    const ::std::string& name, SearchTaskRunState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SearchTaskRunState>(
    SearchTaskRunState_descriptor(), name, value);
}
enum GenderType {
  GT_Unknown = 0,
  GT_Male = 1,
  GT_Female = 2,
  GT_Both = 3
};
bool GenderType_IsValid(int value);
const GenderType GenderType_MIN = GT_Unknown;
const GenderType GenderType_MAX = GT_Both;
const int GenderType_ARRAYSIZE = GenderType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GenderType_descriptor();
inline const ::std::string& GenderType_Name(GenderType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GenderType_descriptor(), value);
}
inline bool GenderType_Parse(
    const ::std::string& name, GenderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GenderType>(
    GenderType_descriptor(), name, value);
}
// ===================================================================

class HeadMsg : public ::google::protobuf::Message {
 public:
  HeadMsg();
  virtual ~HeadMsg();

  HeadMsg(const HeadMsg& from);

  inline HeadMsg& operator=(const HeadMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeadMsg& default_instance();

  void Swap(HeadMsg* other);

  // implements Message ----------------------------------------------

  HeadMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeadMsg& from);
  void MergeFrom(const HeadMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 syn = 1 [default = 255];
  inline bool has_syn() const;
  inline void clear_syn();
  static const int kSynFieldNumber = 1;
  inline ::google::protobuf::uint32 syn() const;
  inline void set_syn(::google::protobuf::uint32 value);

  // required fixed32 pro = 2 [default = 100];
  inline bool has_pro() const;
  inline void clear_pro();
  static const int kProFieldNumber = 2;
  inline ::google::protobuf::uint32 pro() const;
  inline void set_pro(::google::protobuf::uint32 value);

  // required fixed32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required fixed64 seqno = 4;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 4;
  inline ::google::protobuf::uint64 seqno() const;
  inline void set_seqno(::google::protobuf::uint64 value);

  // required fixed32 len = 5;
  inline bool has_len() const;
  inline void clear_len();
  static const int kLenFieldNumber = 5;
  inline ::google::protobuf::uint32 len() const;
  inline void set_len(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PBMidLayer.HeadMsg)
 private:
  inline void set_has_syn();
  inline void clear_has_syn();
  inline void set_has_pro();
  inline void clear_has_pro();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_len();
  inline void clear_has_len();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 syn_;
  ::google::protobuf::uint32 pro_;
  ::google::protobuf::uint64 seqno_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static HeadMsg* default_instance_;
};
// -------------------------------------------------------------------

class ConnectRequest : public ::google::protobuf::Message {
 public:
  ConnectRequest();
  virtual ~ConnectRequest();

  ConnectRequest(const ConnectRequest& from);

  inline ConnectRequest& operator=(const ConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectRequest& default_instance();

  void Swap(ConnectRequest* other);

  // implements Message ----------------------------------------------

  ConnectRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectRequest& from);
  void MergeFrom(const ConnectRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string spyid = 1;
  inline bool has_spyid() const;
  inline void clear_spyid();
  static const int kSpyidFieldNumber = 1;
  inline const ::std::string& spyid() const;
  inline void set_spyid(const ::std::string& value);
  inline void set_spyid(const char* value);
  inline void set_spyid(const char* value, size_t size);
  inline ::std::string* mutable_spyid();
  inline ::std::string* release_spyid();
  inline void set_allocated_spyid(::std::string* spyid);

  // optional string srid = 2;
  inline bool has_srid() const;
  inline void clear_srid();
  static const int kSridFieldNumber = 2;
  inline const ::std::string& srid() const;
  inline void set_srid(const ::std::string& value);
  inline void set_srid(const char* value);
  inline void set_srid(const char* value, size_t size);
  inline ::std::string* mutable_srid();
  inline ::std::string* release_srid();
  inline void set_allocated_srid(::std::string* srid);

  // @@protoc_insertion_point(class_scope:PBMidLayer.ConnectRequest)
 private:
  inline void set_has_spyid();
  inline void clear_has_spyid();
  inline void set_has_srid();
  inline void clear_has_srid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* spyid_;
  ::std::string* srid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static ConnectRequest* default_instance_;
};
// -------------------------------------------------------------------

class ConnectResponse : public ::google::protobuf::Message {
 public:
  ConnectResponse();
  virtual ~ConnectResponse();

  ConnectResponse(const ConnectResponse& from);

  inline ConnectResponse& operator=(const ConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectResponse& default_instance();

  void Swap(ConnectResponse* other);

  // implements Message ----------------------------------------------

  ConnectResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectResponse& from);
  void MergeFrom(const ConnectResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMidLayer.OperationStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::PBMidLayer::OperationStatus& status() const;
  inline ::PBMidLayer::OperationStatus* mutable_status();
  inline ::PBMidLayer::OperationStatus* release_status();
  inline void set_allocated_status(::PBMidLayer::OperationStatus* status);

  // required string spyid = 2;
  inline bool has_spyid() const;
  inline void clear_spyid();
  static const int kSpyidFieldNumber = 2;
  inline const ::std::string& spyid() const;
  inline void set_spyid(const ::std::string& value);
  inline void set_spyid(const char* value);
  inline void set_spyid(const char* value, size_t size);
  inline ::std::string* mutable_spyid();
  inline ::std::string* release_spyid();
  inline void set_allocated_spyid(::std::string* spyid);

  // optional string srid = 3;
  inline bool has_srid() const;
  inline void clear_srid();
  static const int kSridFieldNumber = 3;
  inline const ::std::string& srid() const;
  inline void set_srid(const ::std::string& value);
  inline void set_srid(const char* value);
  inline void set_srid(const char* value, size_t size);
  inline ::std::string* mutable_srid();
  inline ::std::string* release_srid();
  inline void set_allocated_srid(::std::string* srid);

  // @@protoc_insertion_point(class_scope:PBMidLayer.ConnectResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_spyid();
  inline void clear_has_spyid();
  inline void set_has_srid();
  inline void clear_has_srid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PBMidLayer::OperationStatus* status_;
  ::std::string* spyid_;
  ::std::string* srid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static ConnectResponse* default_instance_;
};
// -------------------------------------------------------------------

class ConnectRelease : public ::google::protobuf::Message {
 public:
  ConnectRelease();
  virtual ~ConnectRelease();

  ConnectRelease(const ConnectRelease& from);

  inline ConnectRelease& operator=(const ConnectRelease& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectRelease& default_instance();

  void Swap(ConnectRelease* other);

  // implements Message ----------------------------------------------

  ConnectRelease* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectRelease& from);
  void MergeFrom(const ConnectRelease& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMidLayer.OperationStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::PBMidLayer::OperationStatus& status() const;
  inline ::PBMidLayer::OperationStatus* mutable_status();
  inline ::PBMidLayer::OperationStatus* release_status();
  inline void set_allocated_status(::PBMidLayer::OperationStatus* status);

  // required string spyid = 2;
  inline bool has_spyid() const;
  inline void clear_spyid();
  static const int kSpyidFieldNumber = 2;
  inline const ::std::string& spyid() const;
  inline void set_spyid(const ::std::string& value);
  inline void set_spyid(const char* value);
  inline void set_spyid(const char* value, size_t size);
  inline ::std::string* mutable_spyid();
  inline ::std::string* release_spyid();
  inline void set_allocated_spyid(::std::string* spyid);

  // optional string srid = 3;
  inline bool has_srid() const;
  inline void clear_srid();
  static const int kSridFieldNumber = 3;
  inline const ::std::string& srid() const;
  inline void set_srid(const ::std::string& value);
  inline void set_srid(const char* value);
  inline void set_srid(const char* value, size_t size);
  inline ::std::string* mutable_srid();
  inline ::std::string* release_srid();
  inline void set_allocated_srid(::std::string* srid);

  // @@protoc_insertion_point(class_scope:PBMidLayer.ConnectRelease)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_spyid();
  inline void clear_has_spyid();
  inline void set_has_srid();
  inline void clear_has_srid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PBMidLayer::OperationStatus* status_;
  ::std::string* spyid_;
  ::std::string* srid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static ConnectRelease* default_instance_;
};
// -------------------------------------------------------------------

class EchoReqRes : public ::google::protobuf::Message {
 public:
  EchoReqRes();
  virtual ~EchoReqRes();

  EchoReqRes(const EchoReqRes& from);

  inline EchoReqRes& operator=(const EchoReqRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EchoReqRes& default_instance();

  void Swap(EchoReqRes* other);

  // implements Message ----------------------------------------------

  EchoReqRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EchoReqRes& from);
  void MergeFrom(const EchoReqRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PBMidLayer.EchoReqRes)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static EchoReqRes* default_instance_;
};
// -------------------------------------------------------------------

class CallProcessRequest : public ::google::protobuf::Message {
 public:
  CallProcessRequest();
  virtual ~CallProcessRequest();

  CallProcessRequest(const CallProcessRequest& from);

  inline CallProcessRequest& operator=(const CallProcessRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CallProcessRequest& default_instance();

  void Swap(CallProcessRequest* other);

  // implements Message ----------------------------------------------

  CallProcessRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CallProcessRequest& from);
  void MergeFrom(const CallProcessRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string callid = 1;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 1;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // required .PBMidLayer.AudioRecordMode flag = 2;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 2;
  inline ::PBMidLayer::AudioRecordMode flag() const;
  inline void set_flag(::PBMidLayer::AudioRecordMode value);

  // required int32 terminals = 3;
  inline bool has_terminals() const;
  inline void clear_terminals();
  static const int kTerminalsFieldNumber = 3;
  inline ::google::protobuf::int32 terminals() const;
  inline void set_terminals(::google::protobuf::int32 value);

  // required .PBMidLayer.AudioChannelType channeltype = 4;
  inline bool has_channeltype() const;
  inline void clear_channeltype();
  static const int kChanneltypeFieldNumber = 4;
  inline ::PBMidLayer::AudioChannelType channeltype() const;
  inline void set_channeltype(::PBMidLayer::AudioChannelType value);

  // required .PBMidLayer.AudioTransFlag transflag = 5 [default = ATF_NotTrans];
  inline bool has_transflag() const;
  inline void clear_transflag();
  static const int kTransflagFieldNumber = 5;
  inline ::PBMidLayer::AudioTransFlag transflag() const;
  inline void set_transflag(::PBMidLayer::AudioTransFlag value);

  // optional string caller = 6;
  inline bool has_caller() const;
  inline void clear_caller();
  static const int kCallerFieldNumber = 6;
  inline const ::std::string& caller() const;
  inline void set_caller(const ::std::string& value);
  inline void set_caller(const char* value);
  inline void set_caller(const char* value, size_t size);
  inline ::std::string* mutable_caller();
  inline ::std::string* release_caller();
  inline void set_allocated_caller(::std::string* caller);

  // optional string callee = 7;
  inline bool has_callee() const;
  inline void clear_callee();
  static const int kCalleeFieldNumber = 7;
  inline const ::std::string& callee() const;
  inline void set_callee(const ::std::string& value);
  inline void set_callee(const char* value);
  inline void set_callee(const char* value, size_t size);
  inline ::std::string* mutable_callee();
  inline ::std::string* release_callee();
  inline void set_allocated_callee(::std::string* callee);

  // optional string third = 8;
  inline bool has_third() const;
  inline void clear_third();
  static const int kThirdFieldNumber = 8;
  inline const ::std::string& third() const;
  inline void set_third(const ::std::string& value);
  inline void set_third(const char* value);
  inline void set_third(const char* value, size_t size);
  inline ::std::string* mutable_third();
  inline ::std::string* release_third();
  inline void set_allocated_third(::std::string* third);

  // optional uint64 starttime = 9;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 9;
  inline ::google::protobuf::uint64 starttime() const;
  inline void set_starttime(::google::protobuf::uint64 value);

  // optional uint64 endtime = 10;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 10;
  inline ::google::protobuf::uint64 endtime() const;
  inline void set_endtime(::google::protobuf::uint64 value);

  // optional uint32 recogflag = 11 [default = 7];
  inline bool has_recogflag() const;
  inline void clear_recogflag();
  static const int kRecogflagFieldNumber = 11;
  inline ::google::protobuf::uint32 recogflag() const;
  inline void set_recogflag(::google::protobuf::uint32 value);

  // optional .PBMidLayer.FileAcquireMethod method = 12 [default = FAM_URL];
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 12;
  inline ::PBMidLayer::FileAcquireMethod method() const;
  inline void set_method(::PBMidLayer::FileAcquireMethod value);

  // optional .PBMidLayer.PhoneNumber callerappendix = 13;
  inline bool has_callerappendix() const;
  inline void clear_callerappendix();
  static const int kCallerappendixFieldNumber = 13;
  inline const ::PBMidLayer::PhoneNumber& callerappendix() const;
  inline ::PBMidLayer::PhoneNumber* mutable_callerappendix();
  inline ::PBMidLayer::PhoneNumber* release_callerappendix();
  inline void set_allocated_callerappendix(::PBMidLayer::PhoneNumber* callerappendix);

  // optional .PBMidLayer.PhoneNumber calleeappendix = 14;
  inline bool has_calleeappendix() const;
  inline void clear_calleeappendix();
  static const int kCalleeappendixFieldNumber = 14;
  inline const ::PBMidLayer::PhoneNumber& calleeappendix() const;
  inline ::PBMidLayer::PhoneNumber* mutable_calleeappendix();
  inline ::PBMidLayer::PhoneNumber* release_calleeappendix();
  inline void set_allocated_calleeappendix(::PBMidLayer::PhoneNumber* calleeappendix);

  // optional .PBMidLayer.PhoneNumber thirdappendix = 15;
  inline bool has_thirdappendix() const;
  inline void clear_thirdappendix();
  static const int kThirdappendixFieldNumber = 15;
  inline const ::PBMidLayer::PhoneNumber& thirdappendix() const;
  inline ::PBMidLayer::PhoneNumber* mutable_thirdappendix();
  inline ::PBMidLayer::PhoneNumber* release_thirdappendix();
  inline void set_allocated_thirdappendix(::PBMidLayer::PhoneNumber* thirdappendix);

  // optional .PBMidLayer.PriorityType priority = 16 [default = PT_Normal];
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 16;
  inline ::PBMidLayer::PriorityType priority() const;
  inline void set_priority(::PBMidLayer::PriorityType value);

  // optional .PBMidLayer.SystemCode syscode = 17;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 17;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // optional bool isimport = 18;
  inline bool has_isimport() const;
  inline void clear_isimport();
  static const int kIsimportFieldNumber = 18;
  inline bool isimport() const;
  inline void set_isimport(bool value);

  // repeated .PBMidLayer.FileLocationNotify voicefiles = 19;
  inline int voicefiles_size() const;
  inline void clear_voicefiles();
  static const int kVoicefilesFieldNumber = 19;
  inline const ::PBMidLayer::FileLocationNotify& voicefiles(int index) const;
  inline ::PBMidLayer::FileLocationNotify* mutable_voicefiles(int index);
  inline ::PBMidLayer::FileLocationNotify* add_voicefiles();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::FileLocationNotify >&
      voicefiles() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::FileLocationNotify >*
      mutable_voicefiles();

  // @@protoc_insertion_point(class_scope:PBMidLayer.CallProcessRequest)
 private:
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_terminals();
  inline void clear_has_terminals();
  inline void set_has_channeltype();
  inline void clear_has_channeltype();
  inline void set_has_transflag();
  inline void clear_has_transflag();
  inline void set_has_caller();
  inline void clear_has_caller();
  inline void set_has_callee();
  inline void clear_has_callee();
  inline void set_has_third();
  inline void clear_has_third();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_recogflag();
  inline void clear_has_recogflag();
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_callerappendix();
  inline void clear_has_callerappendix();
  inline void set_has_calleeappendix();
  inline void clear_has_calleeappendix();
  inline void set_has_thirdappendix();
  inline void clear_has_thirdappendix();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_syscode();
  inline void clear_has_syscode();
  inline void set_has_isimport();
  inline void clear_has_isimport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* callid_;
  int flag_;
  ::google::protobuf::int32 terminals_;
  int channeltype_;
  int transflag_;
  ::std::string* caller_;
  ::std::string* callee_;
  ::std::string* third_;
  ::google::protobuf::uint64 starttime_;
  ::google::protobuf::uint64 endtime_;
  ::google::protobuf::uint32 recogflag_;
  int method_;
  ::PBMidLayer::PhoneNumber* callerappendix_;
  ::PBMidLayer::PhoneNumber* calleeappendix_;
  ::PBMidLayer::PhoneNumber* thirdappendix_;
  ::PBMidLayer::SystemCode* syscode_;
  int priority_;
  bool isimport_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::FileLocationNotify > voicefiles_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static CallProcessRequest* default_instance_;
};
// -------------------------------------------------------------------

class CallProcessResponse : public ::google::protobuf::Message {
 public:
  CallProcessResponse();
  virtual ~CallProcessResponse();

  CallProcessResponse(const CallProcessResponse& from);

  inline CallProcessResponse& operator=(const CallProcessResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CallProcessResponse& default_instance();

  void Swap(CallProcessResponse* other);

  // implements Message ----------------------------------------------

  CallProcessResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CallProcessResponse& from);
  void MergeFrom(const CallProcessResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string callid = 1;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 1;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // required .PBMidLayer.OperationStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::PBMidLayer::OperationStatus& status() const;
  inline ::PBMidLayer::OperationStatus* mutable_status();
  inline ::PBMidLayer::OperationStatus* release_status();
  inline void set_allocated_status(::PBMidLayer::OperationStatus* status);

  // required .PBMidLayer.AudioFileTag filetag = 3;
  inline bool has_filetag() const;
  inline void clear_filetag();
  static const int kFiletagFieldNumber = 3;
  inline ::PBMidLayer::AudioFileTag filetag() const;
  inline void set_filetag(::PBMidLayer::AudioFileTag value);

  // optional .PBMidLayer.RecognitionType recotype = 4;
  inline bool has_recotype() const;
  inline void clear_recotype();
  static const int kRecotypeFieldNumber = 4;
  inline ::PBMidLayer::RecognitionType recotype() const;
  inline void set_recotype(::PBMidLayer::RecognitionType value);

  // optional uint32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional .PBMidLayer.PreprocessResult prelist = 6;
  inline bool has_prelist() const;
  inline void clear_prelist();
  static const int kPrelistFieldNumber = 6;
  inline const ::PBMidLayer::PreprocessResult& prelist() const;
  inline ::PBMidLayer::PreprocessResult* mutable_prelist();
  inline ::PBMidLayer::PreprocessResult* release_prelist();
  inline void set_allocated_prelist(::PBMidLayer::PreprocessResult* prelist);

  // optional .PBMidLayer.SpeakerResult speakerlist = 7;
  inline bool has_speakerlist() const;
  inline void clear_speakerlist();
  static const int kSpeakerlistFieldNumber = 7;
  inline const ::PBMidLayer::SpeakerResult& speakerlist() const;
  inline ::PBMidLayer::SpeakerResult* mutable_speakerlist();
  inline ::PBMidLayer::SpeakerResult* release_speakerlist();
  inline void set_allocated_speakerlist(::PBMidLayer::SpeakerResult* speakerlist);

  // optional .PBMidLayer.KeywordResult keywordlist = 8;
  inline bool has_keywordlist() const;
  inline void clear_keywordlist();
  static const int kKeywordlistFieldNumber = 8;
  inline const ::PBMidLayer::KeywordResult& keywordlist() const;
  inline ::PBMidLayer::KeywordResult* mutable_keywordlist();
  inline ::PBMidLayer::KeywordResult* release_keywordlist();
  inline void set_allocated_keywordlist(::PBMidLayer::KeywordResult* keywordlist);

  // optional .PBMidLayer.TranscriptResult translist = 9;
  inline bool has_translist() const;
  inline void clear_translist();
  static const int kTranslistFieldNumber = 9;
  inline const ::PBMidLayer::TranscriptResult& translist() const;
  inline ::PBMidLayer::TranscriptResult* mutable_translist();
  inline ::PBMidLayer::TranscriptResult* release_translist();
  inline void set_allocated_translist(::PBMidLayer::TranscriptResult* translist);

  // optional .PBMidLayer.VADResult vad = 10;
  inline bool has_vad() const;
  inline void clear_vad();
  static const int kVadFieldNumber = 10;
  inline const ::PBMidLayer::VADResult& vad() const;
  inline ::PBMidLayer::VADResult* mutable_vad();
  inline ::PBMidLayer::VADResult* release_vad();
  inline void set_allocated_vad(::PBMidLayer::VADResult* vad);

  // optional .PBMidLayer.SpeechSegResult speechseg = 11;
  inline bool has_speechseg() const;
  inline void clear_speechseg();
  static const int kSpeechsegFieldNumber = 11;
  inline const ::PBMidLayer::SpeechSegResult& speechseg() const;
  inline ::PBMidLayer::SpeechSegResult* mutable_speechseg();
  inline ::PBMidLayer::SpeechSegResult* release_speechseg();
  inline void set_allocated_speechseg(::PBMidLayer::SpeechSegResult* speechseg);

  // optional .PBMidLayer.DTMFResult dtmfs = 12;
  inline bool has_dtmfs() const;
  inline void clear_dtmfs();
  static const int kDtmfsFieldNumber = 12;
  inline const ::PBMidLayer::DTMFResult& dtmfs() const;
  inline ::PBMidLayer::DTMFResult* mutable_dtmfs();
  inline ::PBMidLayer::DTMFResult* release_dtmfs();
  inline void set_allocated_dtmfs(::PBMidLayer::DTMFResult* dtmfs);

  // optional uint32 resultflag = 13 [default = 7];
  inline bool has_resultflag() const;
  inline void clear_resultflag();
  static const int kResultflagFieldNumber = 13;
  inline ::google::protobuf::uint32 resultflag() const;
  inline void set_resultflag(::google::protobuf::uint32 value);

  // optional uint64 starttime = 14;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 14;
  inline ::google::protobuf::uint64 starttime() const;
  inline void set_starttime(::google::protobuf::uint64 value);

  // optional .PBMidLayer.SystemCode syscode = 15;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 15;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.CallProcessResponse)
 private:
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_filetag();
  inline void clear_has_filetag();
  inline void set_has_recotype();
  inline void clear_has_recotype();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_prelist();
  inline void clear_has_prelist();
  inline void set_has_speakerlist();
  inline void clear_has_speakerlist();
  inline void set_has_keywordlist();
  inline void clear_has_keywordlist();
  inline void set_has_translist();
  inline void clear_has_translist();
  inline void set_has_vad();
  inline void clear_has_vad();
  inline void set_has_speechseg();
  inline void clear_has_speechseg();
  inline void set_has_dtmfs();
  inline void clear_has_dtmfs();
  inline void set_has_resultflag();
  inline void clear_has_resultflag();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* callid_;
  ::PBMidLayer::OperationStatus* status_;
  int filetag_;
  int recotype_;
  ::PBMidLayer::PreprocessResult* prelist_;
  ::PBMidLayer::SpeakerResult* speakerlist_;
  ::PBMidLayer::KeywordResult* keywordlist_;
  ::PBMidLayer::TranscriptResult* translist_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 resultflag_;
  ::PBMidLayer::VADResult* vad_;
  ::PBMidLayer::SpeechSegResult* speechseg_;
  ::PBMidLayer::DTMFResult* dtmfs_;
  ::google::protobuf::uint64 starttime_;
  ::PBMidLayer::SystemCode* syscode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static CallProcessResponse* default_instance_;
};
// -------------------------------------------------------------------

class HistorySearchRequest : public ::google::protobuf::Message {
 public:
  HistorySearchRequest();
  virtual ~HistorySearchRequest();

  HistorySearchRequest(const HistorySearchRequest& from);

  inline HistorySearchRequest& operator=(const HistorySearchRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistorySearchRequest& default_instance();

  void Swap(HistorySearchRequest* other);

  // implements Message ----------------------------------------------

  HistorySearchRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistorySearchRequest& from);
  void MergeFrom(const HistorySearchRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required int32 packageseq = 2;
  inline bool has_packageseq() const;
  inline void clear_packageseq();
  static const int kPackageseqFieldNumber = 2;
  inline ::google::protobuf::int32 packageseq() const;
  inline void set_packageseq(::google::protobuf::int32 value);

  // required int32 endflag = 3;
  inline bool has_endflag() const;
  inline void clear_endflag();
  static const int kEndflagFieldNumber = 3;
  inline ::google::protobuf::int32 endflag() const;
  inline void set_endflag(::google::protobuf::int32 value);

  // required int32 records = 4;
  inline bool has_records() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 4;
  inline ::google::protobuf::int32 records() const;
  inline void set_records(::google::protobuf::int32 value);

  // optional .PBMidLayer.TaskAttribute attribute = 5;
  inline bool has_attribute() const;
  inline void clear_attribute();
  static const int kAttributeFieldNumber = 5;
  inline const ::PBMidLayer::TaskAttribute& attribute() const;
  inline ::PBMidLayer::TaskAttribute* mutable_attribute();
  inline ::PBMidLayer::TaskAttribute* release_attribute();
  inline void set_allocated_attribute(::PBMidLayer::TaskAttribute* attribute);

  // repeated string calllist = 6;
  inline int calllist_size() const;
  inline void clear_calllist();
  static const int kCalllistFieldNumber = 6;
  inline const ::std::string& calllist(int index) const;
  inline ::std::string* mutable_calllist(int index);
  inline void set_calllist(int index, const ::std::string& value);
  inline void set_calllist(int index, const char* value);
  inline void set_calllist(int index, const char* value, size_t size);
  inline ::std::string* add_calllist();
  inline void add_calllist(const ::std::string& value);
  inline void add_calllist(const char* value);
  inline void add_calllist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& calllist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_calllist();

  // optional .PBMidLayer.SystemCode syscode = 7;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 7;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.HistorySearchRequest)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_packageseq();
  inline void clear_has_packageseq();
  inline void set_has_endflag();
  inline void clear_has_endflag();
  inline void set_has_records();
  inline void clear_has_records();
  inline void set_has_attribute();
  inline void clear_has_attribute();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::google::protobuf::int32 packageseq_;
  ::google::protobuf::int32 endflag_;
  ::PBMidLayer::TaskAttribute* attribute_;
  ::google::protobuf::RepeatedPtrField< ::std::string> calllist_;
  ::PBMidLayer::SystemCode* syscode_;
  ::google::protobuf::int32 records_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static HistorySearchRequest* default_instance_;
};
// -------------------------------------------------------------------

class TaskAttribute : public ::google::protobuf::Message {
 public:
  TaskAttribute();
  virtual ~TaskAttribute();

  TaskAttribute(const TaskAttribute& from);

  inline TaskAttribute& operator=(const TaskAttribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskAttribute& default_instance();

  void Swap(TaskAttribute* other);

  // implements Message ----------------------------------------------

  TaskAttribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskAttribute& from);
  void MergeFrom(const TaskAttribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // required .PBMidLayer.PriorityType priority = 2;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 2;
  inline ::PBMidLayer::PriorityType priority() const;
  inline void set_priority(::PBMidLayer::PriorityType value);

  // required .PBMidLayer.SearchCondition condition = 3;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 3;
  inline ::PBMidLayer::SearchCondition condition() const;
  inline void set_condition(::PBMidLayer::SearchCondition value);

  // repeated string objectids = 4;
  inline int objectids_size() const;
  inline void clear_objectids();
  static const int kObjectidsFieldNumber = 4;
  inline const ::std::string& objectids(int index) const;
  inline ::std::string* mutable_objectids(int index);
  inline void set_objectids(int index, const ::std::string& value);
  inline void set_objectids(int index, const char* value);
  inline void set_objectids(int index, const char* value, size_t size);
  inline ::std::string* add_objectids();
  inline void add_objectids(const ::std::string& value);
  inline void add_objectids(const char* value);
  inline void add_objectids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& objectids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_objectids();

  // optional string languagename = 5;
  inline bool has_languagename() const;
  inline void clear_languagename();
  static const int kLanguagenameFieldNumber = 5;
  inline const ::std::string& languagename() const;
  inline void set_languagename(const ::std::string& value);
  inline void set_languagename(const char* value);
  inline void set_languagename(const char* value, size_t size);
  inline ::std::string* mutable_languagename();
  inline ::std::string* release_languagename();
  inline void set_allocated_languagename(::std::string* languagename);

  // repeated string keywords = 6;
  inline int keywords_size() const;
  inline void clear_keywords();
  static const int kKeywordsFieldNumber = 6;
  inline const ::std::string& keywords(int index) const;
  inline ::std::string* mutable_keywords(int index);
  inline void set_keywords(int index, const ::std::string& value);
  inline void set_keywords(int index, const char* value);
  inline void set_keywords(int index, const char* value, size_t size);
  inline ::std::string* add_keywords();
  inline void add_keywords(const ::std::string& value);
  inline void add_keywords(const char* value);
  inline void add_keywords(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keywords() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keywords();

  // optional bytes voice = 7;
  inline bool has_voice() const;
  inline void clear_voice();
  static const int kVoiceFieldNumber = 7;
  inline const ::std::string& voice() const;
  inline void set_voice(const ::std::string& value);
  inline void set_voice(const char* value);
  inline void set_voice(const void* value, size_t size);
  inline ::std::string* mutable_voice();
  inline ::std::string* release_voice();
  inline void set_allocated_voice(::std::string* voice);

  // @@protoc_insertion_point(class_scope:PBMidLayer.TaskAttribute)
 private:
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_condition();
  inline void clear_has_condition();
  inline void set_has_languagename();
  inline void clear_has_languagename();
  inline void set_has_voice();
  inline void clear_has_voice();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 total_;
  int priority_;
  ::google::protobuf::RepeatedPtrField< ::std::string> objectids_;
  ::std::string* languagename_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keywords_;
  ::std::string* voice_;
  int condition_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static TaskAttribute* default_instance_;
};
// -------------------------------------------------------------------

class HistorySearchResponse : public ::google::protobuf::Message {
 public:
  HistorySearchResponse();
  virtual ~HistorySearchResponse();

  HistorySearchResponse(const HistorySearchResponse& from);

  inline HistorySearchResponse& operator=(const HistorySearchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistorySearchResponse& default_instance();

  void Swap(HistorySearchResponse* other);

  // implements Message ----------------------------------------------

  HistorySearchResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistorySearchResponse& from);
  void MergeFrom(const HistorySearchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required .PBMidLayer.OperationStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::PBMidLayer::OperationStatus& status() const;
  inline ::PBMidLayer::OperationStatus* mutable_status();
  inline ::PBMidLayer::OperationStatus* release_status();
  inline void set_allocated_status(::PBMidLayer::OperationStatus* status);

  // required .PBMidLayer.SearchCondition condition = 3;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 3;
  inline ::PBMidLayer::SearchCondition condition() const;
  inline void set_condition(::PBMidLayer::SearchCondition value);

  // required uint32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional .PBMidLayer.SystemCode syscode = 5;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 5;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.HistorySearchResponse)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_condition();
  inline void clear_has_condition();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::PBMidLayer::OperationStatus* status_;
  int condition_;
  ::google::protobuf::uint32 count_;
  ::PBMidLayer::SystemCode* syscode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static HistorySearchResponse* default_instance_;
};
// -------------------------------------------------------------------

class HistoryTransRequest : public ::google::protobuf::Message {
 public:
  HistoryTransRequest();
  virtual ~HistoryTransRequest();

  HistoryTransRequest(const HistoryTransRequest& from);

  inline HistoryTransRequest& operator=(const HistoryTransRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryTransRequest& default_instance();

  void Swap(HistoryTransRequest* other);

  // implements Message ----------------------------------------------

  HistoryTransRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryTransRequest& from);
  void MergeFrom(const HistoryTransRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required .PBMidLayer.SearchCondition condition = 2;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 2;
  inline ::PBMidLayer::SearchCondition condition() const;
  inline void set_condition(::PBMidLayer::SearchCondition value);

  // required uint32 begin = 3;
  inline bool has_begin() const;
  inline void clear_begin();
  static const int kBeginFieldNumber = 3;
  inline ::google::protobuf::uint32 begin() const;
  inline void set_begin(::google::protobuf::uint32 value);

  // required uint32 end = 4;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 4;
  inline ::google::protobuf::uint32 end() const;
  inline void set_end(::google::protobuf::uint32 value);

  // optional .PBMidLayer.SystemCode syscode = 5;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 5;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.HistoryTransRequest)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_condition();
  inline void clear_has_condition();
  inline void set_has_begin();
  inline void clear_has_begin();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  int condition_;
  ::google::protobuf::uint32 begin_;
  ::PBMidLayer::SystemCode* syscode_;
  ::google::protobuf::uint32 end_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static HistoryTransRequest* default_instance_;
};
// -------------------------------------------------------------------

class HistoryTransResponse : public ::google::protobuf::Message {
 public:
  HistoryTransResponse();
  virtual ~HistoryTransResponse();

  HistoryTransResponse(const HistoryTransResponse& from);

  inline HistoryTransResponse& operator=(const HistoryTransResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryTransResponse& default_instance();

  void Swap(HistoryTransResponse* other);

  // implements Message ----------------------------------------------

  HistoryTransResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryTransResponse& from);
  void MergeFrom(const HistoryTransResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required .PBMidLayer.OperationStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::PBMidLayer::OperationStatus& status() const;
  inline ::PBMidLayer::OperationStatus* mutable_status();
  inline ::PBMidLayer::OperationStatus* release_status();
  inline void set_allocated_status(::PBMidLayer::OperationStatus* status);

  // required uint32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .PBMidLayer.PreprocessResult prelist = 4;
  inline int prelist_size() const;
  inline void clear_prelist();
  static const int kPrelistFieldNumber = 4;
  inline const ::PBMidLayer::PreprocessResult& prelist(int index) const;
  inline ::PBMidLayer::PreprocessResult* mutable_prelist(int index);
  inline ::PBMidLayer::PreprocessResult* add_prelist();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PreprocessResult >&
      prelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PreprocessResult >*
      mutable_prelist();

  // repeated .PBMidLayer.SpeakerResult speakerlist = 5;
  inline int speakerlist_size() const;
  inline void clear_speakerlist();
  static const int kSpeakerlistFieldNumber = 5;
  inline const ::PBMidLayer::SpeakerResult& speakerlist(int index) const;
  inline ::PBMidLayer::SpeakerResult* mutable_speakerlist(int index);
  inline ::PBMidLayer::SpeakerResult* add_speakerlist();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerResult >&
      speakerlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerResult >*
      mutable_speakerlist();

  // repeated .PBMidLayer.KeywordResult keywordlist = 6;
  inline int keywordlist_size() const;
  inline void clear_keywordlist();
  static const int kKeywordlistFieldNumber = 6;
  inline const ::PBMidLayer::KeywordResult& keywordlist(int index) const;
  inline ::PBMidLayer::KeywordResult* mutable_keywordlist(int index);
  inline ::PBMidLayer::KeywordResult* add_keywordlist();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordResult >&
      keywordlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordResult >*
      mutable_keywordlist();

  // repeated .PBMidLayer.TranscriptResult translist = 7;
  inline int translist_size() const;
  inline void clear_translist();
  static const int kTranslistFieldNumber = 7;
  inline const ::PBMidLayer::TranscriptResult& translist(int index) const;
  inline ::PBMidLayer::TranscriptResult* mutable_translist(int index);
  inline ::PBMidLayer::TranscriptResult* add_translist();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::TranscriptResult >&
      translist() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::TranscriptResult >*
      mutable_translist();

  // repeated .PBMidLayer.VADResult vad = 8;
  inline int vad_size() const;
  inline void clear_vad();
  static const int kVadFieldNumber = 8;
  inline const ::PBMidLayer::VADResult& vad(int index) const;
  inline ::PBMidLayer::VADResult* mutable_vad(int index);
  inline ::PBMidLayer::VADResult* add_vad();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::VADResult >&
      vad() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::VADResult >*
      mutable_vad();

  // repeated .PBMidLayer.SpeechSegResult speechseg = 9;
  inline int speechseg_size() const;
  inline void clear_speechseg();
  static const int kSpeechsegFieldNumber = 9;
  inline const ::PBMidLayer::SpeechSegResult& speechseg(int index) const;
  inline ::PBMidLayer::SpeechSegResult* mutable_speechseg(int index);
  inline ::PBMidLayer::SpeechSegResult* add_speechseg();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegResult >&
      speechseg() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegResult >*
      mutable_speechseg();

  // repeated .PBMidLayer.DTMFResult dtmfs = 10;
  inline int dtmfs_size() const;
  inline void clear_dtmfs();
  static const int kDtmfsFieldNumber = 10;
  inline const ::PBMidLayer::DTMFResult& dtmfs(int index) const;
  inline ::PBMidLayer::DTMFResult* mutable_dtmfs(int index);
  inline ::PBMidLayer::DTMFResult* add_dtmfs();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::DTMFResult >&
      dtmfs() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::DTMFResult >*
      mutable_dtmfs();

  // optional .PBMidLayer.SystemCode syscode = 11;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 11;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.HistoryTransResponse)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::PBMidLayer::OperationStatus* status_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PreprocessResult > prelist_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerResult > speakerlist_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordResult > keywordlist_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::TranscriptResult > translist_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::VADResult > vad_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegResult > speechseg_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::DTMFResult > dtmfs_;
  ::PBMidLayer::SystemCode* syscode_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static HistoryTransResponse* default_instance_;
};
// -------------------------------------------------------------------

class FileLocationNotify : public ::google::protobuf::Message {
 public:
  FileLocationNotify();
  virtual ~FileLocationNotify();

  FileLocationNotify(const FileLocationNotify& from);

  inline FileLocationNotify& operator=(const FileLocationNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileLocationNotify& default_instance();

  void Swap(FileLocationNotify* other);

  // implements Message ----------------------------------------------

  FileLocationNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileLocationNotify& from);
  void MergeFrom(const FileLocationNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string callid = 1;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 1;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // required .PBMidLayer.AudioFileTag filetag = 2;
  inline bool has_filetag() const;
  inline void clear_filetag();
  static const int kFiletagFieldNumber = 2;
  inline ::PBMidLayer::AudioFileTag filetag() const;
  inline void set_filetag(::PBMidLayer::AudioFileTag value);

  // required string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required .PBMidLayer.AudioEncodingTag code = 4;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 4;
  inline ::PBMidLayer::AudioEncodingTag code() const;
  inline void set_code(::PBMidLayer::AudioEncodingTag value);

  // optional .PBMidLayer.SystemCode syscode = 5;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 5;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.FileLocationNotify)
 private:
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_filetag();
  inline void clear_has_filetag();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* callid_;
  ::std::string* path_;
  int filetag_;
  int code_;
  ::PBMidLayer::SystemCode* syscode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static FileLocationNotify* default_instance_;
};
// -------------------------------------------------------------------

class TargetQueryRequest : public ::google::protobuf::Message {
 public:
  TargetQueryRequest();
  virtual ~TargetQueryRequest();

  TargetQueryRequest(const TargetQueryRequest& from);

  inline TargetQueryRequest& operator=(const TargetQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetQueryRequest& default_instance();

  void Swap(TargetQueryRequest* other);

  // implements Message ----------------------------------------------

  TargetQueryRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetQueryRequest& from);
  void MergeFrom(const TargetQueryRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required string target = 2;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  inline void set_allocated_target(::std::string* target);

  // required uint64 starttime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 3;
  inline ::google::protobuf::uint64 starttime() const;
  inline void set_starttime(::google::protobuf::uint64 value);

  // required uint64 endtime = 4;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 4;
  inline ::google::protobuf::uint64 endtime() const;
  inline void set_endtime(::google::protobuf::uint64 value);

  // optional .PBMidLayer.SystemCode syscode = 5;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 5;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.TargetQueryRequest)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::std::string* target_;
  ::google::protobuf::uint64 starttime_;
  ::google::protobuf::uint64 endtime_;
  ::PBMidLayer::SystemCode* syscode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static TargetQueryRequest* default_instance_;
};
// -------------------------------------------------------------------

class TargetQueryResponse : public ::google::protobuf::Message {
 public:
  TargetQueryResponse();
  virtual ~TargetQueryResponse();

  TargetQueryResponse(const TargetQueryResponse& from);

  inline TargetQueryResponse& operator=(const TargetQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetQueryResponse& default_instance();

  void Swap(TargetQueryResponse* other);

  // implements Message ----------------------------------------------

  TargetQueryResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetQueryResponse& from);
  void MergeFrom(const TargetQueryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required .PBMidLayer.OperationStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::PBMidLayer::OperationStatus& status() const;
  inline ::PBMidLayer::OperationStatus* mutable_status();
  inline ::PBMidLayer::OperationStatus* release_status();
  inline void set_allocated_status(::PBMidLayer::OperationStatus* status);

  // optional int32 packageseq = 3;
  inline bool has_packageseq() const;
  inline void clear_packageseq();
  static const int kPackageseqFieldNumber = 3;
  inline ::google::protobuf::int32 packageseq() const;
  inline void set_packageseq(::google::protobuf::int32 value);

  // optional int32 endflag = 4;
  inline bool has_endflag() const;
  inline void clear_endflag();
  static const int kEndflagFieldNumber = 4;
  inline ::google::protobuf::int32 endflag() const;
  inline void set_endflag(::google::protobuf::int32 value);

  // optional int32 records = 5;
  inline bool has_records() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 5;
  inline ::google::protobuf::int32 records() const;
  inline void set_records(::google::protobuf::int32 value);

  // repeated string calllist = 6;
  inline int calllist_size() const;
  inline void clear_calllist();
  static const int kCalllistFieldNumber = 6;
  inline const ::std::string& calllist(int index) const;
  inline ::std::string* mutable_calllist(int index);
  inline void set_calllist(int index, const ::std::string& value);
  inline void set_calllist(int index, const char* value);
  inline void set_calllist(int index, const char* value, size_t size);
  inline ::std::string* add_calllist();
  inline void add_calllist(const ::std::string& value);
  inline void add_calllist(const char* value);
  inline void add_calllist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& calllist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_calllist();

  // optional .PBMidLayer.SystemCode syscode = 7;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 7;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.TargetQueryResponse)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_packageseq();
  inline void clear_has_packageseq();
  inline void set_has_endflag();
  inline void clear_has_endflag();
  inline void set_has_records();
  inline void clear_has_records();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::PBMidLayer::OperationStatus* status_;
  ::google::protobuf::int32 packageseq_;
  ::google::protobuf::int32 endflag_;
  ::google::protobuf::RepeatedPtrField< ::std::string> calllist_;
  ::PBMidLayer::SystemCode* syscode_;
  ::google::protobuf::int32 records_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static TargetQueryResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetRuleRequest : public ::google::protobuf::Message {
 public:
  SetRuleRequest();
  virtual ~SetRuleRequest();

  SetRuleRequest(const SetRuleRequest& from);

  inline SetRuleRequest& operator=(const SetRuleRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetRuleRequest& default_instance();

  void Swap(SetRuleRequest* other);

  // implements Message ----------------------------------------------

  SetRuleRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetRuleRequest& from);
  void MergeFrom(const SetRuleRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMidLayer.OperationType opertype = 1;
  inline bool has_opertype() const;
  inline void clear_opertype();
  static const int kOpertypeFieldNumber = 1;
  inline ::PBMidLayer::OperationType opertype() const;
  inline void set_opertype(::PBMidLayer::OperationType value);

  // required .PBMidLayer.RuleType operation = 2;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 2;
  inline ::PBMidLayer::RuleType operation() const;
  inline void set_operation(::PBMidLayer::RuleType value);

  // optional .PBMidLayer.SpeakerRule speaker = 3;
  inline bool has_speaker() const;
  inline void clear_speaker();
  static const int kSpeakerFieldNumber = 3;
  inline const ::PBMidLayer::SpeakerRule& speaker() const;
  inline ::PBMidLayer::SpeakerRule* mutable_speaker();
  inline ::PBMidLayer::SpeakerRule* release_speaker();
  inline void set_allocated_speaker(::PBMidLayer::SpeakerRule* speaker);

  // optional .PBMidLayer.KeywordRule keyword = 4;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 4;
  inline const ::PBMidLayer::KeywordRule& keyword() const;
  inline ::PBMidLayer::KeywordRule* mutable_keyword();
  inline ::PBMidLayer::KeywordRule* release_keyword();
  inline void set_allocated_keyword(::PBMidLayer::KeywordRule* keyword);

  // optional .PBMidLayer.SpeechSegRule speechseg = 5;
  inline bool has_speechseg() const;
  inline void clear_speechseg();
  static const int kSpeechsegFieldNumber = 5;
  inline const ::PBMidLayer::SpeechSegRule& speechseg() const;
  inline ::PBMidLayer::SpeechSegRule* mutable_speechseg();
  inline ::PBMidLayer::SpeechSegRule* release_speechseg();
  inline void set_allocated_speechseg(::PBMidLayer::SpeechSegRule* speechseg);

  // optional .PBMidLayer.SystemCode syscode = 6;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 6;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.SetRuleRequest)
 private:
  inline void set_has_opertype();
  inline void clear_has_opertype();
  inline void set_has_operation();
  inline void clear_has_operation();
  inline void set_has_speaker();
  inline void clear_has_speaker();
  inline void set_has_keyword();
  inline void clear_has_keyword();
  inline void set_has_speechseg();
  inline void clear_has_speechseg();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int opertype_;
  int operation_;
  ::PBMidLayer::SpeakerRule* speaker_;
  ::PBMidLayer::KeywordRule* keyword_;
  ::PBMidLayer::SpeechSegRule* speechseg_;
  ::PBMidLayer::SystemCode* syscode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SetRuleRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetRuleResponse : public ::google::protobuf::Message {
 public:
  SetRuleResponse();
  virtual ~SetRuleResponse();

  SetRuleResponse(const SetRuleResponse& from);

  inline SetRuleResponse& operator=(const SetRuleResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetRuleResponse& default_instance();

  void Swap(SetRuleResponse* other);

  // implements Message ----------------------------------------------

  SetRuleResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetRuleResponse& from);
  void MergeFrom(const SetRuleResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMidLayer.OperationStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::PBMidLayer::OperationStatus& status() const;
  inline ::PBMidLayer::OperationStatus* mutable_status();
  inline ::PBMidLayer::OperationStatus* release_status();
  inline void set_allocated_status(::PBMidLayer::OperationStatus* status);

  // optional .PBMidLayer.SystemCode syscode = 2;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 2;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.SetRuleResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PBMidLayer::OperationStatus* status_;
  ::PBMidLayer::SystemCode* syscode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SetRuleResponse* default_instance_;
};
// -------------------------------------------------------------------

class QueryRuleRequest : public ::google::protobuf::Message {
 public:
  QueryRuleRequest();
  virtual ~QueryRuleRequest();

  QueryRuleRequest(const QueryRuleRequest& from);

  inline QueryRuleRequest& operator=(const QueryRuleRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryRuleRequest& default_instance();

  void Swap(QueryRuleRequest* other);

  // implements Message ----------------------------------------------

  QueryRuleRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryRuleRequest& from);
  void MergeFrom(const QueryRuleRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMidLayer.RuleType operation = 1;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 1;
  inline ::PBMidLayer::RuleType operation() const;
  inline void set_operation(::PBMidLayer::RuleType value);

  // optional string objectid = 2;
  inline bool has_objectid() const;
  inline void clear_objectid();
  static const int kObjectidFieldNumber = 2;
  inline const ::std::string& objectid() const;
  inline void set_objectid(const ::std::string& value);
  inline void set_objectid(const char* value);
  inline void set_objectid(const char* value, size_t size);
  inline ::std::string* mutable_objectid();
  inline ::std::string* release_objectid();
  inline void set_allocated_objectid(::std::string* objectid);

  // optional string languagename = 3;
  inline bool has_languagename() const;
  inline void clear_languagename();
  static const int kLanguagenameFieldNumber = 3;
  inline const ::std::string& languagename() const;
  inline void set_languagename(const ::std::string& value);
  inline void set_languagename(const char* value);
  inline void set_languagename(const char* value, size_t size);
  inline ::std::string* mutable_languagename();
  inline ::std::string* release_languagename();
  inline void set_allocated_languagename(::std::string* languagename);

  // optional string keyword = 4;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 4;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  inline void set_allocated_keyword(::std::string* keyword);

  // optional string speechseglang = 5;
  inline bool has_speechseglang() const;
  inline void clear_speechseglang();
  static const int kSpeechseglangFieldNumber = 5;
  inline const ::std::string& speechseglang() const;
  inline void set_speechseglang(const ::std::string& value);
  inline void set_speechseglang(const char* value);
  inline void set_speechseglang(const char* value, size_t size);
  inline ::std::string* mutable_speechseglang();
  inline ::std::string* release_speechseglang();
  inline void set_allocated_speechseglang(::std::string* speechseglang);

  // optional string speechsegid = 6;
  inline bool has_speechsegid() const;
  inline void clear_speechsegid();
  static const int kSpeechsegidFieldNumber = 6;
  inline const ::std::string& speechsegid() const;
  inline void set_speechsegid(const ::std::string& value);
  inline void set_speechsegid(const char* value);
  inline void set_speechsegid(const char* value, size_t size);
  inline ::std::string* mutable_speechsegid();
  inline ::std::string* release_speechsegid();
  inline void set_allocated_speechsegid(::std::string* speechsegid);

  // optional .PBMidLayer.SystemCode syscode = 7;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 7;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.QueryRuleRequest)
 private:
  inline void set_has_operation();
  inline void clear_has_operation();
  inline void set_has_objectid();
  inline void clear_has_objectid();
  inline void set_has_languagename();
  inline void clear_has_languagename();
  inline void set_has_keyword();
  inline void clear_has_keyword();
  inline void set_has_speechseglang();
  inline void clear_has_speechseglang();
  inline void set_has_speechsegid();
  inline void clear_has_speechsegid();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* objectid_;
  ::std::string* languagename_;
  ::std::string* keyword_;
  ::std::string* speechseglang_;
  ::std::string* speechsegid_;
  ::PBMidLayer::SystemCode* syscode_;
  int operation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static QueryRuleRequest* default_instance_;
};
// -------------------------------------------------------------------

class QueryRuleResponse : public ::google::protobuf::Message {
 public:
  QueryRuleResponse();
  virtual ~QueryRuleResponse();

  QueryRuleResponse(const QueryRuleResponse& from);

  inline QueryRuleResponse& operator=(const QueryRuleResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryRuleResponse& default_instance();

  void Swap(QueryRuleResponse* other);

  // implements Message ----------------------------------------------

  QueryRuleResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryRuleResponse& from);
  void MergeFrom(const QueryRuleResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMidLayer.OperationStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::PBMidLayer::OperationStatus& status() const;
  inline ::PBMidLayer::OperationStatus* mutable_status();
  inline ::PBMidLayer::OperationStatus* release_status();
  inline void set_allocated_status(::PBMidLayer::OperationStatus* status);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .PBMidLayer.SpeakerRule speakerlist = 3;
  inline int speakerlist_size() const;
  inline void clear_speakerlist();
  static const int kSpeakerlistFieldNumber = 3;
  inline const ::PBMidLayer::SpeakerRule& speakerlist(int index) const;
  inline ::PBMidLayer::SpeakerRule* mutable_speakerlist(int index);
  inline ::PBMidLayer::SpeakerRule* add_speakerlist();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerRule >&
      speakerlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerRule >*
      mutable_speakerlist();

  // repeated .PBMidLayer.KeywordRule keywordlist = 4;
  inline int keywordlist_size() const;
  inline void clear_keywordlist();
  static const int kKeywordlistFieldNumber = 4;
  inline const ::PBMidLayer::KeywordRule& keywordlist(int index) const;
  inline ::PBMidLayer::KeywordRule* mutable_keywordlist(int index);
  inline ::PBMidLayer::KeywordRule* add_keywordlist();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordRule >&
      keywordlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordRule >*
      mutable_keywordlist();

  // repeated .PBMidLayer.SpeechSegRule speechseg = 5;
  inline int speechseg_size() const;
  inline void clear_speechseg();
  static const int kSpeechsegFieldNumber = 5;
  inline const ::PBMidLayer::SpeechSegRule& speechseg(int index) const;
  inline ::PBMidLayer::SpeechSegRule* mutable_speechseg(int index);
  inline ::PBMidLayer::SpeechSegRule* add_speechseg();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegRule >&
      speechseg() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegRule >*
      mutable_speechseg();

  // optional .PBMidLayer.SystemCode syscode = 6;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 6;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.QueryRuleResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PBMidLayer::OperationStatus* status_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerRule > speakerlist_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordRule > keywordlist_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegRule > speechseg_;
  ::PBMidLayer::SystemCode* syscode_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static QueryRuleResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetSysParaRequest : public ::google::protobuf::Message {
 public:
  SetSysParaRequest();
  virtual ~SetSysParaRequest();

  SetSysParaRequest(const SetSysParaRequest& from);

  inline SetSysParaRequest& operator=(const SetSysParaRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetSysParaRequest& default_instance();

  void Swap(SetSysParaRequest* other);

  // implements Message ----------------------------------------------

  SetSysParaRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetSysParaRequest& from);
  void MergeFrom(const SetSysParaRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMidLayer.SystemParaType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::PBMidLayer::SystemParaType type() const;
  inline void set_type(::PBMidLayer::SystemParaType value);

  // optional float languagethreshold = 2;
  inline bool has_languagethreshold() const;
  inline void clear_languagethreshold();
  static const int kLanguagethresholdFieldNumber = 2;
  inline float languagethreshold() const;
  inline void set_languagethreshold(float value);

  // optional float speakerthreshold = 3;
  inline bool has_speakerthreshold() const;
  inline void clear_speakerthreshold();
  static const int kSpeakerthresholdFieldNumber = 3;
  inline float speakerthreshold() const;
  inline void set_speakerthreshold(float value);

  // optional float keywordthreshold = 4;
  inline bool has_keywordthreshold() const;
  inline void clear_keywordthreshold();
  static const int kKeywordthresholdFieldNumber = 4;
  inline float keywordthreshold() const;
  inline void set_keywordthreshold(float value);

  // optional int32 languagecount = 5;
  inline bool has_languagecount() const;
  inline void clear_languagecount();
  static const int kLanguagecountFieldNumber = 5;
  inline ::google::protobuf::int32 languagecount() const;
  inline void set_languagecount(::google::protobuf::int32 value);

  // optional int32 speakercount = 6;
  inline bool has_speakercount() const;
  inline void clear_speakercount();
  static const int kSpeakercountFieldNumber = 6;
  inline ::google::protobuf::int32 speakercount() const;
  inline void set_speakercount(::google::protobuf::int32 value);

  // optional .PBMidLayer.SystemCode syscode = 7;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 7;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.SetSysParaRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_languagethreshold();
  inline void clear_has_languagethreshold();
  inline void set_has_speakerthreshold();
  inline void clear_has_speakerthreshold();
  inline void set_has_keywordthreshold();
  inline void clear_has_keywordthreshold();
  inline void set_has_languagecount();
  inline void clear_has_languagecount();
  inline void set_has_speakercount();
  inline void clear_has_speakercount();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  float languagethreshold_;
  float speakerthreshold_;
  float keywordthreshold_;
  ::google::protobuf::int32 languagecount_;
  ::google::protobuf::int32 speakercount_;
  ::PBMidLayer::SystemCode* syscode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SetSysParaRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetSysParaResponse : public ::google::protobuf::Message {
 public:
  SetSysParaResponse();
  virtual ~SetSysParaResponse();

  SetSysParaResponse(const SetSysParaResponse& from);

  inline SetSysParaResponse& operator=(const SetSysParaResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetSysParaResponse& default_instance();

  void Swap(SetSysParaResponse* other);

  // implements Message ----------------------------------------------

  SetSysParaResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetSysParaResponse& from);
  void MergeFrom(const SetSysParaResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMidLayer.OperationStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::PBMidLayer::OperationStatus& status() const;
  inline ::PBMidLayer::OperationStatus* mutable_status();
  inline ::PBMidLayer::OperationStatus* release_status();
  inline void set_allocated_status(::PBMidLayer::OperationStatus* status);

  // optional .PBMidLayer.SystemCode syscode = 2;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 2;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.SetSysParaResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PBMidLayer::OperationStatus* status_;
  ::PBMidLayer::SystemCode* syscode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SetSysParaResponse* default_instance_;
};
// -------------------------------------------------------------------

class QuerySysParaRequest : public ::google::protobuf::Message {
 public:
  QuerySysParaRequest();
  virtual ~QuerySysParaRequest();

  QuerySysParaRequest(const QuerySysParaRequest& from);

  inline QuerySysParaRequest& operator=(const QuerySysParaRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuerySysParaRequest& default_instance();

  void Swap(QuerySysParaRequest* other);

  // implements Message ----------------------------------------------

  QuerySysParaRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuerySysParaRequest& from);
  void MergeFrom(const QuerySysParaRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .PBMidLayer.SystemCode syscode = 1;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 1;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.QuerySysParaRequest)
 private:
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PBMidLayer::SystemCode* syscode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static QuerySysParaRequest* default_instance_;
};
// -------------------------------------------------------------------

class QuerySysParaResponse : public ::google::protobuf::Message {
 public:
  QuerySysParaResponse();
  virtual ~QuerySysParaResponse();

  QuerySysParaResponse(const QuerySysParaResponse& from);

  inline QuerySysParaResponse& operator=(const QuerySysParaResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuerySysParaResponse& default_instance();

  void Swap(QuerySysParaResponse* other);

  // implements Message ----------------------------------------------

  QuerySysParaResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuerySysParaResponse& from);
  void MergeFrom(const QuerySysParaResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMidLayer.OperationStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::PBMidLayer::OperationStatus& status() const;
  inline ::PBMidLayer::OperationStatus* mutable_status();
  inline ::PBMidLayer::OperationStatus* release_status();
  inline void set_allocated_status(::PBMidLayer::OperationStatus* status);

  // optional float languagethreshold = 2;
  inline bool has_languagethreshold() const;
  inline void clear_languagethreshold();
  static const int kLanguagethresholdFieldNumber = 2;
  inline float languagethreshold() const;
  inline void set_languagethreshold(float value);

  // optional float speakerthreshold = 3;
  inline bool has_speakerthreshold() const;
  inline void clear_speakerthreshold();
  static const int kSpeakerthresholdFieldNumber = 3;
  inline float speakerthreshold() const;
  inline void set_speakerthreshold(float value);

  // optional float keywordthreshold = 4;
  inline bool has_keywordthreshold() const;
  inline void clear_keywordthreshold();
  static const int kKeywordthresholdFieldNumber = 4;
  inline float keywordthreshold() const;
  inline void set_keywordthreshold(float value);

  // optional int32 languagecount = 5;
  inline bool has_languagecount() const;
  inline void clear_languagecount();
  static const int kLanguagecountFieldNumber = 5;
  inline ::google::protobuf::int32 languagecount() const;
  inline void set_languagecount(::google::protobuf::int32 value);

  // optional int32 speakercount = 6;
  inline bool has_speakercount() const;
  inline void clear_speakercount();
  static const int kSpeakercountFieldNumber = 6;
  inline ::google::protobuf::int32 speakercount() const;
  inline void set_speakercount(::google::protobuf::int32 value);

  // required uint32 supportlangs = 7;
  inline bool has_supportlangs() const;
  inline void clear_supportlangs();
  static const int kSupportlangsFieldNumber = 7;
  inline ::google::protobuf::uint32 supportlangs() const;
  inline void set_supportlangs(::google::protobuf::uint32 value);

  // repeated .PBMidLayer.LanguageInfo langlist = 8;
  inline int langlist_size() const;
  inline void clear_langlist();
  static const int kLanglistFieldNumber = 8;
  inline const ::PBMidLayer::LanguageInfo& langlist(int index) const;
  inline ::PBMidLayer::LanguageInfo* mutable_langlist(int index);
  inline ::PBMidLayer::LanguageInfo* add_langlist();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::LanguageInfo >&
      langlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::LanguageInfo >*
      mutable_langlist();

  // optional .PBMidLayer.SystemCode syscode = 9;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 9;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.QuerySysParaResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_languagethreshold();
  inline void clear_has_languagethreshold();
  inline void set_has_speakerthreshold();
  inline void clear_has_speakerthreshold();
  inline void set_has_keywordthreshold();
  inline void clear_has_keywordthreshold();
  inline void set_has_languagecount();
  inline void clear_has_languagecount();
  inline void set_has_speakercount();
  inline void clear_has_speakercount();
  inline void set_has_supportlangs();
  inline void clear_has_supportlangs();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PBMidLayer::OperationStatus* status_;
  float languagethreshold_;
  float speakerthreshold_;
  float keywordthreshold_;
  ::google::protobuf::int32 languagecount_;
  ::google::protobuf::int32 speakercount_;
  ::google::protobuf::uint32 supportlangs_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::LanguageInfo > langlist_;
  ::PBMidLayer::SystemCode* syscode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static QuerySysParaResponse* default_instance_;
};
// -------------------------------------------------------------------

class AlarmNotify : public ::google::protobuf::Message {
 public:
  AlarmNotify();
  virtual ~AlarmNotify();

  AlarmNotify(const AlarmNotify& from);

  inline AlarmNotify& operator=(const AlarmNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlarmNotify& default_instance();

  void Swap(AlarmNotify* other);

  // implements Message ----------------------------------------------

  AlarmNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlarmNotify& from);
  void MergeFrom(const AlarmNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string alarmtime = 1;
  inline bool has_alarmtime() const;
  inline void clear_alarmtime();
  static const int kAlarmtimeFieldNumber = 1;
  inline const ::std::string& alarmtime() const;
  inline void set_alarmtime(const ::std::string& value);
  inline void set_alarmtime(const char* value);
  inline void set_alarmtime(const char* value, size_t size);
  inline ::std::string* mutable_alarmtime();
  inline ::std::string* release_alarmtime();
  inline void set_allocated_alarmtime(::std::string* alarmtime);

  // required .PBMidLayer.AlarmLevel level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::PBMidLayer::AlarmLevel level() const;
  inline void set_level(::PBMidLayer::AlarmLevel value);

  // required string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // required string modulename = 4;
  inline bool has_modulename() const;
  inline void clear_modulename();
  static const int kModulenameFieldNumber = 4;
  inline const ::std::string& modulename() const;
  inline void set_modulename(const ::std::string& value);
  inline void set_modulename(const char* value);
  inline void set_modulename(const char* value, size_t size);
  inline ::std::string* mutable_modulename();
  inline ::std::string* release_modulename();
  inline void set_allocated_modulename(::std::string* modulename);

  // optional .PBMidLayer.SystemCode syscode = 5;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 5;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.AlarmNotify)
 private:
  inline void set_has_alarmtime();
  inline void clear_has_alarmtime();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_modulename();
  inline void clear_has_modulename();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* alarmtime_;
  ::std::string* content_;
  ::std::string* modulename_;
  ::PBMidLayer::SystemCode* syscode_;
  int level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static AlarmNotify* default_instance_;
};
// -------------------------------------------------------------------

class StatusNotify : public ::google::protobuf::Message {
 public:
  StatusNotify();
  virtual ~StatusNotify();

  StatusNotify(const StatusNotify& from);

  inline StatusNotify& operator=(const StatusNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusNotify& default_instance();

  void Swap(StatusNotify* other);

  // implements Message ----------------------------------------------

  StatusNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusNotify& from);
  void MergeFrom(const StatusNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string modulename = 1;
  inline bool has_modulename() const;
  inline void clear_modulename();
  static const int kModulenameFieldNumber = 1;
  inline const ::std::string& modulename() const;
  inline void set_modulename(const ::std::string& value);
  inline void set_modulename(const char* value);
  inline void set_modulename(const char* value, size_t size);
  inline ::std::string* mutable_modulename();
  inline ::std::string* release_modulename();
  inline void set_allocated_modulename(::std::string* modulename);

  // required string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required float cpuusage = 3;
  inline bool has_cpuusage() const;
  inline void clear_cpuusage();
  static const int kCpuusageFieldNumber = 3;
  inline float cpuusage() const;
  inline void set_cpuusage(float value);

  // required int32 totalmemory = 4;
  inline bool has_totalmemory() const;
  inline void clear_totalmemory();
  static const int kTotalmemoryFieldNumber = 4;
  inline ::google::protobuf::int32 totalmemory() const;
  inline void set_totalmemory(::google::protobuf::int32 value);

  // required int32 memoryused = 5;
  inline bool has_memoryused() const;
  inline void clear_memoryused();
  static const int kMemoryusedFieldNumber = 5;
  inline ::google::protobuf::int32 memoryused() const;
  inline void set_memoryused(::google::protobuf::int32 value);

  // required int32 currenttasks = 6;
  inline bool has_currenttasks() const;
  inline void clear_currenttasks();
  static const int kCurrenttasksFieldNumber = 6;
  inline ::google::protobuf::int32 currenttasks() const;
  inline void set_currenttasks(::google::protobuf::int32 value);

  // required string recordtime = 7;
  inline bool has_recordtime() const;
  inline void clear_recordtime();
  static const int kRecordtimeFieldNumber = 7;
  inline const ::std::string& recordtime() const;
  inline void set_recordtime(const ::std::string& value);
  inline void set_recordtime(const char* value);
  inline void set_recordtime(const char* value, size_t size);
  inline ::std::string* mutable_recordtime();
  inline ::std::string* release_recordtime();
  inline void set_allocated_recordtime(::std::string* recordtime);

  // optional .PBMidLayer.SystemCode syscode = 8;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 8;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // repeated .PBMidLayer.SystemStateItem states = 9;
  inline int states_size() const;
  inline void clear_states();
  static const int kStatesFieldNumber = 9;
  inline const ::PBMidLayer::SystemStateItem& states(int index) const;
  inline ::PBMidLayer::SystemStateItem* mutable_states(int index);
  inline ::PBMidLayer::SystemStateItem* add_states();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SystemStateItem >&
      states() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SystemStateItem >*
      mutable_states();

  // @@protoc_insertion_point(class_scope:PBMidLayer.StatusNotify)
 private:
  inline void set_has_modulename();
  inline void clear_has_modulename();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_cpuusage();
  inline void clear_has_cpuusage();
  inline void set_has_totalmemory();
  inline void clear_has_totalmemory();
  inline void set_has_memoryused();
  inline void clear_has_memoryused();
  inline void set_has_currenttasks();
  inline void clear_has_currenttasks();
  inline void set_has_recordtime();
  inline void clear_has_recordtime();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* modulename_;
  ::std::string* ip_;
  float cpuusage_;
  ::google::protobuf::int32 totalmemory_;
  ::google::protobuf::int32 memoryused_;
  ::google::protobuf::int32 currenttasks_;
  ::std::string* recordtime_;
  ::PBMidLayer::SystemCode* syscode_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SystemStateItem > states_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static StatusNotify* default_instance_;
};
// -------------------------------------------------------------------

class ObjectManageRequest : public ::google::protobuf::Message {
 public:
  ObjectManageRequest();
  virtual ~ObjectManageRequest();

  ObjectManageRequest(const ObjectManageRequest& from);

  inline ObjectManageRequest& operator=(const ObjectManageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectManageRequest& default_instance();

  void Swap(ObjectManageRequest* other);

  // implements Message ----------------------------------------------

  ObjectManageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectManageRequest& from);
  void MergeFrom(const ObjectManageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string objectid = 1;
  inline bool has_objectid() const;
  inline void clear_objectid();
  static const int kObjectidFieldNumber = 1;
  inline const ::std::string& objectid() const;
  inline void set_objectid(const ::std::string& value);
  inline void set_objectid(const char* value);
  inline void set_objectid(const char* value, size_t size);
  inline ::std::string* mutable_objectid();
  inline ::std::string* release_objectid();
  inline void set_allocated_objectid(::std::string* objectid);

  // required .PBMidLayer.OperationType opertype = 2;
  inline bool has_opertype() const;
  inline void clear_opertype();
  static const int kOpertypeFieldNumber = 2;
  inline ::PBMidLayer::OperationType opertype() const;
  inline void set_opertype(::PBMidLayer::OperationType value);

  // required uint32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .PBMidLayer.TrainInfo list = 4;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 4;
  inline const ::PBMidLayer::TrainInfo& list(int index) const;
  inline ::PBMidLayer::TrainInfo* mutable_list(int index);
  inline ::PBMidLayer::TrainInfo* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::TrainInfo >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::TrainInfo >*
      mutable_list();

  // optional string objectname = 5;
  inline bool has_objectname() const;
  inline void clear_objectname();
  static const int kObjectnameFieldNumber = 5;
  inline const ::std::string& objectname() const;
  inline void set_objectname(const ::std::string& value);
  inline void set_objectname(const char* value);
  inline void set_objectname(const char* value, size_t size);
  inline ::std::string* mutable_objectname();
  inline ::std::string* release_objectname();
  inline void set_allocated_objectname(::std::string* objectname);

  // optional bool isautotrain = 6;
  inline bool has_isautotrain() const;
  inline void clear_isautotrain();
  static const int kIsautotrainFieldNumber = 6;
  inline bool isautotrain() const;
  inline void set_isautotrain(bool value);

  // optional .PBMidLayer.SystemCode syscode = 7;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 7;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // optional .PBMidLayer.GenderType gender = 8;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 8;
  inline ::PBMidLayer::GenderType gender() const;
  inline void set_gender(::PBMidLayer::GenderType value);

  // @@protoc_insertion_point(class_scope:PBMidLayer.ObjectManageRequest)
 private:
  inline void set_has_objectid();
  inline void clear_has_objectid();
  inline void set_has_opertype();
  inline void clear_has_opertype();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_objectname();
  inline void clear_has_objectname();
  inline void set_has_isautotrain();
  inline void clear_has_isautotrain();
  inline void set_has_syscode();
  inline void clear_has_syscode();
  inline void set_has_gender();
  inline void clear_has_gender();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* objectid_;
  int opertype_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::TrainInfo > list_;
  ::std::string* objectname_;
  ::PBMidLayer::SystemCode* syscode_;
  bool isautotrain_;
  int gender_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static ObjectManageRequest* default_instance_;
};
// -------------------------------------------------------------------

class ObjectManageNotify : public ::google::protobuf::Message {
 public:
  ObjectManageNotify();
  virtual ~ObjectManageNotify();

  ObjectManageNotify(const ObjectManageNotify& from);

  inline ObjectManageNotify& operator=(const ObjectManageNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectManageNotify& default_instance();

  void Swap(ObjectManageNotify* other);

  // implements Message ----------------------------------------------

  ObjectManageNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectManageNotify& from);
  void MergeFrom(const ObjectManageNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMidLayer.OperationStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::PBMidLayer::OperationStatus& status() const;
  inline ::PBMidLayer::OperationStatus* mutable_status();
  inline ::PBMidLayer::OperationStatus* release_status();
  inline void set_allocated_status(::PBMidLayer::OperationStatus* status);

  // optional string objectid = 2;
  inline bool has_objectid() const;
  inline void clear_objectid();
  static const int kObjectidFieldNumber = 2;
  inline const ::std::string& objectid() const;
  inline void set_objectid(const ::std::string& value);
  inline void set_objectid(const char* value);
  inline void set_objectid(const char* value, size_t size);
  inline ::std::string* mutable_objectid();
  inline ::std::string* release_objectid();
  inline void set_allocated_objectid(::std::string* objectid);

  // optional .PBMidLayer.SystemCode syscode = 3;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 3;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.ObjectManageNotify)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_objectid();
  inline void clear_has_objectid();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PBMidLayer::OperationStatus* status_;
  ::std::string* objectid_;
  ::PBMidLayer::SystemCode* syscode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static ObjectManageNotify* default_instance_;
};
// -------------------------------------------------------------------

class ObjectManageResponse : public ::google::protobuf::Message {
 public:
  ObjectManageResponse();
  virtual ~ObjectManageResponse();

  ObjectManageResponse(const ObjectManageResponse& from);

  inline ObjectManageResponse& operator=(const ObjectManageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectManageResponse& default_instance();

  void Swap(ObjectManageResponse* other);

  // implements Message ----------------------------------------------

  ObjectManageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectManageResponse& from);
  void MergeFrom(const ObjectManageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMidLayer.OperationStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::PBMidLayer::OperationStatus& status() const;
  inline ::PBMidLayer::OperationStatus* mutable_status();
  inline ::PBMidLayer::OperationStatus* release_status();
  inline void set_allocated_status(::PBMidLayer::OperationStatus* status);

  // optional string objectid = 2;
  inline bool has_objectid() const;
  inline void clear_objectid();
  static const int kObjectidFieldNumber = 2;
  inline const ::std::string& objectid() const;
  inline void set_objectid(const ::std::string& value);
  inline void set_objectid(const char* value);
  inline void set_objectid(const char* value, size_t size);
  inline ::std::string* mutable_objectid();
  inline ::std::string* release_objectid();
  inline void set_allocated_objectid(::std::string* objectid);

  // optional .PBMidLayer.SystemCode syscode = 3;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 3;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.ObjectManageResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_objectid();
  inline void clear_has_objectid();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PBMidLayer::OperationStatus* status_;
  ::std::string* objectid_;
  ::PBMidLayer::SystemCode* syscode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static ObjectManageResponse* default_instance_;
};
// -------------------------------------------------------------------

class FeedbackNotify : public ::google::protobuf::Message {
 public:
  FeedbackNotify();
  virtual ~FeedbackNotify();

  FeedbackNotify(const FeedbackNotify& from);

  inline FeedbackNotify& operator=(const FeedbackNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeedbackNotify& default_instance();

  void Swap(FeedbackNotify* other);

  // implements Message ----------------------------------------------

  FeedbackNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeedbackNotify& from);
  void MergeFrom(const FeedbackNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string callid = 1;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 1;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // required .PBMidLayer.AudioFileTag filetag = 2;
  inline bool has_filetag() const;
  inline void clear_filetag();
  static const int kFiletagFieldNumber = 2;
  inline ::PBMidLayer::AudioFileTag filetag() const;
  inline void set_filetag(::PBMidLayer::AudioFileTag value);

  // optional int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 result = 4;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 4;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .PBMidLayer.PreprocessResult errorpp = 5;
  inline bool has_errorpp() const;
  inline void clear_errorpp();
  static const int kErrorppFieldNumber = 5;
  inline const ::PBMidLayer::PreprocessResult& errorpp() const;
  inline ::PBMidLayer::PreprocessResult* mutable_errorpp();
  inline ::PBMidLayer::PreprocessResult* release_errorpp();
  inline void set_allocated_errorpp(::PBMidLayer::PreprocessResult* errorpp);

  // optional .PBMidLayer.PreprocessResult rightpp = 6;
  inline bool has_rightpp() const;
  inline void clear_rightpp();
  static const int kRightppFieldNumber = 6;
  inline const ::PBMidLayer::PreprocessResult& rightpp() const;
  inline ::PBMidLayer::PreprocessResult* mutable_rightpp();
  inline ::PBMidLayer::PreprocessResult* release_rightpp();
  inline void set_allocated_rightpp(::PBMidLayer::PreprocessResult* rightpp);

  // optional .PBMidLayer.SpeakerResult errorsp = 7;
  inline bool has_errorsp() const;
  inline void clear_errorsp();
  static const int kErrorspFieldNumber = 7;
  inline const ::PBMidLayer::SpeakerResult& errorsp() const;
  inline ::PBMidLayer::SpeakerResult* mutable_errorsp();
  inline ::PBMidLayer::SpeakerResult* release_errorsp();
  inline void set_allocated_errorsp(::PBMidLayer::SpeakerResult* errorsp);

  // optional .PBMidLayer.SpeakerResult rightsp = 8;
  inline bool has_rightsp() const;
  inline void clear_rightsp();
  static const int kRightspFieldNumber = 8;
  inline const ::PBMidLayer::SpeakerResult& rightsp() const;
  inline ::PBMidLayer::SpeakerResult* mutable_rightsp();
  inline ::PBMidLayer::SpeakerResult* release_rightsp();
  inline void set_allocated_rightsp(::PBMidLayer::SpeakerResult* rightsp);

  // optional .PBMidLayer.KeywordResult errorkw = 9;
  inline bool has_errorkw() const;
  inline void clear_errorkw();
  static const int kErrorkwFieldNumber = 9;
  inline const ::PBMidLayer::KeywordResult& errorkw() const;
  inline ::PBMidLayer::KeywordResult* mutable_errorkw();
  inline ::PBMidLayer::KeywordResult* release_errorkw();
  inline void set_allocated_errorkw(::PBMidLayer::KeywordResult* errorkw);

  // optional .PBMidLayer.KeywordResult rightkw = 10;
  inline bool has_rightkw() const;
  inline void clear_rightkw();
  static const int kRightkwFieldNumber = 10;
  inline const ::PBMidLayer::KeywordResult& rightkw() const;
  inline ::PBMidLayer::KeywordResult* mutable_rightkw();
  inline ::PBMidLayer::KeywordResult* release_rightkw();
  inline void set_allocated_rightkw(::PBMidLayer::KeywordResult* rightkw);

  // optional .PBMidLayer.TranscriptResult errorts = 11;
  inline bool has_errorts() const;
  inline void clear_errorts();
  static const int kErrortsFieldNumber = 11;
  inline const ::PBMidLayer::TranscriptResult& errorts() const;
  inline ::PBMidLayer::TranscriptResult* mutable_errorts();
  inline ::PBMidLayer::TranscriptResult* release_errorts();
  inline void set_allocated_errorts(::PBMidLayer::TranscriptResult* errorts);

  // optional .PBMidLayer.TranscriptResult rightts = 12;
  inline bool has_rightts() const;
  inline void clear_rightts();
  static const int kRighttsFieldNumber = 12;
  inline const ::PBMidLayer::TranscriptResult& rightts() const;
  inline ::PBMidLayer::TranscriptResult* mutable_rightts();
  inline ::PBMidLayer::TranscriptResult* release_rightts();
  inline void set_allocated_rightts(::PBMidLayer::TranscriptResult* rightts);

  // optional .PBMidLayer.VADResult rightvad = 13;
  inline bool has_rightvad() const;
  inline void clear_rightvad();
  static const int kRightvadFieldNumber = 13;
  inline const ::PBMidLayer::VADResult& rightvad() const;
  inline ::PBMidLayer::VADResult* mutable_rightvad();
  inline ::PBMidLayer::VADResult* release_rightvad();
  inline void set_allocated_rightvad(::PBMidLayer::VADResult* rightvad);

  // optional .PBMidLayer.VADResult errorvad = 14;
  inline bool has_errorvad() const;
  inline void clear_errorvad();
  static const int kErrorvadFieldNumber = 14;
  inline const ::PBMidLayer::VADResult& errorvad() const;
  inline ::PBMidLayer::VADResult* mutable_errorvad();
  inline ::PBMidLayer::VADResult* release_errorvad();
  inline void set_allocated_errorvad(::PBMidLayer::VADResult* errorvad);

  // optional .PBMidLayer.SpeechSegResult rightss = 15;
  inline bool has_rightss() const;
  inline void clear_rightss();
  static const int kRightssFieldNumber = 15;
  inline const ::PBMidLayer::SpeechSegResult& rightss() const;
  inline ::PBMidLayer::SpeechSegResult* mutable_rightss();
  inline ::PBMidLayer::SpeechSegResult* release_rightss();
  inline void set_allocated_rightss(::PBMidLayer::SpeechSegResult* rightss);

  // optional .PBMidLayer.SpeechSegResult errorss = 16;
  inline bool has_errorss() const;
  inline void clear_errorss();
  static const int kErrorssFieldNumber = 16;
  inline const ::PBMidLayer::SpeechSegResult& errorss() const;
  inline ::PBMidLayer::SpeechSegResult* mutable_errorss();
  inline ::PBMidLayer::SpeechSegResult* release_errorss();
  inline void set_allocated_errorss(::PBMidLayer::SpeechSegResult* errorss);

  // optional .PBMidLayer.DTMFResult rightdtmf = 17;
  inline bool has_rightdtmf() const;
  inline void clear_rightdtmf();
  static const int kRightdtmfFieldNumber = 17;
  inline const ::PBMidLayer::DTMFResult& rightdtmf() const;
  inline ::PBMidLayer::DTMFResult* mutable_rightdtmf();
  inline ::PBMidLayer::DTMFResult* release_rightdtmf();
  inline void set_allocated_rightdtmf(::PBMidLayer::DTMFResult* rightdtmf);

  // optional .PBMidLayer.DTMFResult errordtmf = 18;
  inline bool has_errordtmf() const;
  inline void clear_errordtmf();
  static const int kErrordtmfFieldNumber = 18;
  inline const ::PBMidLayer::DTMFResult& errordtmf() const;
  inline ::PBMidLayer::DTMFResult* mutable_errordtmf();
  inline ::PBMidLayer::DTMFResult* release_errordtmf();
  inline void set_allocated_errordtmf(::PBMidLayer::DTMFResult* errordtmf);

  // optional .PBMidLayer.SystemCode syscode = 19;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 19;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.FeedbackNotify)
 private:
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_filetag();
  inline void clear_has_filetag();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_errorpp();
  inline void clear_has_errorpp();
  inline void set_has_rightpp();
  inline void clear_has_rightpp();
  inline void set_has_errorsp();
  inline void clear_has_errorsp();
  inline void set_has_rightsp();
  inline void clear_has_rightsp();
  inline void set_has_errorkw();
  inline void clear_has_errorkw();
  inline void set_has_rightkw();
  inline void clear_has_rightkw();
  inline void set_has_errorts();
  inline void clear_has_errorts();
  inline void set_has_rightts();
  inline void clear_has_rightts();
  inline void set_has_rightvad();
  inline void clear_has_rightvad();
  inline void set_has_errorvad();
  inline void clear_has_errorvad();
  inline void set_has_rightss();
  inline void clear_has_rightss();
  inline void set_has_errorss();
  inline void clear_has_errorss();
  inline void set_has_rightdtmf();
  inline void clear_has_rightdtmf();
  inline void set_has_errordtmf();
  inline void clear_has_errordtmf();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* callid_;
  int filetag_;
  ::google::protobuf::int32 type_;
  ::PBMidLayer::PreprocessResult* errorpp_;
  ::PBMidLayer::PreprocessResult* rightpp_;
  ::PBMidLayer::SpeakerResult* errorsp_;
  ::PBMidLayer::SpeakerResult* rightsp_;
  ::PBMidLayer::KeywordResult* errorkw_;
  ::PBMidLayer::KeywordResult* rightkw_;
  ::PBMidLayer::TranscriptResult* errorts_;
  ::PBMidLayer::TranscriptResult* rightts_;
  ::PBMidLayer::VADResult* rightvad_;
  ::PBMidLayer::VADResult* errorvad_;
  ::PBMidLayer::SpeechSegResult* rightss_;
  ::PBMidLayer::SpeechSegResult* errorss_;
  ::PBMidLayer::DTMFResult* rightdtmf_;
  ::PBMidLayer::DTMFResult* errordtmf_;
  ::PBMidLayer::SystemCode* syscode_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static FeedbackNotify* default_instance_;
};
// -------------------------------------------------------------------

class SearchRequest : public ::google::protobuf::Message {
 public:
  SearchRequest();
  virtual ~SearchRequest();

  SearchRequest(const SearchRequest& from);

  inline SearchRequest& operator=(const SearchRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchRequest& default_instance();

  void Swap(SearchRequest* other);

  // implements Message ----------------------------------------------

  SearchRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchRequest& from);
  void MergeFrom(const SearchRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required .PBMidLayer.SystemCode syscode = 2;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 2;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // required int32 maxresult = 3;
  inline bool has_maxresult() const;
  inline void clear_maxresult();
  static const int kMaxresultFieldNumber = 3;
  inline ::google::protobuf::int32 maxresult() const;
  inline void set_maxresult(::google::protobuf::int32 value);

  // required .PBMidLayer.SearchTaskType tasktype = 4;
  inline bool has_tasktype() const;
  inline void clear_tasktype();
  static const int kTasktypeFieldNumber = 4;
  inline ::PBMidLayer::SearchTaskType tasktype() const;
  inline void set_tasktype(::PBMidLayer::SearchTaskType value);

  // optional .PBMidLayer.GenderType gender = 5;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 5;
  inline ::PBMidLayer::GenderType gender() const;
  inline void set_gender(::PBMidLayer::GenderType value);

  // optional uint64 starttime = 6;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 6;
  inline ::google::protobuf::uint64 starttime() const;
  inline void set_starttime(::google::protobuf::uint64 value);

  // optional uint64 endtime = 7;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 7;
  inline ::google::protobuf::uint64 endtime() const;
  inline void set_endtime(::google::protobuf::uint64 value);

  // repeated .PBMidLayer.PhoneNumber telpattern = 8;
  inline int telpattern_size() const;
  inline void clear_telpattern();
  static const int kTelpatternFieldNumber = 8;
  inline const ::PBMidLayer::PhoneNumber& telpattern(int index) const;
  inline ::PBMidLayer::PhoneNumber* mutable_telpattern(int index);
  inline ::PBMidLayer::PhoneNumber* add_telpattern();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber >&
      telpattern() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber >*
      mutable_telpattern();

  // optional string lang = 9;
  inline bool has_lang() const;
  inline void clear_lang();
  static const int kLangFieldNumber = 9;
  inline const ::std::string& lang() const;
  inline void set_lang(const ::std::string& value);
  inline void set_lang(const char* value);
  inline void set_lang(const char* value, size_t size);
  inline ::std::string* mutable_lang();
  inline ::std::string* release_lang();
  inline void set_allocated_lang(::std::string* lang);

  // repeated .PBMidLayer.KeywordRule keywords = 10;
  inline int keywords_size() const;
  inline void clear_keywords();
  static const int kKeywordsFieldNumber = 10;
  inline const ::PBMidLayer::KeywordRule& keywords(int index) const;
  inline ::PBMidLayer::KeywordRule* mutable_keywords(int index);
  inline ::PBMidLayer::KeywordRule* add_keywords();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordRule >&
      keywords() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordRule >*
      mutable_keywords();

  // repeated .PBMidLayer.SpeechSegRule speechseg = 11;
  inline int speechseg_size() const;
  inline void clear_speechseg();
  static const int kSpeechsegFieldNumber = 11;
  inline const ::PBMidLayer::SpeechSegRule& speechseg(int index) const;
  inline ::PBMidLayer::SpeechSegRule* mutable_speechseg(int index);
  inline ::PBMidLayer::SpeechSegRule* add_speechseg();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegRule >&
      speechseg() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegRule >*
      mutable_speechseg();

  // repeated .PBMidLayer.SpeakerRule speakers = 12;
  inline int speakers_size() const;
  inline void clear_speakers();
  static const int kSpeakersFieldNumber = 12;
  inline const ::PBMidLayer::SpeakerRule& speakers(int index) const;
  inline ::PBMidLayer::SpeakerRule* mutable_speakers(int index);
  inline ::PBMidLayer::SpeakerRule* add_speakers();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerRule >&
      speakers() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerRule >*
      mutable_speakers();

  // optional bytes voice = 13;
  inline bool has_voice() const;
  inline void clear_voice();
  static const int kVoiceFieldNumber = 13;
  inline const ::std::string& voice() const;
  inline void set_voice(const ::std::string& value);
  inline void set_voice(const char* value);
  inline void set_voice(const void* value, size_t size);
  inline ::std::string* mutable_voice();
  inline ::std::string* release_voice();
  inline void set_allocated_voice(::std::string* voice);

  // repeated string calllist = 14;
  inline int calllist_size() const;
  inline void clear_calllist();
  static const int kCalllistFieldNumber = 14;
  inline const ::std::string& calllist(int index) const;
  inline ::std::string* mutable_calllist(int index);
  inline void set_calllist(int index, const ::std::string& value);
  inline void set_calllist(int index, const char* value);
  inline void set_calllist(int index, const char* value, size_t size);
  inline ::std::string* add_calllist();
  inline void add_calllist(const ::std::string& value);
  inline void add_calllist(const char* value);
  inline void add_calllist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& calllist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_calllist();

  // @@protoc_insertion_point(class_scope:PBMidLayer.SearchRequest)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_syscode();
  inline void clear_has_syscode();
  inline void set_has_maxresult();
  inline void clear_has_maxresult();
  inline void set_has_tasktype();
  inline void clear_has_tasktype();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_lang();
  inline void clear_has_lang();
  inline void set_has_voice();
  inline void clear_has_voice();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::PBMidLayer::SystemCode* syscode_;
  ::google::protobuf::int32 maxresult_;
  int tasktype_;
  ::google::protobuf::uint64 starttime_;
  ::google::protobuf::uint64 endtime_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber > telpattern_;
  ::std::string* lang_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordRule > keywords_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegRule > speechseg_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerRule > speakers_;
  ::std::string* voice_;
  ::google::protobuf::RepeatedPtrField< ::std::string> calllist_;
  int gender_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SearchRequest* default_instance_;
};
// -------------------------------------------------------------------

class SearchAbortRequest : public ::google::protobuf::Message {
 public:
  SearchAbortRequest();
  virtual ~SearchAbortRequest();

  SearchAbortRequest(const SearchAbortRequest& from);

  inline SearchAbortRequest& operator=(const SearchAbortRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchAbortRequest& default_instance();

  void Swap(SearchAbortRequest* other);

  // implements Message ----------------------------------------------

  SearchAbortRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchAbortRequest& from);
  void MergeFrom(const SearchAbortRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required .PBMidLayer.SystemCode syscode = 2;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 2;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // required string aborttaskid = 3;
  inline bool has_aborttaskid() const;
  inline void clear_aborttaskid();
  static const int kAborttaskidFieldNumber = 3;
  inline const ::std::string& aborttaskid() const;
  inline void set_aborttaskid(const ::std::string& value);
  inline void set_aborttaskid(const char* value);
  inline void set_aborttaskid(const char* value, size_t size);
  inline ::std::string* mutable_aborttaskid();
  inline ::std::string* release_aborttaskid();
  inline void set_allocated_aborttaskid(::std::string* aborttaskid);

  // @@protoc_insertion_point(class_scope:PBMidLayer.SearchAbortRequest)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_syscode();
  inline void clear_has_syscode();
  inline void set_has_aborttaskid();
  inline void clear_has_aborttaskid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::PBMidLayer::SystemCode* syscode_;
  ::std::string* aborttaskid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SearchAbortRequest* default_instance_;
};
// -------------------------------------------------------------------

class SearchResultNotify : public ::google::protobuf::Message {
 public:
  SearchResultNotify();
  virtual ~SearchResultNotify();

  SearchResultNotify(const SearchResultNotify& from);

  inline SearchResultNotify& operator=(const SearchResultNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchResultNotify& default_instance();

  void Swap(SearchResultNotify* other);

  // implements Message ----------------------------------------------

  SearchResultNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchResultNotify& from);
  void MergeFrom(const SearchResultNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required .PBMidLayer.SystemCode syscode = 2;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 2;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // required .PBMidLayer.OperationStatus status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline const ::PBMidLayer::OperationStatus& status() const;
  inline ::PBMidLayer::OperationStatus* mutable_status();
  inline ::PBMidLayer::OperationStatus* release_status();
  inline void set_allocated_status(::PBMidLayer::OperationStatus* status);

  // optional .PBMidLayer.SearchTaskType tasktype = 4;
  inline bool has_tasktype() const;
  inline void clear_tasktype();
  static const int kTasktypeFieldNumber = 4;
  inline ::PBMidLayer::SearchTaskType tasktype() const;
  inline void set_tasktype(::PBMidLayer::SearchTaskType value);

  // repeated .PBMidLayer.SearchFileResult voices = 5;
  inline int voices_size() const;
  inline void clear_voices();
  static const int kVoicesFieldNumber = 5;
  inline const ::PBMidLayer::SearchFileResult& voices(int index) const;
  inline ::PBMidLayer::SearchFileResult* mutable_voices(int index);
  inline ::PBMidLayer::SearchFileResult* add_voices();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SearchFileResult >&
      voices() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SearchFileResult >*
      mutable_voices();

  // repeated .PBMidLayer.SpeakerItem speakers = 6;
  inline int speakers_size() const;
  inline void clear_speakers();
  static const int kSpeakersFieldNumber = 6;
  inline const ::PBMidLayer::SpeakerItem& speakers(int index) const;
  inline ::PBMidLayer::SpeakerItem* mutable_speakers(int index);
  inline ::PBMidLayer::SpeakerItem* add_speakers();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerItem >&
      speakers() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerItem >*
      mutable_speakers();

  // @@protoc_insertion_point(class_scope:PBMidLayer.SearchResultNotify)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_syscode();
  inline void clear_has_syscode();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_tasktype();
  inline void clear_has_tasktype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::PBMidLayer::SystemCode* syscode_;
  ::PBMidLayer::OperationStatus* status_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SearchFileResult > voices_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerItem > speakers_;
  int tasktype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SearchResultNotify* default_instance_;
};
// -------------------------------------------------------------------

class SearchResponse : public ::google::protobuf::Message {
 public:
  SearchResponse();
  virtual ~SearchResponse();

  SearchResponse(const SearchResponse& from);

  inline SearchResponse& operator=(const SearchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchResponse& default_instance();

  void Swap(SearchResponse* other);

  // implements Message ----------------------------------------------

  SearchResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchResponse& from);
  void MergeFrom(const SearchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required .PBMidLayer.SystemCode syscode = 2;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 2;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // required .PBMidLayer.OperationStatus status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline const ::PBMidLayer::OperationStatus& status() const;
  inline ::PBMidLayer::OperationStatus* mutable_status();
  inline ::PBMidLayer::OperationStatus* release_status();
  inline void set_allocated_status(::PBMidLayer::OperationStatus* status);

  // @@protoc_insertion_point(class_scope:PBMidLayer.SearchResponse)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_syscode();
  inline void clear_has_syscode();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::PBMidLayer::SystemCode* syscode_;
  ::PBMidLayer::OperationStatus* status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SearchResponse* default_instance_;
};
// -------------------------------------------------------------------

class SearchStateRequest : public ::google::protobuf::Message {
 public:
  SearchStateRequest();
  virtual ~SearchStateRequest();

  SearchStateRequest(const SearchStateRequest& from);

  inline SearchStateRequest& operator=(const SearchStateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchStateRequest& default_instance();

  void Swap(SearchStateRequest* other);

  // implements Message ----------------------------------------------

  SearchStateRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchStateRequest& from);
  void MergeFrom(const SearchStateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string operid = 1;
  inline bool has_operid() const;
  inline void clear_operid();
  static const int kOperidFieldNumber = 1;
  inline const ::std::string& operid() const;
  inline void set_operid(const ::std::string& value);
  inline void set_operid(const char* value);
  inline void set_operid(const char* value, size_t size);
  inline ::std::string* mutable_operid();
  inline ::std::string* release_operid();
  inline void set_allocated_operid(::std::string* operid);

  // required .PBMidLayer.SystemCode syscode = 2;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 2;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // required string requesttaskid = 3;
  inline bool has_requesttaskid() const;
  inline void clear_requesttaskid();
  static const int kRequesttaskidFieldNumber = 3;
  inline const ::std::string& requesttaskid() const;
  inline void set_requesttaskid(const ::std::string& value);
  inline void set_requesttaskid(const char* value);
  inline void set_requesttaskid(const char* value, size_t size);
  inline ::std::string* mutable_requesttaskid();
  inline ::std::string* release_requesttaskid();
  inline void set_allocated_requesttaskid(::std::string* requesttaskid);

  // @@protoc_insertion_point(class_scope:PBMidLayer.SearchStateRequest)
 private:
  inline void set_has_operid();
  inline void clear_has_operid();
  inline void set_has_syscode();
  inline void clear_has_syscode();
  inline void set_has_requesttaskid();
  inline void clear_has_requesttaskid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* operid_;
  ::PBMidLayer::SystemCode* syscode_;
  ::std::string* requesttaskid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SearchStateRequest* default_instance_;
};
// -------------------------------------------------------------------

class SearchStateResponse : public ::google::protobuf::Message {
 public:
  SearchStateResponse();
  virtual ~SearchStateResponse();

  SearchStateResponse(const SearchStateResponse& from);

  inline SearchStateResponse& operator=(const SearchStateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchStateResponse& default_instance();

  void Swap(SearchStateResponse* other);

  // implements Message ----------------------------------------------

  SearchStateResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchStateResponse& from);
  void MergeFrom(const SearchStateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string operid = 1;
  inline bool has_operid() const;
  inline void clear_operid();
  static const int kOperidFieldNumber = 1;
  inline const ::std::string& operid() const;
  inline void set_operid(const ::std::string& value);
  inline void set_operid(const char* value);
  inline void set_operid(const char* value, size_t size);
  inline ::std::string* mutable_operid();
  inline ::std::string* release_operid();
  inline void set_allocated_operid(::std::string* operid);

  // required .PBMidLayer.SystemCode syscode = 2;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 2;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // required .PBMidLayer.OperationStatus status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline const ::PBMidLayer::OperationStatus& status() const;
  inline ::PBMidLayer::OperationStatus* mutable_status();
  inline ::PBMidLayer::OperationStatus* release_status();
  inline void set_allocated_status(::PBMidLayer::OperationStatus* status);

  // required .PBMidLayer.SearchTaskState state = 4;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 4;
  inline const ::PBMidLayer::SearchTaskState& state() const;
  inline ::PBMidLayer::SearchTaskState* mutable_state();
  inline ::PBMidLayer::SearchTaskState* release_state();
  inline void set_allocated_state(::PBMidLayer::SearchTaskState* state);

  // @@protoc_insertion_point(class_scope:PBMidLayer.SearchStateResponse)
 private:
  inline void set_has_operid();
  inline void clear_has_operid();
  inline void set_has_syscode();
  inline void clear_has_syscode();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* operid_;
  ::PBMidLayer::SystemCode* syscode_;
  ::PBMidLayer::OperationStatus* status_;
  ::PBMidLayer::SearchTaskState* state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SearchStateResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetFileRequest : public ::google::protobuf::Message {
 public:
  GetFileRequest();
  virtual ~GetFileRequest();

  GetFileRequest(const GetFileRequest& from);

  inline GetFileRequest& operator=(const GetFileRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFileRequest& default_instance();

  void Swap(GetFileRequest* other);

  // implements Message ----------------------------------------------

  GetFileRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFileRequest& from);
  void MergeFrom(const GetFileRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string operid = 1;
  inline bool has_operid() const;
  inline void clear_operid();
  static const int kOperidFieldNumber = 1;
  inline const ::std::string& operid() const;
  inline void set_operid(const ::std::string& value);
  inline void set_operid(const char* value);
  inline void set_operid(const char* value, size_t size);
  inline ::std::string* mutable_operid();
  inline ::std::string* release_operid();
  inline void set_allocated_operid(::std::string* operid);

  // required .PBMidLayer.SystemCode syscode = 2;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 2;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // required string callid = 3;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 3;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // required .PBMidLayer.AudioFileTag filetag = 4;
  inline bool has_filetag() const;
  inline void clear_filetag();
  static const int kFiletagFieldNumber = 4;
  inline ::PBMidLayer::AudioFileTag filetag() const;
  inline void set_filetag(::PBMidLayer::AudioFileTag value);

  // @@protoc_insertion_point(class_scope:PBMidLayer.GetFileRequest)
 private:
  inline void set_has_operid();
  inline void clear_has_operid();
  inline void set_has_syscode();
  inline void clear_has_syscode();
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_filetag();
  inline void clear_has_filetag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* operid_;
  ::PBMidLayer::SystemCode* syscode_;
  ::std::string* callid_;
  int filetag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static GetFileRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetFileResponse : public ::google::protobuf::Message {
 public:
  GetFileResponse();
  virtual ~GetFileResponse();

  GetFileResponse(const GetFileResponse& from);

  inline GetFileResponse& operator=(const GetFileResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFileResponse& default_instance();

  void Swap(GetFileResponse* other);

  // implements Message ----------------------------------------------

  GetFileResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFileResponse& from);
  void MergeFrom(const GetFileResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string operid = 1;
  inline bool has_operid() const;
  inline void clear_operid();
  static const int kOperidFieldNumber = 1;
  inline const ::std::string& operid() const;
  inline void set_operid(const ::std::string& value);
  inline void set_operid(const char* value);
  inline void set_operid(const char* value, size_t size);
  inline ::std::string* mutable_operid();
  inline ::std::string* release_operid();
  inline void set_allocated_operid(::std::string* operid);

  // required .PBMidLayer.SystemCode syscode = 2;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 2;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // required bool isdata = 3;
  inline bool has_isdata() const;
  inline void clear_isdata();
  static const int kIsdataFieldNumber = 3;
  inline bool isdata() const;
  inline void set_isdata(bool value);

  // optional .PBMidLayer.FileLocationNotify filelocation = 4;
  inline bool has_filelocation() const;
  inline void clear_filelocation();
  static const int kFilelocationFieldNumber = 4;
  inline const ::PBMidLayer::FileLocationNotify& filelocation() const;
  inline ::PBMidLayer::FileLocationNotify* mutable_filelocation();
  inline ::PBMidLayer::FileLocationNotify* release_filelocation();
  inline void set_allocated_filelocation(::PBMidLayer::FileLocationNotify* filelocation);

  // optional .PBMidLayer.FileDataNotify filedata = 5;
  inline bool has_filedata() const;
  inline void clear_filedata();
  static const int kFiledataFieldNumber = 5;
  inline const ::PBMidLayer::FileDataNotify& filedata() const;
  inline ::PBMidLayer::FileDataNotify* mutable_filedata();
  inline ::PBMidLayer::FileDataNotify* release_filedata();
  inline void set_allocated_filedata(::PBMidLayer::FileDataNotify* filedata);

  // @@protoc_insertion_point(class_scope:PBMidLayer.GetFileResponse)
 private:
  inline void set_has_operid();
  inline void clear_has_operid();
  inline void set_has_syscode();
  inline void clear_has_syscode();
  inline void set_has_isdata();
  inline void clear_has_isdata();
  inline void set_has_filelocation();
  inline void clear_has_filelocation();
  inline void set_has_filedata();
  inline void clear_has_filedata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* operid_;
  ::PBMidLayer::SystemCode* syscode_;
  ::PBMidLayer::FileLocationNotify* filelocation_;
  ::PBMidLayer::FileDataNotify* filedata_;
  bool isdata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static GetFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class AddLangSampRequest : public ::google::protobuf::Message {
 public:
  AddLangSampRequest();
  virtual ~AddLangSampRequest();

  AddLangSampRequest(const AddLangSampRequest& from);

  inline AddLangSampRequest& operator=(const AddLangSampRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddLangSampRequest& default_instance();

  void Swap(AddLangSampRequest* other);

  // implements Message ----------------------------------------------

  AddLangSampRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddLangSampRequest& from);
  void MergeFrom(const AddLangSampRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required .PBMidLayer.SystemCode syscode = 2;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 2;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // required string lang = 3;
  inline bool has_lang() const;
  inline void clear_lang();
  static const int kLangFieldNumber = 3;
  inline const ::std::string& lang() const;
  inline void set_lang(const ::std::string& value);
  inline void set_lang(const char* value);
  inline void set_lang(const char* value, size_t size);
  inline ::std::string* mutable_lang();
  inline ::std::string* release_lang();
  inline void set_allocated_lang(::std::string* lang);

  // repeated .PBMidLayer.FileLocationNotify files = 4;
  inline int files_size() const;
  inline void clear_files();
  static const int kFilesFieldNumber = 4;
  inline const ::PBMidLayer::FileLocationNotify& files(int index) const;
  inline ::PBMidLayer::FileLocationNotify* mutable_files(int index);
  inline ::PBMidLayer::FileLocationNotify* add_files();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::FileLocationNotify >&
      files() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::FileLocationNotify >*
      mutable_files();

  // @@protoc_insertion_point(class_scope:PBMidLayer.AddLangSampRequest)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_syscode();
  inline void clear_has_syscode();
  inline void set_has_lang();
  inline void clear_has_lang();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::PBMidLayer::SystemCode* syscode_;
  ::std::string* lang_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::FileLocationNotify > files_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static AddLangSampRequest* default_instance_;
};
// -------------------------------------------------------------------

class AddLangSampResponse : public ::google::protobuf::Message {
 public:
  AddLangSampResponse();
  virtual ~AddLangSampResponse();

  AddLangSampResponse(const AddLangSampResponse& from);

  inline AddLangSampResponse& operator=(const AddLangSampResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddLangSampResponse& default_instance();

  void Swap(AddLangSampResponse* other);

  // implements Message ----------------------------------------------

  AddLangSampResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddLangSampResponse& from);
  void MergeFrom(const AddLangSampResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required .PBMidLayer.SystemCode syscode = 2;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 2;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // required .PBMidLayer.OperationStatus status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline const ::PBMidLayer::OperationStatus& status() const;
  inline ::PBMidLayer::OperationStatus* mutable_status();
  inline ::PBMidLayer::OperationStatus* release_status();
  inline void set_allocated_status(::PBMidLayer::OperationStatus* status);

  // @@protoc_insertion_point(class_scope:PBMidLayer.AddLangSampResponse)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_syscode();
  inline void clear_has_syscode();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::PBMidLayer::SystemCode* syscode_;
  ::PBMidLayer::OperationStatus* status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static AddLangSampResponse* default_instance_;
};
// -------------------------------------------------------------------

class OperationStatus : public ::google::protobuf::Message {
 public:
  OperationStatus();
  virtual ~OperationStatus();

  OperationStatus(const OperationStatus& from);

  inline OperationStatus& operator=(const OperationStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationStatus& default_instance();

  void Swap(OperationStatus* other);

  // implements Message ----------------------------------------------

  OperationStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationStatus& from);
  void MergeFrom(const OperationStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:PBMidLayer.OperationStatus)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* description_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static OperationStatus* default_instance_;
};
// -------------------------------------------------------------------

class PreprocessResult : public ::google::protobuf::Message {
 public:
  PreprocessResult();
  virtual ~PreprocessResult();

  PreprocessResult(const PreprocessResult& from);

  inline PreprocessResult& operator=(const PreprocessResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PreprocessResult& default_instance();

  void Swap(PreprocessResult* other);

  // implements Message ----------------------------------------------

  PreprocessResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PreprocessResult& from);
  void MergeFrom(const PreprocessResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMidLayer.SpeechType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::PBMidLayer::SpeechType type() const;
  inline void set_type(::PBMidLayer::SpeechType value);

  // optional string languagename = 2;
  inline bool has_languagename() const;
  inline void clear_languagename();
  static const int kLanguagenameFieldNumber = 2;
  inline const ::std::string& languagename() const;
  inline void set_languagename(const ::std::string& value);
  inline void set_languagename(const char* value);
  inline void set_languagename(const char* value, size_t size);
  inline ::std::string* mutable_languagename();
  inline ::std::string* release_languagename();
  inline void set_allocated_languagename(::std::string* languagename);

  // optional float score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline float score() const;
  inline void set_score(float value);

  // optional uint32 validlen = 4;
  inline bool has_validlen() const;
  inline void clear_validlen();
  static const int kValidlenFieldNumber = 4;
  inline ::google::protobuf::uint32 validlen() const;
  inline void set_validlen(::google::protobuf::uint32 value);

  // optional .PBMidLayer.GenderType gender = 5;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 5;
  inline ::PBMidLayer::GenderType gender() const;
  inline void set_gender(::PBMidLayer::GenderType value);

  // optional int32 speakernum = 6;
  inline bool has_speakernum() const;
  inline void clear_speakernum();
  static const int kSpeakernumFieldNumber = 6;
  inline ::google::protobuf::int32 speakernum() const;
  inline void set_speakernum(::google::protobuf::int32 value);

  // optional string callid = 7;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 7;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // optional .PBMidLayer.AudioFileTag filetag = 8;
  inline bool has_filetag() const;
  inline void clear_filetag();
  static const int kFiletagFieldNumber = 8;
  inline ::PBMidLayer::AudioFileTag filetag() const;
  inline void set_filetag(::PBMidLayer::AudioFileTag value);

  // @@protoc_insertion_point(class_scope:PBMidLayer.PreprocessResult)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_languagename();
  inline void clear_has_languagename();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_validlen();
  inline void clear_has_validlen();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_speakernum();
  inline void clear_has_speakernum();
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_filetag();
  inline void clear_has_filetag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* languagename_;
  int type_;
  float score_;
  ::google::protobuf::uint32 validlen_;
  int gender_;
  ::std::string* callid_;
  ::google::protobuf::int32 speakernum_;
  int filetag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static PreprocessResult* default_instance_;
};
// -------------------------------------------------------------------

class SpeakerResult : public ::google::protobuf::Message {
 public:
  SpeakerResult();
  virtual ~SpeakerResult();

  SpeakerResult(const SpeakerResult& from);

  inline SpeakerResult& operator=(const SpeakerResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeakerResult& default_instance();

  void Swap(SpeakerResult* other);

  // implements Message ----------------------------------------------

  SpeakerResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpeakerResult& from);
  void MergeFrom(const SpeakerResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 speakernum = 1;
  inline bool has_speakernum() const;
  inline void clear_speakernum();
  static const int kSpeakernumFieldNumber = 1;
  inline ::google::protobuf::int32 speakernum() const;
  inline void set_speakernum(::google::protobuf::int32 value);

  // repeated .PBMidLayer.SpeakerItem speakers = 2;
  inline int speakers_size() const;
  inline void clear_speakers();
  static const int kSpeakersFieldNumber = 2;
  inline const ::PBMidLayer::SpeakerItem& speakers(int index) const;
  inline ::PBMidLayer::SpeakerItem* mutable_speakers(int index);
  inline ::PBMidLayer::SpeakerItem* add_speakers();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerItem >&
      speakers() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerItem >*
      mutable_speakers();

  // optional string callid = 3;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 3;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // optional .PBMidLayer.AudioFileTag filetag = 4;
  inline bool has_filetag() const;
  inline void clear_filetag();
  static const int kFiletagFieldNumber = 4;
  inline ::PBMidLayer::AudioFileTag filetag() const;
  inline void set_filetag(::PBMidLayer::AudioFileTag value);

  // @@protoc_insertion_point(class_scope:PBMidLayer.SpeakerResult)
 private:
  inline void set_has_speakernum();
  inline void clear_has_speakernum();
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_filetag();
  inline void clear_has_filetag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerItem > speakers_;
  ::google::protobuf::int32 speakernum_;
  int filetag_;
  ::std::string* callid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SpeakerResult* default_instance_;
};
// -------------------------------------------------------------------

class SpeakerItem : public ::google::protobuf::Message {
 public:
  SpeakerItem();
  virtual ~SpeakerItem();

  SpeakerItem(const SpeakerItem& from);

  inline SpeakerItem& operator=(const SpeakerItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeakerItem& default_instance();

  void Swap(SpeakerItem* other);

  // implements Message ----------------------------------------------

  SpeakerItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpeakerItem& from);
  void MergeFrom(const SpeakerItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string objectid = 1;
  inline bool has_objectid() const;
  inline void clear_objectid();
  static const int kObjectidFieldNumber = 1;
  inline const ::std::string& objectid() const;
  inline void set_objectid(const ::std::string& value);
  inline void set_objectid(const char* value);
  inline void set_objectid(const char* value, size_t size);
  inline ::std::string* mutable_objectid();
  inline ::std::string* release_objectid();
  inline void set_allocated_objectid(::std::string* objectid);

  // required float score = 2;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 2;
  inline float score() const;
  inline void set_score(float value);

  // optional string spyid = 3;
  inline bool has_spyid() const;
  inline void clear_spyid();
  static const int kSpyidFieldNumber = 3;
  inline const ::std::string& spyid() const;
  inline void set_spyid(const ::std::string& value);
  inline void set_spyid(const char* value);
  inline void set_spyid(const char* value, size_t size);
  inline ::std::string* mutable_spyid();
  inline ::std::string* release_spyid();
  inline void set_allocated_spyid(::std::string* spyid);

  // @@protoc_insertion_point(class_scope:PBMidLayer.SpeakerItem)
 private:
  inline void set_has_objectid();
  inline void clear_has_objectid();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_spyid();
  inline void clear_has_spyid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* objectid_;
  ::std::string* spyid_;
  float score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SpeakerItem* default_instance_;
};
// -------------------------------------------------------------------

class KeywordResult : public ::google::protobuf::Message {
 public:
  KeywordResult();
  virtual ~KeywordResult();

  KeywordResult(const KeywordResult& from);

  inline KeywordResult& operator=(const KeywordResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeywordResult& default_instance();

  void Swap(KeywordResult* other);

  // implements Message ----------------------------------------------

  KeywordResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeywordResult& from);
  void MergeFrom(const KeywordResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 keywordnum = 1;
  inline bool has_keywordnum() const;
  inline void clear_keywordnum();
  static const int kKeywordnumFieldNumber = 1;
  inline ::google::protobuf::int32 keywordnum() const;
  inline void set_keywordnum(::google::protobuf::int32 value);

  // repeated .PBMidLayer.KeywordSnippet keywords = 2;
  inline int keywords_size() const;
  inline void clear_keywords();
  static const int kKeywordsFieldNumber = 2;
  inline const ::PBMidLayer::KeywordSnippet& keywords(int index) const;
  inline ::PBMidLayer::KeywordSnippet* mutable_keywords(int index);
  inline ::PBMidLayer::KeywordSnippet* add_keywords();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordSnippet >&
      keywords() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordSnippet >*
      mutable_keywords();

  // optional string callid = 3;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 3;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // optional .PBMidLayer.AudioFileTag filetag = 4;
  inline bool has_filetag() const;
  inline void clear_filetag();
  static const int kFiletagFieldNumber = 4;
  inline ::PBMidLayer::AudioFileTag filetag() const;
  inline void set_filetag(::PBMidLayer::AudioFileTag value);

  // @@protoc_insertion_point(class_scope:PBMidLayer.KeywordResult)
 private:
  inline void set_has_keywordnum();
  inline void clear_has_keywordnum();
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_filetag();
  inline void clear_has_filetag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordSnippet > keywords_;
  ::google::protobuf::int32 keywordnum_;
  int filetag_;
  ::std::string* callid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static KeywordResult* default_instance_;
};
// -------------------------------------------------------------------

class KeywordSnippet : public ::google::protobuf::Message {
 public:
  KeywordSnippet();
  virtual ~KeywordSnippet();

  KeywordSnippet(const KeywordSnippet& from);

  inline KeywordSnippet& operator=(const KeywordSnippet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeywordSnippet& default_instance();

  void Swap(KeywordSnippet* other);

  // implements Message ----------------------------------------------

  KeywordSnippet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeywordSnippet& from);
  void MergeFrom(const KeywordSnippet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string keyword = 1;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 1;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  inline void set_allocated_keyword(::std::string* keyword);

  // required string languagename = 2;
  inline bool has_languagename() const;
  inline void clear_languagename();
  static const int kLanguagenameFieldNumber = 2;
  inline const ::std::string& languagename() const;
  inline void set_languagename(const ::std::string& value);
  inline void set_languagename(const char* value);
  inline void set_languagename(const char* value, size_t size);
  inline ::std::string* mutable_languagename();
  inline ::std::string* release_languagename();
  inline void set_allocated_languagename(::std::string* languagename);

  // required float score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline float score() const;
  inline void set_score(float value);

  // required uint32 begintime = 4;
  inline bool has_begintime() const;
  inline void clear_begintime();
  static const int kBegintimeFieldNumber = 4;
  inline ::google::protobuf::uint32 begintime() const;
  inline void set_begintime(::google::protobuf::uint32 value);

  // required uint32 endtime = 5;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 5;
  inline ::google::protobuf::uint32 endtime() const;
  inline void set_endtime(::google::protobuf::uint32 value);

  // optional string text = 6;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 6;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string spyid = 7;
  inline bool has_spyid() const;
  inline void clear_spyid();
  static const int kSpyidFieldNumber = 7;
  inline const ::std::string& spyid() const;
  inline void set_spyid(const ::std::string& value);
  inline void set_spyid(const char* value);
  inline void set_spyid(const char* value, size_t size);
  inline ::std::string* mutable_spyid();
  inline ::std::string* release_spyid();
  inline void set_allocated_spyid(::std::string* spyid);

  // @@protoc_insertion_point(class_scope:PBMidLayer.KeywordSnippet)
 private:
  inline void set_has_keyword();
  inline void clear_has_keyword();
  inline void set_has_languagename();
  inline void clear_has_languagename();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_begintime();
  inline void clear_has_begintime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_spyid();
  inline void clear_has_spyid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* keyword_;
  ::std::string* languagename_;
  float score_;
  ::google::protobuf::uint32 begintime_;
  ::std::string* text_;
  ::std::string* spyid_;
  ::google::protobuf::uint32 endtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static KeywordSnippet* default_instance_;
};
// -------------------------------------------------------------------

class TranscriptResult : public ::google::protobuf::Message {
 public:
  TranscriptResult();
  virtual ~TranscriptResult();

  TranscriptResult(const TranscriptResult& from);

  inline TranscriptResult& operator=(const TranscriptResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TranscriptResult& default_instance();

  void Swap(TranscriptResult* other);

  // implements Message ----------------------------------------------

  TranscriptResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TranscriptResult& from);
  void MergeFrom(const TranscriptResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 segmentnum = 1;
  inline bool has_segmentnum() const;
  inline void clear_segmentnum();
  static const int kSegmentnumFieldNumber = 1;
  inline ::google::protobuf::int32 segmentnum() const;
  inline void set_segmentnum(::google::protobuf::int32 value);

  // repeated .PBMidLayer.SegmentTranscript segments = 2;
  inline int segments_size() const;
  inline void clear_segments();
  static const int kSegmentsFieldNumber = 2;
  inline const ::PBMidLayer::SegmentTranscript& segments(int index) const;
  inline ::PBMidLayer::SegmentTranscript* mutable_segments(int index);
  inline ::PBMidLayer::SegmentTranscript* add_segments();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SegmentTranscript >&
      segments() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SegmentTranscript >*
      mutable_segments();

  // optional string callid = 3;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 3;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // optional .PBMidLayer.AudioFileTag filetag = 4;
  inline bool has_filetag() const;
  inline void clear_filetag();
  static const int kFiletagFieldNumber = 4;
  inline ::PBMidLayer::AudioFileTag filetag() const;
  inline void set_filetag(::PBMidLayer::AudioFileTag value);

  // @@protoc_insertion_point(class_scope:PBMidLayer.TranscriptResult)
 private:
  inline void set_has_segmentnum();
  inline void clear_has_segmentnum();
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_filetag();
  inline void clear_has_filetag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SegmentTranscript > segments_;
  ::google::protobuf::int32 segmentnum_;
  int filetag_;
  ::std::string* callid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static TranscriptResult* default_instance_;
};
// -------------------------------------------------------------------

class SegmentTranscript : public ::google::protobuf::Message {
 public:
  SegmentTranscript();
  virtual ~SegmentTranscript();

  SegmentTranscript(const SegmentTranscript& from);

  inline SegmentTranscript& operator=(const SegmentTranscript& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentTranscript& default_instance();

  void Swap(SegmentTranscript* other);

  // implements Message ----------------------------------------------

  SegmentTranscript* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SegmentTranscript& from);
  void MergeFrom(const SegmentTranscript& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string content = 1;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // required string languagename = 2;
  inline bool has_languagename() const;
  inline void clear_languagename();
  static const int kLanguagenameFieldNumber = 2;
  inline const ::std::string& languagename() const;
  inline void set_languagename(const ::std::string& value);
  inline void set_languagename(const char* value);
  inline void set_languagename(const char* value, size_t size);
  inline ::std::string* mutable_languagename();
  inline ::std::string* release_languagename();
  inline void set_allocated_languagename(::std::string* languagename);

  // required float score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline float score() const;
  inline void set_score(float value);

  // required uint32 begintime = 4;
  inline bool has_begintime() const;
  inline void clear_begintime();
  static const int kBegintimeFieldNumber = 4;
  inline ::google::protobuf::uint32 begintime() const;
  inline void set_begintime(::google::protobuf::uint32 value);

  // required uint32 endtime = 5;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 5;
  inline ::google::protobuf::uint32 endtime() const;
  inline void set_endtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PBMidLayer.SegmentTranscript)
 private:
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_languagename();
  inline void clear_has_languagename();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_begintime();
  inline void clear_has_begintime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* content_;
  ::std::string* languagename_;
  float score_;
  ::google::protobuf::uint32 begintime_;
  ::google::protobuf::uint32 endtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SegmentTranscript* default_instance_;
};
// -------------------------------------------------------------------

class SpeakerRule : public ::google::protobuf::Message {
 public:
  SpeakerRule();
  virtual ~SpeakerRule();

  SpeakerRule(const SpeakerRule& from);

  inline SpeakerRule& operator=(const SpeakerRule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeakerRule& default_instance();

  void Swap(SpeakerRule* other);

  // implements Message ----------------------------------------------

  SpeakerRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpeakerRule& from);
  void MergeFrom(const SpeakerRule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string objectid = 1;
  inline bool has_objectid() const;
  inline void clear_objectid();
  static const int kObjectidFieldNumber = 1;
  inline const ::std::string& objectid() const;
  inline void set_objectid(const ::std::string& value);
  inline void set_objectid(const char* value);
  inline void set_objectid(const char* value, size_t size);
  inline ::std::string* mutable_objectid();
  inline ::std::string* release_objectid();
  inline void set_allocated_objectid(::std::string* objectid);

  // optional int32 thresholdflag = 2;
  inline bool has_thresholdflag() const;
  inline void clear_thresholdflag();
  static const int kThresholdflagFieldNumber = 2;
  inline ::google::protobuf::int32 thresholdflag() const;
  inline void set_thresholdflag(::google::protobuf::int32 value);

  // optional float lowthreshold = 3;
  inline bool has_lowthreshold() const;
  inline void clear_lowthreshold();
  static const int kLowthresholdFieldNumber = 3;
  inline float lowthreshold() const;
  inline void set_lowthreshold(float value);

  // optional float highthreshold = 4;
  inline bool has_highthreshold() const;
  inline void clear_highthreshold();
  static const int kHighthresholdFieldNumber = 4;
  inline float highthreshold() const;
  inline void set_highthreshold(float value);

  // repeated .PBMidLayer.PhoneNumber telrule = 5;
  inline int telrule_size() const;
  inline void clear_telrule();
  static const int kTelruleFieldNumber = 5;
  inline const ::PBMidLayer::PhoneNumber& telrule(int index) const;
  inline ::PBMidLayer::PhoneNumber* mutable_telrule(int index);
  inline ::PBMidLayer::PhoneNumber* add_telrule();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber >&
      telrule() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber >*
      mutable_telrule();

  // @@protoc_insertion_point(class_scope:PBMidLayer.SpeakerRule)
 private:
  inline void set_has_objectid();
  inline void clear_has_objectid();
  inline void set_has_thresholdflag();
  inline void clear_has_thresholdflag();
  inline void set_has_lowthreshold();
  inline void clear_has_lowthreshold();
  inline void set_has_highthreshold();
  inline void clear_has_highthreshold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* objectid_;
  ::google::protobuf::int32 thresholdflag_;
  float lowthreshold_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber > telrule_;
  float highthreshold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SpeakerRule* default_instance_;
};
// -------------------------------------------------------------------

class KeywordRule : public ::google::protobuf::Message {
 public:
  KeywordRule();
  virtual ~KeywordRule();

  KeywordRule(const KeywordRule& from);

  inline KeywordRule& operator=(const KeywordRule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeywordRule& default_instance();

  void Swap(KeywordRule* other);

  // implements Message ----------------------------------------------

  KeywordRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeywordRule& from);
  void MergeFrom(const KeywordRule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string languagename = 1;
  inline bool has_languagename() const;
  inline void clear_languagename();
  static const int kLanguagenameFieldNumber = 1;
  inline const ::std::string& languagename() const;
  inline void set_languagename(const ::std::string& value);
  inline void set_languagename(const char* value);
  inline void set_languagename(const char* value, size_t size);
  inline ::std::string* mutable_languagename();
  inline ::std::string* release_languagename();
  inline void set_allocated_languagename(::std::string* languagename);

  // required string keyword = 2;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 2;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  inline void set_allocated_keyword(::std::string* keyword);

  // optional float threshold = 3;
  inline bool has_threshold() const;
  inline void clear_threshold();
  static const int kThresholdFieldNumber = 3;
  inline float threshold() const;
  inline void set_threshold(float value);

  // repeated .PBMidLayer.PhoneNumber telrule = 5;
  inline int telrule_size() const;
  inline void clear_telrule();
  static const int kTelruleFieldNumber = 5;
  inline const ::PBMidLayer::PhoneNumber& telrule(int index) const;
  inline ::PBMidLayer::PhoneNumber* mutable_telrule(int index);
  inline ::PBMidLayer::PhoneNumber* add_telrule();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber >&
      telrule() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber >*
      mutable_telrule();

  // @@protoc_insertion_point(class_scope:PBMidLayer.KeywordRule)
 private:
  inline void set_has_languagename();
  inline void clear_has_languagename();
  inline void set_has_keyword();
  inline void clear_has_keyword();
  inline void set_has_threshold();
  inline void clear_has_threshold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* languagename_;
  ::std::string* keyword_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber > telrule_;
  float threshold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static KeywordRule* default_instance_;
};
// -------------------------------------------------------------------

class SpeechSegRule : public ::google::protobuf::Message {
 public:
  SpeechSegRule();
  virtual ~SpeechSegRule();

  SpeechSegRule(const SpeechSegRule& from);

  inline SpeechSegRule& operator=(const SpeechSegRule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeechSegRule& default_instance();

  void Swap(SpeechSegRule* other);

  // implements Message ----------------------------------------------

  SpeechSegRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpeechSegRule& from);
  void MergeFrom(const SpeechSegRule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string languagename = 1;
  inline bool has_languagename() const;
  inline void clear_languagename();
  static const int kLanguagenameFieldNumber = 1;
  inline const ::std::string& languagename() const;
  inline void set_languagename(const ::std::string& value);
  inline void set_languagename(const char* value);
  inline void set_languagename(const char* value, size_t size);
  inline ::std::string* mutable_languagename();
  inline ::std::string* release_languagename();
  inline void set_allocated_languagename(::std::string* languagename);

  // required string speechsegid = 2;
  inline bool has_speechsegid() const;
  inline void clear_speechsegid();
  static const int kSpeechsegidFieldNumber = 2;
  inline const ::std::string& speechsegid() const;
  inline void set_speechsegid(const ::std::string& value);
  inline void set_speechsegid(const char* value);
  inline void set_speechsegid(const char* value, size_t size);
  inline ::std::string* mutable_speechsegid();
  inline ::std::string* release_speechsegid();
  inline void set_allocated_speechsegid(::std::string* speechsegid);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional string speechsegname = 4;
  inline bool has_speechsegname() const;
  inline void clear_speechsegname();
  static const int kSpeechsegnameFieldNumber = 4;
  inline const ::std::string& speechsegname() const;
  inline void set_speechsegname(const ::std::string& value);
  inline void set_speechsegname(const char* value);
  inline void set_speechsegname(const char* value, size_t size);
  inline ::std::string* mutable_speechsegname();
  inline ::std::string* release_speechsegname();
  inline void set_allocated_speechsegname(::std::string* speechsegname);

  // optional float threshold = 5;
  inline bool has_threshold() const;
  inline void clear_threshold();
  static const int kThresholdFieldNumber = 5;
  inline float threshold() const;
  inline void set_threshold(float value);

  // repeated .PBMidLayer.PhoneNumber telrule = 6;
  inline int telrule_size() const;
  inline void clear_telrule();
  static const int kTelruleFieldNumber = 6;
  inline const ::PBMidLayer::PhoneNumber& telrule(int index) const;
  inline ::PBMidLayer::PhoneNumber* mutable_telrule(int index);
  inline ::PBMidLayer::PhoneNumber* add_telrule();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber >&
      telrule() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber >*
      mutable_telrule();

  // @@protoc_insertion_point(class_scope:PBMidLayer.SpeechSegRule)
 private:
  inline void set_has_languagename();
  inline void clear_has_languagename();
  inline void set_has_speechsegid();
  inline void clear_has_speechsegid();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_speechsegname();
  inline void clear_has_speechsegname();
  inline void set_has_threshold();
  inline void clear_has_threshold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* languagename_;
  ::std::string* speechsegid_;
  ::std::string* data_;
  ::std::string* speechsegname_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber > telrule_;
  float threshold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SpeechSegRule* default_instance_;
};
// -------------------------------------------------------------------

class LanguageInfo : public ::google::protobuf::Message {
 public:
  LanguageInfo();
  virtual ~LanguageInfo();

  LanguageInfo(const LanguageInfo& from);

  inline LanguageInfo& operator=(const LanguageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LanguageInfo& default_instance();

  void Swap(LanguageInfo* other);

  // implements Message ----------------------------------------------

  LanguageInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LanguageInfo& from);
  void MergeFrom(const LanguageInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string languagename = 1;
  inline bool has_languagename() const;
  inline void clear_languagename();
  static const int kLanguagenameFieldNumber = 1;
  inline const ::std::string& languagename() const;
  inline void set_languagename(const ::std::string& value);
  inline void set_languagename(const char* value);
  inline void set_languagename(const char* value, size_t size);
  inline ::std::string* mutable_languagename();
  inline ::std::string* release_languagename();
  inline void set_allocated_languagename(::std::string* languagename);

  // required int32 keywordsupported = 2;
  inline bool has_keywordsupported() const;
  inline void clear_keywordsupported();
  static const int kKeywordsupportedFieldNumber = 2;
  inline ::google::protobuf::int32 keywordsupported() const;
  inline void set_keywordsupported(::google::protobuf::int32 value);

  // required int32 transsupported = 3;
  inline bool has_transsupported() const;
  inline void clear_transsupported();
  static const int kTranssupportedFieldNumber = 3;
  inline ::google::protobuf::int32 transsupported() const;
  inline void set_transsupported(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PBMidLayer.LanguageInfo)
 private:
  inline void set_has_languagename();
  inline void clear_has_languagename();
  inline void set_has_keywordsupported();
  inline void clear_has_keywordsupported();
  inline void set_has_transsupported();
  inline void clear_has_transsupported();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* languagename_;
  ::google::protobuf::int32 keywordsupported_;
  ::google::protobuf::int32 transsupported_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static LanguageInfo* default_instance_;
};
// -------------------------------------------------------------------

class TrainInfo : public ::google::protobuf::Message {
 public:
  TrainInfo();
  virtual ~TrainInfo();

  TrainInfo(const TrainInfo& from);

  inline TrainInfo& operator=(const TrainInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrainInfo& default_instance();

  void Swap(TrainInfo* other);

  // implements Message ----------------------------------------------

  TrainInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrainInfo& from);
  void MergeFrom(const TrainInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMidLayer.AudioEncodingTag code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::PBMidLayer::AudioEncodingTag code() const;
  inline void set_code(::PBMidLayer::AudioEncodingTag value);

  // required bool isdata = 2;
  inline bool has_isdata() const;
  inline void clear_isdata();
  static const int kIsdataFieldNumber = 2;
  inline bool isdata() const;
  inline void set_isdata(bool value);

  // optional bytes voice = 3;
  inline bool has_voice() const;
  inline void clear_voice();
  static const int kVoiceFieldNumber = 3;
  inline const ::std::string& voice() const;
  inline void set_voice(const ::std::string& value);
  inline void set_voice(const char* value);
  inline void set_voice(const void* value, size_t size);
  inline ::std::string* mutable_voice();
  inline ::std::string* release_voice();
  inline void set_allocated_voice(::std::string* voice);

  // optional string path = 4;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 4;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:PBMidLayer.TrainInfo)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_isdata();
  inline void clear_has_isdata();
  inline void set_has_voice();
  inline void clear_has_voice();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int code_;
  bool isdata_;
  ::std::string* voice_;
  ::std::string* path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static TrainInfo* default_instance_;
};
// -------------------------------------------------------------------

class PhoneNumber : public ::google::protobuf::Message {
 public:
  PhoneNumber();
  virtual ~PhoneNumber();

  PhoneNumber(const PhoneNumber& from);

  inline PhoneNumber& operator=(const PhoneNumber& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PhoneNumber& default_instance();

  void Swap(PhoneNumber* other);

  // implements Message ----------------------------------------------

  PhoneNumber* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PhoneNumber& from);
  void MergeFrom(const PhoneNumber& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string telnumber = 1;
  inline bool has_telnumber() const;
  inline void clear_telnumber();
  static const int kTelnumberFieldNumber = 1;
  inline const ::std::string& telnumber() const;
  inline void set_telnumber(const ::std::string& value);
  inline void set_telnumber(const char* value);
  inline void set_telnumber(const char* value, size_t size);
  inline ::std::string* mutable_telnumber();
  inline ::std::string* release_telnumber();
  inline void set_allocated_telnumber(::std::string* telnumber);

  // optional string countrycode = 2;
  inline bool has_countrycode() const;
  inline void clear_countrycode();
  static const int kCountrycodeFieldNumber = 2;
  inline const ::std::string& countrycode() const;
  inline void set_countrycode(const ::std::string& value);
  inline void set_countrycode(const char* value);
  inline void set_countrycode(const char* value, size_t size);
  inline ::std::string* mutable_countrycode();
  inline ::std::string* release_countrycode();
  inline void set_allocated_countrycode(::std::string* countrycode);

  // optional string provincecode = 3;
  inline bool has_provincecode() const;
  inline void clear_provincecode();
  static const int kProvincecodeFieldNumber = 3;
  inline const ::std::string& provincecode() const;
  inline void set_provincecode(const ::std::string& value);
  inline void set_provincecode(const char* value);
  inline void set_provincecode(const char* value, size_t size);
  inline ::std::string* mutable_provincecode();
  inline ::std::string* release_provincecode();
  inline void set_allocated_provincecode(::std::string* provincecode);

  // optional string areacode = 4;
  inline bool has_areacode() const;
  inline void clear_areacode();
  static const int kAreacodeFieldNumber = 4;
  inline const ::std::string& areacode() const;
  inline void set_areacode(const ::std::string& value);
  inline void set_areacode(const char* value);
  inline void set_areacode(const char* value, size_t size);
  inline ::std::string* mutable_areacode();
  inline ::std::string* release_areacode();
  inline void set_allocated_areacode(::std::string* areacode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.PhoneNumber)
 private:
  inline void set_has_telnumber();
  inline void clear_has_telnumber();
  inline void set_has_countrycode();
  inline void clear_has_countrycode();
  inline void set_has_provincecode();
  inline void clear_has_provincecode();
  inline void set_has_areacode();
  inline void clear_has_areacode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* telnumber_;
  ::std::string* countrycode_;
  ::std::string* provincecode_;
  ::std::string* areacode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static PhoneNumber* default_instance_;
};
// -------------------------------------------------------------------

class SearchTaskState : public ::google::protobuf::Message {
 public:
  SearchTaskState();
  virtual ~SearchTaskState();

  SearchTaskState(const SearchTaskState& from);

  inline SearchTaskState& operator=(const SearchTaskState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchTaskState& default_instance();

  void Swap(SearchTaskState* other);

  // implements Message ----------------------------------------------

  SearchTaskState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchTaskState& from);
  void MergeFrom(const SearchTaskState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMidLayer.SearchTaskRunState runstate = 1;
  inline bool has_runstate() const;
  inline void clear_runstate();
  static const int kRunstateFieldNumber = 1;
  inline ::PBMidLayer::SearchTaskRunState runstate() const;
  inline void set_runstate(::PBMidLayer::SearchTaskRunState value);

  // required uint64 queuetime = 2;
  inline bool has_queuetime() const;
  inline void clear_queuetime();
  static const int kQueuetimeFieldNumber = 2;
  inline ::google::protobuf::uint64 queuetime() const;
  inline void set_queuetime(::google::protobuf::uint64 value);

  // optional uint64 starttime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 3;
  inline ::google::protobuf::uint64 starttime() const;
  inline void set_starttime(::google::protobuf::uint64 value);

  // optional uint64 finishtime = 4;
  inline bool has_finishtime() const;
  inline void clear_finishtime();
  static const int kFinishtimeFieldNumber = 4;
  inline ::google::protobuf::uint64 finishtime() const;
  inline void set_finishtime(::google::protobuf::uint64 value);

  // optional uint64 aborttime = 5;
  inline bool has_aborttime() const;
  inline void clear_aborttime();
  static const int kAborttimeFieldNumber = 5;
  inline ::google::protobuf::uint64 aborttime() const;
  inline void set_aborttime(::google::protobuf::uint64 value);

  // optional string msg = 6;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 6;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:PBMidLayer.SearchTaskState)
 private:
  inline void set_has_runstate();
  inline void clear_has_runstate();
  inline void set_has_queuetime();
  inline void clear_has_queuetime();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_finishtime();
  inline void clear_has_finishtime();
  inline void set_has_aborttime();
  inline void clear_has_aborttime();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 queuetime_;
  ::google::protobuf::uint64 starttime_;
  ::google::protobuf::uint64 finishtime_;
  ::google::protobuf::uint64 aborttime_;
  ::std::string* msg_;
  int runstate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SearchTaskState* default_instance_;
};
// -------------------------------------------------------------------

class SystemCode : public ::google::protobuf::Message {
 public:
  SystemCode();
  virtual ~SystemCode();

  SystemCode(const SystemCode& from);

  inline SystemCode& operator=(const SystemCode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemCode& default_instance();

  void Swap(SystemCode* other);

  // implements Message ----------------------------------------------

  SystemCode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemCode& from);
  void MergeFrom(const SystemCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string spyid = 1;
  inline bool has_spyid() const;
  inline void clear_spyid();
  static const int kSpyidFieldNumber = 1;
  inline const ::std::string& spyid() const;
  inline void set_spyid(const ::std::string& value);
  inline void set_spyid(const char* value);
  inline void set_spyid(const char* value, size_t size);
  inline ::std::string* mutable_spyid();
  inline ::std::string* release_spyid();
  inline void set_allocated_spyid(::std::string* spyid);

  // optional string srid = 2;
  inline bool has_srid() const;
  inline void clear_srid();
  static const int kSridFieldNumber = 2;
  inline const ::std::string& srid() const;
  inline void set_srid(const ::std::string& value);
  inline void set_srid(const char* value);
  inline void set_srid(const char* value, size_t size);
  inline ::std::string* mutable_srid();
  inline ::std::string* release_srid();
  inline void set_allocated_srid(::std::string* srid);

  // repeated string datasource = 3;
  inline int datasource_size() const;
  inline void clear_datasource();
  static const int kDatasourceFieldNumber = 3;
  inline const ::std::string& datasource(int index) const;
  inline ::std::string* mutable_datasource(int index);
  inline void set_datasource(int index, const ::std::string& value);
  inline void set_datasource(int index, const char* value);
  inline void set_datasource(int index, const char* value, size_t size);
  inline ::std::string* add_datasource();
  inline void add_datasource(const ::std::string& value);
  inline void add_datasource(const char* value);
  inline void add_datasource(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& datasource() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_datasource();

  // @@protoc_insertion_point(class_scope:PBMidLayer.SystemCode)
 private:
  inline void set_has_spyid();
  inline void clear_has_spyid();
  inline void set_has_srid();
  inline void clear_has_srid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* spyid_;
  ::std::string* srid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> datasource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SystemCode* default_instance_;
};
// -------------------------------------------------------------------

class SearchFileResult : public ::google::protobuf::Message {
 public:
  SearchFileResult();
  virtual ~SearchFileResult();

  SearchFileResult(const SearchFileResult& from);

  inline SearchFileResult& operator=(const SearchFileResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchFileResult& default_instance();

  void Swap(SearchFileResult* other);

  // implements Message ----------------------------------------------

  SearchFileResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchFileResult& from);
  void MergeFrom(const SearchFileResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string callid = 1;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 1;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // required .PBMidLayer.AudioFileTag filetag = 2;
  inline bool has_filetag() const;
  inline void clear_filetag();
  static const int kFiletagFieldNumber = 2;
  inline ::PBMidLayer::AudioFileTag filetag() const;
  inline void set_filetag(::PBMidLayer::AudioFileTag value);

  // optional float score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline float score() const;
  inline void set_score(float value);

  // repeated .PBMidLayer.SpeakerItem speakers = 4;
  inline int speakers_size() const;
  inline void clear_speakers();
  static const int kSpeakersFieldNumber = 4;
  inline const ::PBMidLayer::SpeakerItem& speakers(int index) const;
  inline ::PBMidLayer::SpeakerItem* mutable_speakers(int index);
  inline ::PBMidLayer::SpeakerItem* add_speakers();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerItem >&
      speakers() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerItem >*
      mutable_speakers();

  // repeated .PBMidLayer.KeywordSnippet keywords = 5;
  inline int keywords_size() const;
  inline void clear_keywords();
  static const int kKeywordsFieldNumber = 5;
  inline const ::PBMidLayer::KeywordSnippet& keywords(int index) const;
  inline ::PBMidLayer::KeywordSnippet* mutable_keywords(int index);
  inline ::PBMidLayer::KeywordSnippet* add_keywords();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordSnippet >&
      keywords() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordSnippet >*
      mutable_keywords();

  // repeated .PBMidLayer.SpeechSegItem speechsegs = 6;
  inline int speechsegs_size() const;
  inline void clear_speechsegs();
  static const int kSpeechsegsFieldNumber = 6;
  inline const ::PBMidLayer::SpeechSegItem& speechsegs(int index) const;
  inline ::PBMidLayer::SpeechSegItem* mutable_speechsegs(int index);
  inline ::PBMidLayer::SpeechSegItem* add_speechsegs();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegItem >&
      speechsegs() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegItem >*
      mutable_speechsegs();

  // required string datasource = 7;
  inline bool has_datasource() const;
  inline void clear_datasource();
  static const int kDatasourceFieldNumber = 7;
  inline const ::std::string& datasource() const;
  inline void set_datasource(const ::std::string& value);
  inline void set_datasource(const char* value);
  inline void set_datasource(const char* value, size_t size);
  inline ::std::string* mutable_datasource();
  inline ::std::string* release_datasource();
  inline void set_allocated_datasource(::std::string* datasource);

  // @@protoc_insertion_point(class_scope:PBMidLayer.SearchFileResult)
 private:
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_filetag();
  inline void clear_has_filetag();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_datasource();
  inline void clear_has_datasource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* callid_;
  int filetag_;
  float score_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerItem > speakers_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordSnippet > keywords_;
  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegItem > speechsegs_;
  ::std::string* datasource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SearchFileResult* default_instance_;
};
// -------------------------------------------------------------------

class SpeechSegResult : public ::google::protobuf::Message {
 public:
  SpeechSegResult();
  virtual ~SpeechSegResult();

  SpeechSegResult(const SpeechSegResult& from);

  inline SpeechSegResult& operator=(const SpeechSegResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeechSegResult& default_instance();

  void Swap(SpeechSegResult* other);

  // implements Message ----------------------------------------------

  SpeechSegResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpeechSegResult& from);
  void MergeFrom(const SpeechSegResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PBMidLayer.SpeechSegItem speechsegs = 1;
  inline int speechsegs_size() const;
  inline void clear_speechsegs();
  static const int kSpeechsegsFieldNumber = 1;
  inline const ::PBMidLayer::SpeechSegItem& speechsegs(int index) const;
  inline ::PBMidLayer::SpeechSegItem* mutable_speechsegs(int index);
  inline ::PBMidLayer::SpeechSegItem* add_speechsegs();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegItem >&
      speechsegs() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegItem >*
      mutable_speechsegs();

  // optional string callid = 2;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 2;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // optional .PBMidLayer.AudioFileTag filetag = 3;
  inline bool has_filetag() const;
  inline void clear_filetag();
  static const int kFiletagFieldNumber = 3;
  inline ::PBMidLayer::AudioFileTag filetag() const;
  inline void set_filetag(::PBMidLayer::AudioFileTag value);

  // @@protoc_insertion_point(class_scope:PBMidLayer.SpeechSegResult)
 private:
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_filetag();
  inline void clear_has_filetag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegItem > speechsegs_;
  ::std::string* callid_;
  int filetag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SpeechSegResult* default_instance_;
};
// -------------------------------------------------------------------

class SpeechSegItem : public ::google::protobuf::Message {
 public:
  SpeechSegItem();
  virtual ~SpeechSegItem();

  SpeechSegItem(const SpeechSegItem& from);

  inline SpeechSegItem& operator=(const SpeechSegItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeechSegItem& default_instance();

  void Swap(SpeechSegItem* other);

  // implements Message ----------------------------------------------

  SpeechSegItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpeechSegItem& from);
  void MergeFrom(const SpeechSegItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string speechsegcode = 1;
  inline bool has_speechsegcode() const;
  inline void clear_speechsegcode();
  static const int kSpeechsegcodeFieldNumber = 1;
  inline const ::std::string& speechsegcode() const;
  inline void set_speechsegcode(const ::std::string& value);
  inline void set_speechsegcode(const char* value);
  inline void set_speechsegcode(const char* value, size_t size);
  inline ::std::string* mutable_speechsegcode();
  inline ::std::string* release_speechsegcode();
  inline void set_allocated_speechsegcode(::std::string* speechsegcode);

  // required int32 begin = 2;
  inline bool has_begin() const;
  inline void clear_begin();
  static const int kBeginFieldNumber = 2;
  inline ::google::protobuf::int32 begin() const;
  inline void set_begin(::google::protobuf::int32 value);

  // required int32 end = 3;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 3;
  inline ::google::protobuf::int32 end() const;
  inline void set_end(::google::protobuf::int32 value);

  // required int32 hitbegin = 4;
  inline bool has_hitbegin() const;
  inline void clear_hitbegin();
  static const int kHitbeginFieldNumber = 4;
  inline ::google::protobuf::int32 hitbegin() const;
  inline void set_hitbegin(::google::protobuf::int32 value);

  // required int32 hitend = 5;
  inline bool has_hitend() const;
  inline void clear_hitend();
  static const int kHitendFieldNumber = 5;
  inline ::google::protobuf::int32 hitend() const;
  inline void set_hitend(::google::protobuf::int32 value);

  // required float score = 6;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 6;
  inline float score() const;
  inline void set_score(float value);

  // optional string spyid = 7;
  inline bool has_spyid() const;
  inline void clear_spyid();
  static const int kSpyidFieldNumber = 7;
  inline const ::std::string& spyid() const;
  inline void set_spyid(const ::std::string& value);
  inline void set_spyid(const char* value);
  inline void set_spyid(const char* value, size_t size);
  inline ::std::string* mutable_spyid();
  inline ::std::string* release_spyid();
  inline void set_allocated_spyid(::std::string* spyid);

  // @@protoc_insertion_point(class_scope:PBMidLayer.SpeechSegItem)
 private:
  inline void set_has_speechsegcode();
  inline void clear_has_speechsegcode();
  inline void set_has_begin();
  inline void clear_has_begin();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_hitbegin();
  inline void clear_has_hitbegin();
  inline void set_has_hitend();
  inline void clear_has_hitend();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_spyid();
  inline void clear_has_spyid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* speechsegcode_;
  ::google::protobuf::int32 begin_;
  ::google::protobuf::int32 end_;
  ::google::protobuf::int32 hitbegin_;
  ::google::protobuf::int32 hitend_;
  ::std::string* spyid_;
  float score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SpeechSegItem* default_instance_;
};
// -------------------------------------------------------------------

class VADResult : public ::google::protobuf::Message {
 public:
  VADResult();
  virtual ~VADResult();

  VADResult(const VADResult& from);

  inline VADResult& operator=(const VADResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VADResult& default_instance();

  void Swap(VADResult* other);

  // implements Message ----------------------------------------------

  VADResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VADResult& from);
  void MergeFrom(const VADResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PBMidLayer.VADItem vads = 1;
  inline int vads_size() const;
  inline void clear_vads();
  static const int kVadsFieldNumber = 1;
  inline const ::PBMidLayer::VADItem& vads(int index) const;
  inline ::PBMidLayer::VADItem* mutable_vads(int index);
  inline ::PBMidLayer::VADItem* add_vads();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::VADItem >&
      vads() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::VADItem >*
      mutable_vads();

  // optional string callid = 2;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 2;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // optional .PBMidLayer.AudioFileTag filetag = 3;
  inline bool has_filetag() const;
  inline void clear_filetag();
  static const int kFiletagFieldNumber = 3;
  inline ::PBMidLayer::AudioFileTag filetag() const;
  inline void set_filetag(::PBMidLayer::AudioFileTag value);

  // @@protoc_insertion_point(class_scope:PBMidLayer.VADResult)
 private:
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_filetag();
  inline void clear_has_filetag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::VADItem > vads_;
  ::std::string* callid_;
  int filetag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static VADResult* default_instance_;
};
// -------------------------------------------------------------------

class VADItem : public ::google::protobuf::Message {
 public:
  VADItem();
  virtual ~VADItem();

  VADItem(const VADItem& from);

  inline VADItem& operator=(const VADItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VADItem& default_instance();

  void Swap(VADItem* other);

  // implements Message ----------------------------------------------

  VADItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VADItem& from);
  void MergeFrom(const VADItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 begin = 1;
  inline bool has_begin() const;
  inline void clear_begin();
  static const int kBeginFieldNumber = 1;
  inline ::google::protobuf::int32 begin() const;
  inline void set_begin(::google::protobuf::int32 value);

  // required int32 end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline ::google::protobuf::int32 end() const;
  inline void set_end(::google::protobuf::int32 value);

  // optional string spk = 3;
  inline bool has_spk() const;
  inline void clear_spk();
  static const int kSpkFieldNumber = 3;
  inline const ::std::string& spk() const;
  inline void set_spk(const ::std::string& value);
  inline void set_spk(const char* value);
  inline void set_spk(const char* value, size_t size);
  inline ::std::string* mutable_spk();
  inline ::std::string* release_spk();
  inline void set_allocated_spk(::std::string* spk);

  // @@protoc_insertion_point(class_scope:PBMidLayer.VADItem)
 private:
  inline void set_has_begin();
  inline void clear_has_begin();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_spk();
  inline void clear_has_spk();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 begin_;
  ::google::protobuf::int32 end_;
  ::std::string* spk_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static VADItem* default_instance_;
};
// -------------------------------------------------------------------

class DTMFResult : public ::google::protobuf::Message {
 public:
  DTMFResult();
  virtual ~DTMFResult();

  DTMFResult(const DTMFResult& from);

  inline DTMFResult& operator=(const DTMFResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DTMFResult& default_instance();

  void Swap(DTMFResult* other);

  // implements Message ----------------------------------------------

  DTMFResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DTMFResult& from);
  void MergeFrom(const DTMFResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PBMidLayer.DTMFItem dtms = 1;
  inline int dtms_size() const;
  inline void clear_dtms();
  static const int kDtmsFieldNumber = 1;
  inline const ::PBMidLayer::DTMFItem& dtms(int index) const;
  inline ::PBMidLayer::DTMFItem* mutable_dtms(int index);
  inline ::PBMidLayer::DTMFItem* add_dtms();
  inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::DTMFItem >&
      dtms() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::DTMFItem >*
      mutable_dtms();

  // optional string callid = 2;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 2;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // optional .PBMidLayer.AudioFileTag filetag = 3;
  inline bool has_filetag() const;
  inline void clear_filetag();
  static const int kFiletagFieldNumber = 3;
  inline ::PBMidLayer::AudioFileTag filetag() const;
  inline void set_filetag(::PBMidLayer::AudioFileTag value);

  // @@protoc_insertion_point(class_scope:PBMidLayer.DTMFResult)
 private:
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_filetag();
  inline void clear_has_filetag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PBMidLayer::DTMFItem > dtms_;
  ::std::string* callid_;
  int filetag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static DTMFResult* default_instance_;
};
// -------------------------------------------------------------------

class DTMFItem : public ::google::protobuf::Message {
 public:
  DTMFItem();
  virtual ~DTMFItem();

  DTMFItem(const DTMFItem& from);

  inline DTMFItem& operator=(const DTMFItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DTMFItem& default_instance();

  void Swap(DTMFItem* other);

  // implements Message ----------------------------------------------

  DTMFItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DTMFItem& from);
  void MergeFrom(const DTMFItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required int32 begin = 2;
  inline bool has_begin() const;
  inline void clear_begin();
  static const int kBeginFieldNumber = 2;
  inline ::google::protobuf::int32 begin() const;
  inline void set_begin(::google::protobuf::int32 value);

  // required int32 end = 3;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 3;
  inline ::google::protobuf::int32 end() const;
  inline void set_end(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PBMidLayer.DTMFItem)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_begin();
  inline void clear_has_begin();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 begin_;
  ::google::protobuf::int32 end_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static DTMFItem* default_instance_;
};
// -------------------------------------------------------------------

class SystemStateItem : public ::google::protobuf::Message {
 public:
  SystemStateItem();
  virtual ~SystemStateItem();

  SystemStateItem(const SystemStateItem& from);

  inline SystemStateItem& operator=(const SystemStateItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemStateItem& default_instance();

  void Swap(SystemStateItem* other);

  // implements Message ----------------------------------------------

  SystemStateItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemStateItem& from);
  void MergeFrom(const SystemStateItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string statename = 1;
  inline bool has_statename() const;
  inline void clear_statename();
  static const int kStatenameFieldNumber = 1;
  inline const ::std::string& statename() const;
  inline void set_statename(const ::std::string& value);
  inline void set_statename(const char* value);
  inline void set_statename(const char* value, size_t size);
  inline ::std::string* mutable_statename();
  inline ::std::string* release_statename();
  inline void set_allocated_statename(::std::string* statename);

  // required string statevalue = 2;
  inline bool has_statevalue() const;
  inline void clear_statevalue();
  static const int kStatevalueFieldNumber = 2;
  inline const ::std::string& statevalue() const;
  inline void set_statevalue(const ::std::string& value);
  inline void set_statevalue(const char* value);
  inline void set_statevalue(const char* value, size_t size);
  inline ::std::string* mutable_statevalue();
  inline ::std::string* release_statevalue();
  inline void set_allocated_statevalue(::std::string* statevalue);

  // optional string remark = 3;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 3;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // @@protoc_insertion_point(class_scope:PBMidLayer.SystemStateItem)
 private:
  inline void set_has_statename();
  inline void clear_has_statename();
  inline void set_has_statevalue();
  inline void clear_has_statevalue();
  inline void set_has_remark();
  inline void clear_has_remark();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* statename_;
  ::std::string* statevalue_;
  ::std::string* remark_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static SystemStateItem* default_instance_;
};
// -------------------------------------------------------------------

class FileDataNotify : public ::google::protobuf::Message {
 public:
  FileDataNotify();
  virtual ~FileDataNotify();

  FileDataNotify(const FileDataNotify& from);

  inline FileDataNotify& operator=(const FileDataNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileDataNotify& default_instance();

  void Swap(FileDataNotify* other);

  // implements Message ----------------------------------------------

  FileDataNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileDataNotify& from);
  void MergeFrom(const FileDataNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string callid = 1;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 1;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // required .PBMidLayer.AudioFileTag filetag = 2;
  inline bool has_filetag() const;
  inline void clear_filetag();
  static const int kFiletagFieldNumber = 2;
  inline ::PBMidLayer::AudioFileTag filetag() const;
  inline void set_filetag(::PBMidLayer::AudioFileTag value);

  // required .PBMidLayer.AudioEncodingTag code = 3;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 3;
  inline ::PBMidLayer::AudioEncodingTag code() const;
  inline void set_code(::PBMidLayer::AudioEncodingTag value);

  // required bytes voice = 4;
  inline bool has_voice() const;
  inline void clear_voice();
  static const int kVoiceFieldNumber = 4;
  inline const ::std::string& voice() const;
  inline void set_voice(const ::std::string& value);
  inline void set_voice(const char* value);
  inline void set_voice(const void* value, size_t size);
  inline ::std::string* mutable_voice();
  inline ::std::string* release_voice();
  inline void set_allocated_voice(::std::string* voice);

  // required .PBMidLayer.SystemCode syscode = 5;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 5;
  inline const ::PBMidLayer::SystemCode& syscode() const;
  inline ::PBMidLayer::SystemCode* mutable_syscode();
  inline ::PBMidLayer::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBMidLayer::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBMidLayer.FileDataNotify)
 private:
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_filetag();
  inline void clear_has_filetag();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_voice();
  inline void clear_has_voice();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* callid_;
  int filetag_;
  int code_;
  ::std::string* voice_;
  ::PBMidLayer::SystemCode* syscode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PBMidLayer_2eproto();
  friend void protobuf_AssignDesc_PBMidLayer_2eproto();
  friend void protobuf_ShutdownFile_PBMidLayer_2eproto();

  void InitAsDefaultInstance();
  static FileDataNotify* default_instance_;
};
// ===================================================================


// ===================================================================

// HeadMsg

// required fixed32 syn = 1 [default = 255];
inline bool HeadMsg::has_syn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeadMsg::set_has_syn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeadMsg::clear_has_syn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeadMsg::clear_syn() {
  syn_ = 255u;
  clear_has_syn();
}
inline ::google::protobuf::uint32 HeadMsg::syn() const {
  return syn_;
}
inline void HeadMsg::set_syn(::google::protobuf::uint32 value) {
  set_has_syn();
  syn_ = value;
}

// required fixed32 pro = 2 [default = 100];
inline bool HeadMsg::has_pro() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeadMsg::set_has_pro() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeadMsg::clear_has_pro() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeadMsg::clear_pro() {
  pro_ = 100u;
  clear_has_pro();
}
inline ::google::protobuf::uint32 HeadMsg::pro() const {
  return pro_;
}
inline void HeadMsg::set_pro(::google::protobuf::uint32 value) {
  set_has_pro();
  pro_ = value;
}

// required fixed32 type = 3;
inline bool HeadMsg::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeadMsg::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeadMsg::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeadMsg::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 HeadMsg::type() const {
  return type_;
}
inline void HeadMsg::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required fixed64 seqno = 4;
inline bool HeadMsg::has_seqno() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeadMsg::set_has_seqno() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeadMsg::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeadMsg::clear_seqno() {
  seqno_ = GOOGLE_ULONGLONG(0);
  clear_has_seqno();
}
inline ::google::protobuf::uint64 HeadMsg::seqno() const {
  return seqno_;
}
inline void HeadMsg::set_seqno(::google::protobuf::uint64 value) {
  set_has_seqno();
  seqno_ = value;
}

// required fixed32 len = 5;
inline bool HeadMsg::has_len() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HeadMsg::set_has_len() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HeadMsg::clear_has_len() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HeadMsg::clear_len() {
  len_ = 0u;
  clear_has_len();
}
inline ::google::protobuf::uint32 HeadMsg::len() const {
  return len_;
}
inline void HeadMsg::set_len(::google::protobuf::uint32 value) {
  set_has_len();
  len_ = value;
}

// -------------------------------------------------------------------

// ConnectRequest

// required string spyid = 1;
inline bool ConnectRequest::has_spyid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectRequest::set_has_spyid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectRequest::clear_has_spyid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectRequest::clear_spyid() {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    spyid_->clear();
  }
  clear_has_spyid();
}
inline const ::std::string& ConnectRequest::spyid() const {
  return *spyid_;
}
inline void ConnectRequest::set_spyid(const ::std::string& value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void ConnectRequest::set_spyid(const char* value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void ConnectRequest::set_spyid(const char* value, size_t size) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectRequest::mutable_spyid() {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  return spyid_;
}
inline ::std::string* ConnectRequest::release_spyid() {
  clear_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spyid_;
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectRequest::set_allocated_spyid(::std::string* spyid) {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    delete spyid_;
  }
  if (spyid) {
    set_has_spyid();
    spyid_ = spyid;
  } else {
    clear_has_spyid();
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string srid = 2;
inline bool ConnectRequest::has_srid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectRequest::set_has_srid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectRequest::clear_has_srid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectRequest::clear_srid() {
  if (srid_ != &::google::protobuf::internal::kEmptyString) {
    srid_->clear();
  }
  clear_has_srid();
}
inline const ::std::string& ConnectRequest::srid() const {
  return *srid_;
}
inline void ConnectRequest::set_srid(const ::std::string& value) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(value);
}
inline void ConnectRequest::set_srid(const char* value) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(value);
}
inline void ConnectRequest::set_srid(const char* value, size_t size) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectRequest::mutable_srid() {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  return srid_;
}
inline ::std::string* ConnectRequest::release_srid() {
  clear_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srid_;
    srid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectRequest::set_allocated_srid(::std::string* srid) {
  if (srid_ != &::google::protobuf::internal::kEmptyString) {
    delete srid_;
  }
  if (srid) {
    set_has_srid();
    srid_ = srid;
  } else {
    clear_has_srid();
    srid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ConnectResponse

// required .PBMidLayer.OperationStatus status = 1;
inline bool ConnectResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectResponse::clear_status() {
  if (status_ != NULL) status_->::PBMidLayer::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBMidLayer::OperationStatus& ConnectResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBMidLayer::OperationStatus* ConnectResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBMidLayer::OperationStatus;
  return status_;
}
inline ::PBMidLayer::OperationStatus* ConnectResponse::release_status() {
  clear_has_status();
  ::PBMidLayer::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void ConnectResponse::set_allocated_status(::PBMidLayer::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// required string spyid = 2;
inline bool ConnectResponse::has_spyid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectResponse::set_has_spyid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectResponse::clear_has_spyid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectResponse::clear_spyid() {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    spyid_->clear();
  }
  clear_has_spyid();
}
inline const ::std::string& ConnectResponse::spyid() const {
  return *spyid_;
}
inline void ConnectResponse::set_spyid(const ::std::string& value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void ConnectResponse::set_spyid(const char* value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void ConnectResponse::set_spyid(const char* value, size_t size) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectResponse::mutable_spyid() {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  return spyid_;
}
inline ::std::string* ConnectResponse::release_spyid() {
  clear_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spyid_;
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectResponse::set_allocated_spyid(::std::string* spyid) {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    delete spyid_;
  }
  if (spyid) {
    set_has_spyid();
    spyid_ = spyid;
  } else {
    clear_has_spyid();
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string srid = 3;
inline bool ConnectResponse::has_srid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectResponse::set_has_srid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectResponse::clear_has_srid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectResponse::clear_srid() {
  if (srid_ != &::google::protobuf::internal::kEmptyString) {
    srid_->clear();
  }
  clear_has_srid();
}
inline const ::std::string& ConnectResponse::srid() const {
  return *srid_;
}
inline void ConnectResponse::set_srid(const ::std::string& value) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(value);
}
inline void ConnectResponse::set_srid(const char* value) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(value);
}
inline void ConnectResponse::set_srid(const char* value, size_t size) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectResponse::mutable_srid() {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  return srid_;
}
inline ::std::string* ConnectResponse::release_srid() {
  clear_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srid_;
    srid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectResponse::set_allocated_srid(::std::string* srid) {
  if (srid_ != &::google::protobuf::internal::kEmptyString) {
    delete srid_;
  }
  if (srid) {
    set_has_srid();
    srid_ = srid;
  } else {
    clear_has_srid();
    srid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ConnectRelease

// required .PBMidLayer.OperationStatus status = 1;
inline bool ConnectRelease::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectRelease::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectRelease::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectRelease::clear_status() {
  if (status_ != NULL) status_->::PBMidLayer::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBMidLayer::OperationStatus& ConnectRelease::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBMidLayer::OperationStatus* ConnectRelease::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBMidLayer::OperationStatus;
  return status_;
}
inline ::PBMidLayer::OperationStatus* ConnectRelease::release_status() {
  clear_has_status();
  ::PBMidLayer::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void ConnectRelease::set_allocated_status(::PBMidLayer::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// required string spyid = 2;
inline bool ConnectRelease::has_spyid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectRelease::set_has_spyid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectRelease::clear_has_spyid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectRelease::clear_spyid() {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    spyid_->clear();
  }
  clear_has_spyid();
}
inline const ::std::string& ConnectRelease::spyid() const {
  return *spyid_;
}
inline void ConnectRelease::set_spyid(const ::std::string& value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void ConnectRelease::set_spyid(const char* value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void ConnectRelease::set_spyid(const char* value, size_t size) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectRelease::mutable_spyid() {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  return spyid_;
}
inline ::std::string* ConnectRelease::release_spyid() {
  clear_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spyid_;
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectRelease::set_allocated_spyid(::std::string* spyid) {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    delete spyid_;
  }
  if (spyid) {
    set_has_spyid();
    spyid_ = spyid;
  } else {
    clear_has_spyid();
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string srid = 3;
inline bool ConnectRelease::has_srid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectRelease::set_has_srid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectRelease::clear_has_srid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectRelease::clear_srid() {
  if (srid_ != &::google::protobuf::internal::kEmptyString) {
    srid_->clear();
  }
  clear_has_srid();
}
inline const ::std::string& ConnectRelease::srid() const {
  return *srid_;
}
inline void ConnectRelease::set_srid(const ::std::string& value) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(value);
}
inline void ConnectRelease::set_srid(const char* value) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(value);
}
inline void ConnectRelease::set_srid(const char* value, size_t size) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectRelease::mutable_srid() {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  return srid_;
}
inline ::std::string* ConnectRelease::release_srid() {
  clear_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srid_;
    srid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectRelease::set_allocated_srid(::std::string* srid) {
  if (srid_ != &::google::protobuf::internal::kEmptyString) {
    delete srid_;
  }
  if (srid) {
    set_has_srid();
    srid_ = srid;
  } else {
    clear_has_srid();
    srid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EchoReqRes

// required uint32 timestamp = 1;
inline bool EchoReqRes::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EchoReqRes::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EchoReqRes::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EchoReqRes::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 EchoReqRes::timestamp() const {
  return timestamp_;
}
inline void EchoReqRes::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// CallProcessRequest

// required string callid = 1;
inline bool CallProcessRequest::has_callid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CallProcessRequest::set_has_callid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CallProcessRequest::clear_has_callid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CallProcessRequest::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& CallProcessRequest::callid() const {
  return *callid_;
}
inline void CallProcessRequest::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void CallProcessRequest::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void CallProcessRequest::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CallProcessRequest::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* CallProcessRequest::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CallProcessRequest::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.AudioRecordMode flag = 2;
inline bool CallProcessRequest::has_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CallProcessRequest::set_has_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CallProcessRequest::clear_has_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CallProcessRequest::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::PBMidLayer::AudioRecordMode CallProcessRequest::flag() const {
  return static_cast< ::PBMidLayer::AudioRecordMode >(flag_);
}
inline void CallProcessRequest::set_flag(::PBMidLayer::AudioRecordMode value) {
  assert(::PBMidLayer::AudioRecordMode_IsValid(value));
  set_has_flag();
  flag_ = value;
}

// required int32 terminals = 3;
inline bool CallProcessRequest::has_terminals() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CallProcessRequest::set_has_terminals() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CallProcessRequest::clear_has_terminals() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CallProcessRequest::clear_terminals() {
  terminals_ = 0;
  clear_has_terminals();
}
inline ::google::protobuf::int32 CallProcessRequest::terminals() const {
  return terminals_;
}
inline void CallProcessRequest::set_terminals(::google::protobuf::int32 value) {
  set_has_terminals();
  terminals_ = value;
}

// required .PBMidLayer.AudioChannelType channeltype = 4;
inline bool CallProcessRequest::has_channeltype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CallProcessRequest::set_has_channeltype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CallProcessRequest::clear_has_channeltype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CallProcessRequest::clear_channeltype() {
  channeltype_ = 0;
  clear_has_channeltype();
}
inline ::PBMidLayer::AudioChannelType CallProcessRequest::channeltype() const {
  return static_cast< ::PBMidLayer::AudioChannelType >(channeltype_);
}
inline void CallProcessRequest::set_channeltype(::PBMidLayer::AudioChannelType value) {
  assert(::PBMidLayer::AudioChannelType_IsValid(value));
  set_has_channeltype();
  channeltype_ = value;
}

// required .PBMidLayer.AudioTransFlag transflag = 5 [default = ATF_NotTrans];
inline bool CallProcessRequest::has_transflag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CallProcessRequest::set_has_transflag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CallProcessRequest::clear_has_transflag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CallProcessRequest::clear_transflag() {
  transflag_ = 2;
  clear_has_transflag();
}
inline ::PBMidLayer::AudioTransFlag CallProcessRequest::transflag() const {
  return static_cast< ::PBMidLayer::AudioTransFlag >(transflag_);
}
inline void CallProcessRequest::set_transflag(::PBMidLayer::AudioTransFlag value) {
  assert(::PBMidLayer::AudioTransFlag_IsValid(value));
  set_has_transflag();
  transflag_ = value;
}

// optional string caller = 6;
inline bool CallProcessRequest::has_caller() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CallProcessRequest::set_has_caller() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CallProcessRequest::clear_has_caller() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CallProcessRequest::clear_caller() {
  if (caller_ != &::google::protobuf::internal::kEmptyString) {
    caller_->clear();
  }
  clear_has_caller();
}
inline const ::std::string& CallProcessRequest::caller() const {
  return *caller_;
}
inline void CallProcessRequest::set_caller(const ::std::string& value) {
  set_has_caller();
  if (caller_ == &::google::protobuf::internal::kEmptyString) {
    caller_ = new ::std::string;
  }
  caller_->assign(value);
}
inline void CallProcessRequest::set_caller(const char* value) {
  set_has_caller();
  if (caller_ == &::google::protobuf::internal::kEmptyString) {
    caller_ = new ::std::string;
  }
  caller_->assign(value);
}
inline void CallProcessRequest::set_caller(const char* value, size_t size) {
  set_has_caller();
  if (caller_ == &::google::protobuf::internal::kEmptyString) {
    caller_ = new ::std::string;
  }
  caller_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CallProcessRequest::mutable_caller() {
  set_has_caller();
  if (caller_ == &::google::protobuf::internal::kEmptyString) {
    caller_ = new ::std::string;
  }
  return caller_;
}
inline ::std::string* CallProcessRequest::release_caller() {
  clear_has_caller();
  if (caller_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = caller_;
    caller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CallProcessRequest::set_allocated_caller(::std::string* caller) {
  if (caller_ != &::google::protobuf::internal::kEmptyString) {
    delete caller_;
  }
  if (caller) {
    set_has_caller();
    caller_ = caller;
  } else {
    clear_has_caller();
    caller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string callee = 7;
inline bool CallProcessRequest::has_callee() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CallProcessRequest::set_has_callee() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CallProcessRequest::clear_has_callee() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CallProcessRequest::clear_callee() {
  if (callee_ != &::google::protobuf::internal::kEmptyString) {
    callee_->clear();
  }
  clear_has_callee();
}
inline const ::std::string& CallProcessRequest::callee() const {
  return *callee_;
}
inline void CallProcessRequest::set_callee(const ::std::string& value) {
  set_has_callee();
  if (callee_ == &::google::protobuf::internal::kEmptyString) {
    callee_ = new ::std::string;
  }
  callee_->assign(value);
}
inline void CallProcessRequest::set_callee(const char* value) {
  set_has_callee();
  if (callee_ == &::google::protobuf::internal::kEmptyString) {
    callee_ = new ::std::string;
  }
  callee_->assign(value);
}
inline void CallProcessRequest::set_callee(const char* value, size_t size) {
  set_has_callee();
  if (callee_ == &::google::protobuf::internal::kEmptyString) {
    callee_ = new ::std::string;
  }
  callee_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CallProcessRequest::mutable_callee() {
  set_has_callee();
  if (callee_ == &::google::protobuf::internal::kEmptyString) {
    callee_ = new ::std::string;
  }
  return callee_;
}
inline ::std::string* CallProcessRequest::release_callee() {
  clear_has_callee();
  if (callee_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callee_;
    callee_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CallProcessRequest::set_allocated_callee(::std::string* callee) {
  if (callee_ != &::google::protobuf::internal::kEmptyString) {
    delete callee_;
  }
  if (callee) {
    set_has_callee();
    callee_ = callee;
  } else {
    clear_has_callee();
    callee_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string third = 8;
inline bool CallProcessRequest::has_third() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CallProcessRequest::set_has_third() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CallProcessRequest::clear_has_third() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CallProcessRequest::clear_third() {
  if (third_ != &::google::protobuf::internal::kEmptyString) {
    third_->clear();
  }
  clear_has_third();
}
inline const ::std::string& CallProcessRequest::third() const {
  return *third_;
}
inline void CallProcessRequest::set_third(const ::std::string& value) {
  set_has_third();
  if (third_ == &::google::protobuf::internal::kEmptyString) {
    third_ = new ::std::string;
  }
  third_->assign(value);
}
inline void CallProcessRequest::set_third(const char* value) {
  set_has_third();
  if (third_ == &::google::protobuf::internal::kEmptyString) {
    third_ = new ::std::string;
  }
  third_->assign(value);
}
inline void CallProcessRequest::set_third(const char* value, size_t size) {
  set_has_third();
  if (third_ == &::google::protobuf::internal::kEmptyString) {
    third_ = new ::std::string;
  }
  third_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CallProcessRequest::mutable_third() {
  set_has_third();
  if (third_ == &::google::protobuf::internal::kEmptyString) {
    third_ = new ::std::string;
  }
  return third_;
}
inline ::std::string* CallProcessRequest::release_third() {
  clear_has_third();
  if (third_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = third_;
    third_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CallProcessRequest::set_allocated_third(::std::string* third) {
  if (third_ != &::google::protobuf::internal::kEmptyString) {
    delete third_;
  }
  if (third) {
    set_has_third();
    third_ = third;
  } else {
    clear_has_third();
    third_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 starttime = 9;
inline bool CallProcessRequest::has_starttime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CallProcessRequest::set_has_starttime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CallProcessRequest::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CallProcessRequest::clear_starttime() {
  starttime_ = GOOGLE_ULONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::uint64 CallProcessRequest::starttime() const {
  return starttime_;
}
inline void CallProcessRequest::set_starttime(::google::protobuf::uint64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional uint64 endtime = 10;
inline bool CallProcessRequest::has_endtime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CallProcessRequest::set_has_endtime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CallProcessRequest::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CallProcessRequest::clear_endtime() {
  endtime_ = GOOGLE_ULONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::uint64 CallProcessRequest::endtime() const {
  return endtime_;
}
inline void CallProcessRequest::set_endtime(::google::protobuf::uint64 value) {
  set_has_endtime();
  endtime_ = value;
}

// optional uint32 recogflag = 11 [default = 7];
inline bool CallProcessRequest::has_recogflag() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CallProcessRequest::set_has_recogflag() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CallProcessRequest::clear_has_recogflag() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CallProcessRequest::clear_recogflag() {
  recogflag_ = 7u;
  clear_has_recogflag();
}
inline ::google::protobuf::uint32 CallProcessRequest::recogflag() const {
  return recogflag_;
}
inline void CallProcessRequest::set_recogflag(::google::protobuf::uint32 value) {
  set_has_recogflag();
  recogflag_ = value;
}

// optional .PBMidLayer.FileAcquireMethod method = 12 [default = FAM_URL];
inline bool CallProcessRequest::has_method() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CallProcessRequest::set_has_method() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CallProcessRequest::clear_has_method() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CallProcessRequest::clear_method() {
  method_ = 1;
  clear_has_method();
}
inline ::PBMidLayer::FileAcquireMethod CallProcessRequest::method() const {
  return static_cast< ::PBMidLayer::FileAcquireMethod >(method_);
}
inline void CallProcessRequest::set_method(::PBMidLayer::FileAcquireMethod value) {
  assert(::PBMidLayer::FileAcquireMethod_IsValid(value));
  set_has_method();
  method_ = value;
}

// optional .PBMidLayer.PhoneNumber callerappendix = 13;
inline bool CallProcessRequest::has_callerappendix() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CallProcessRequest::set_has_callerappendix() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CallProcessRequest::clear_has_callerappendix() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CallProcessRequest::clear_callerappendix() {
  if (callerappendix_ != NULL) callerappendix_->::PBMidLayer::PhoneNumber::Clear();
  clear_has_callerappendix();
}
inline const ::PBMidLayer::PhoneNumber& CallProcessRequest::callerappendix() const {
  return callerappendix_ != NULL ? *callerappendix_ : *default_instance_->callerappendix_;
}
inline ::PBMidLayer::PhoneNumber* CallProcessRequest::mutable_callerappendix() {
  set_has_callerappendix();
  if (callerappendix_ == NULL) callerappendix_ = new ::PBMidLayer::PhoneNumber;
  return callerappendix_;
}
inline ::PBMidLayer::PhoneNumber* CallProcessRequest::release_callerappendix() {
  clear_has_callerappendix();
  ::PBMidLayer::PhoneNumber* temp = callerappendix_;
  callerappendix_ = NULL;
  return temp;
}
inline void CallProcessRequest::set_allocated_callerappendix(::PBMidLayer::PhoneNumber* callerappendix) {
  delete callerappendix_;
  callerappendix_ = callerappendix;
  if (callerappendix) {
    set_has_callerappendix();
  } else {
    clear_has_callerappendix();
  }
}

// optional .PBMidLayer.PhoneNumber calleeappendix = 14;
inline bool CallProcessRequest::has_calleeappendix() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CallProcessRequest::set_has_calleeappendix() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CallProcessRequest::clear_has_calleeappendix() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CallProcessRequest::clear_calleeappendix() {
  if (calleeappendix_ != NULL) calleeappendix_->::PBMidLayer::PhoneNumber::Clear();
  clear_has_calleeappendix();
}
inline const ::PBMidLayer::PhoneNumber& CallProcessRequest::calleeappendix() const {
  return calleeappendix_ != NULL ? *calleeappendix_ : *default_instance_->calleeappendix_;
}
inline ::PBMidLayer::PhoneNumber* CallProcessRequest::mutable_calleeappendix() {
  set_has_calleeappendix();
  if (calleeappendix_ == NULL) calleeappendix_ = new ::PBMidLayer::PhoneNumber;
  return calleeappendix_;
}
inline ::PBMidLayer::PhoneNumber* CallProcessRequest::release_calleeappendix() {
  clear_has_calleeappendix();
  ::PBMidLayer::PhoneNumber* temp = calleeappendix_;
  calleeappendix_ = NULL;
  return temp;
}
inline void CallProcessRequest::set_allocated_calleeappendix(::PBMidLayer::PhoneNumber* calleeappendix) {
  delete calleeappendix_;
  calleeappendix_ = calleeappendix;
  if (calleeappendix) {
    set_has_calleeappendix();
  } else {
    clear_has_calleeappendix();
  }
}

// optional .PBMidLayer.PhoneNumber thirdappendix = 15;
inline bool CallProcessRequest::has_thirdappendix() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CallProcessRequest::set_has_thirdappendix() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CallProcessRequest::clear_has_thirdappendix() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CallProcessRequest::clear_thirdappendix() {
  if (thirdappendix_ != NULL) thirdappendix_->::PBMidLayer::PhoneNumber::Clear();
  clear_has_thirdappendix();
}
inline const ::PBMidLayer::PhoneNumber& CallProcessRequest::thirdappendix() const {
  return thirdappendix_ != NULL ? *thirdappendix_ : *default_instance_->thirdappendix_;
}
inline ::PBMidLayer::PhoneNumber* CallProcessRequest::mutable_thirdappendix() {
  set_has_thirdappendix();
  if (thirdappendix_ == NULL) thirdappendix_ = new ::PBMidLayer::PhoneNumber;
  return thirdappendix_;
}
inline ::PBMidLayer::PhoneNumber* CallProcessRequest::release_thirdappendix() {
  clear_has_thirdappendix();
  ::PBMidLayer::PhoneNumber* temp = thirdappendix_;
  thirdappendix_ = NULL;
  return temp;
}
inline void CallProcessRequest::set_allocated_thirdappendix(::PBMidLayer::PhoneNumber* thirdappendix) {
  delete thirdappendix_;
  thirdappendix_ = thirdappendix;
  if (thirdappendix) {
    set_has_thirdappendix();
  } else {
    clear_has_thirdappendix();
  }
}

// optional .PBMidLayer.PriorityType priority = 16 [default = PT_Normal];
inline bool CallProcessRequest::has_priority() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CallProcessRequest::set_has_priority() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CallProcessRequest::clear_has_priority() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CallProcessRequest::clear_priority() {
  priority_ = 2;
  clear_has_priority();
}
inline ::PBMidLayer::PriorityType CallProcessRequest::priority() const {
  return static_cast< ::PBMidLayer::PriorityType >(priority_);
}
inline void CallProcessRequest::set_priority(::PBMidLayer::PriorityType value) {
  assert(::PBMidLayer::PriorityType_IsValid(value));
  set_has_priority();
  priority_ = value;
}

// optional .PBMidLayer.SystemCode syscode = 17;
inline bool CallProcessRequest::has_syscode() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CallProcessRequest::set_has_syscode() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CallProcessRequest::clear_has_syscode() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CallProcessRequest::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& CallProcessRequest::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* CallProcessRequest::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* CallProcessRequest::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void CallProcessRequest::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// optional bool isimport = 18;
inline bool CallProcessRequest::has_isimport() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CallProcessRequest::set_has_isimport() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CallProcessRequest::clear_has_isimport() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CallProcessRequest::clear_isimport() {
  isimport_ = false;
  clear_has_isimport();
}
inline bool CallProcessRequest::isimport() const {
  return isimport_;
}
inline void CallProcessRequest::set_isimport(bool value) {
  set_has_isimport();
  isimport_ = value;
}

// repeated .PBMidLayer.FileLocationNotify voicefiles = 19;
inline int CallProcessRequest::voicefiles_size() const {
  return voicefiles_.size();
}
inline void CallProcessRequest::clear_voicefiles() {
  voicefiles_.Clear();
}
inline const ::PBMidLayer::FileLocationNotify& CallProcessRequest::voicefiles(int index) const {
  return voicefiles_.Get(index);
}
inline ::PBMidLayer::FileLocationNotify* CallProcessRequest::mutable_voicefiles(int index) {
  return voicefiles_.Mutable(index);
}
inline ::PBMidLayer::FileLocationNotify* CallProcessRequest::add_voicefiles() {
  return voicefiles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::FileLocationNotify >&
CallProcessRequest::voicefiles() const {
  return voicefiles_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::FileLocationNotify >*
CallProcessRequest::mutable_voicefiles() {
  return &voicefiles_;
}

// -------------------------------------------------------------------

// CallProcessResponse

// required string callid = 1;
inline bool CallProcessResponse::has_callid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CallProcessResponse::set_has_callid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CallProcessResponse::clear_has_callid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CallProcessResponse::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& CallProcessResponse::callid() const {
  return *callid_;
}
inline void CallProcessResponse::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void CallProcessResponse::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void CallProcessResponse::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CallProcessResponse::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* CallProcessResponse::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CallProcessResponse::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.OperationStatus status = 2;
inline bool CallProcessResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CallProcessResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CallProcessResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CallProcessResponse::clear_status() {
  if (status_ != NULL) status_->::PBMidLayer::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBMidLayer::OperationStatus& CallProcessResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBMidLayer::OperationStatus* CallProcessResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBMidLayer::OperationStatus;
  return status_;
}
inline ::PBMidLayer::OperationStatus* CallProcessResponse::release_status() {
  clear_has_status();
  ::PBMidLayer::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void CallProcessResponse::set_allocated_status(::PBMidLayer::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// required .PBMidLayer.AudioFileTag filetag = 3;
inline bool CallProcessResponse::has_filetag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CallProcessResponse::set_has_filetag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CallProcessResponse::clear_has_filetag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CallProcessResponse::clear_filetag() {
  filetag_ = 0;
  clear_has_filetag();
}
inline ::PBMidLayer::AudioFileTag CallProcessResponse::filetag() const {
  return static_cast< ::PBMidLayer::AudioFileTag >(filetag_);
}
inline void CallProcessResponse::set_filetag(::PBMidLayer::AudioFileTag value) {
  assert(::PBMidLayer::AudioFileTag_IsValid(value));
  set_has_filetag();
  filetag_ = value;
}

// optional .PBMidLayer.RecognitionType recotype = 4;
inline bool CallProcessResponse::has_recotype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CallProcessResponse::set_has_recotype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CallProcessResponse::clear_has_recotype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CallProcessResponse::clear_recotype() {
  recotype_ = 0;
  clear_has_recotype();
}
inline ::PBMidLayer::RecognitionType CallProcessResponse::recotype() const {
  return static_cast< ::PBMidLayer::RecognitionType >(recotype_);
}
inline void CallProcessResponse::set_recotype(::PBMidLayer::RecognitionType value) {
  assert(::PBMidLayer::RecognitionType_IsValid(value));
  set_has_recotype();
  recotype_ = value;
}

// optional uint32 count = 5;
inline bool CallProcessResponse::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CallProcessResponse::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CallProcessResponse::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CallProcessResponse::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CallProcessResponse::count() const {
  return count_;
}
inline void CallProcessResponse::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional .PBMidLayer.PreprocessResult prelist = 6;
inline bool CallProcessResponse::has_prelist() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CallProcessResponse::set_has_prelist() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CallProcessResponse::clear_has_prelist() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CallProcessResponse::clear_prelist() {
  if (prelist_ != NULL) prelist_->::PBMidLayer::PreprocessResult::Clear();
  clear_has_prelist();
}
inline const ::PBMidLayer::PreprocessResult& CallProcessResponse::prelist() const {
  return prelist_ != NULL ? *prelist_ : *default_instance_->prelist_;
}
inline ::PBMidLayer::PreprocessResult* CallProcessResponse::mutable_prelist() {
  set_has_prelist();
  if (prelist_ == NULL) prelist_ = new ::PBMidLayer::PreprocessResult;
  return prelist_;
}
inline ::PBMidLayer::PreprocessResult* CallProcessResponse::release_prelist() {
  clear_has_prelist();
  ::PBMidLayer::PreprocessResult* temp = prelist_;
  prelist_ = NULL;
  return temp;
}
inline void CallProcessResponse::set_allocated_prelist(::PBMidLayer::PreprocessResult* prelist) {
  delete prelist_;
  prelist_ = prelist;
  if (prelist) {
    set_has_prelist();
  } else {
    clear_has_prelist();
  }
}

// optional .PBMidLayer.SpeakerResult speakerlist = 7;
inline bool CallProcessResponse::has_speakerlist() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CallProcessResponse::set_has_speakerlist() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CallProcessResponse::clear_has_speakerlist() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CallProcessResponse::clear_speakerlist() {
  if (speakerlist_ != NULL) speakerlist_->::PBMidLayer::SpeakerResult::Clear();
  clear_has_speakerlist();
}
inline const ::PBMidLayer::SpeakerResult& CallProcessResponse::speakerlist() const {
  return speakerlist_ != NULL ? *speakerlist_ : *default_instance_->speakerlist_;
}
inline ::PBMidLayer::SpeakerResult* CallProcessResponse::mutable_speakerlist() {
  set_has_speakerlist();
  if (speakerlist_ == NULL) speakerlist_ = new ::PBMidLayer::SpeakerResult;
  return speakerlist_;
}
inline ::PBMidLayer::SpeakerResult* CallProcessResponse::release_speakerlist() {
  clear_has_speakerlist();
  ::PBMidLayer::SpeakerResult* temp = speakerlist_;
  speakerlist_ = NULL;
  return temp;
}
inline void CallProcessResponse::set_allocated_speakerlist(::PBMidLayer::SpeakerResult* speakerlist) {
  delete speakerlist_;
  speakerlist_ = speakerlist;
  if (speakerlist) {
    set_has_speakerlist();
  } else {
    clear_has_speakerlist();
  }
}

// optional .PBMidLayer.KeywordResult keywordlist = 8;
inline bool CallProcessResponse::has_keywordlist() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CallProcessResponse::set_has_keywordlist() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CallProcessResponse::clear_has_keywordlist() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CallProcessResponse::clear_keywordlist() {
  if (keywordlist_ != NULL) keywordlist_->::PBMidLayer::KeywordResult::Clear();
  clear_has_keywordlist();
}
inline const ::PBMidLayer::KeywordResult& CallProcessResponse::keywordlist() const {
  return keywordlist_ != NULL ? *keywordlist_ : *default_instance_->keywordlist_;
}
inline ::PBMidLayer::KeywordResult* CallProcessResponse::mutable_keywordlist() {
  set_has_keywordlist();
  if (keywordlist_ == NULL) keywordlist_ = new ::PBMidLayer::KeywordResult;
  return keywordlist_;
}
inline ::PBMidLayer::KeywordResult* CallProcessResponse::release_keywordlist() {
  clear_has_keywordlist();
  ::PBMidLayer::KeywordResult* temp = keywordlist_;
  keywordlist_ = NULL;
  return temp;
}
inline void CallProcessResponse::set_allocated_keywordlist(::PBMidLayer::KeywordResult* keywordlist) {
  delete keywordlist_;
  keywordlist_ = keywordlist;
  if (keywordlist) {
    set_has_keywordlist();
  } else {
    clear_has_keywordlist();
  }
}

// optional .PBMidLayer.TranscriptResult translist = 9;
inline bool CallProcessResponse::has_translist() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CallProcessResponse::set_has_translist() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CallProcessResponse::clear_has_translist() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CallProcessResponse::clear_translist() {
  if (translist_ != NULL) translist_->::PBMidLayer::TranscriptResult::Clear();
  clear_has_translist();
}
inline const ::PBMidLayer::TranscriptResult& CallProcessResponse::translist() const {
  return translist_ != NULL ? *translist_ : *default_instance_->translist_;
}
inline ::PBMidLayer::TranscriptResult* CallProcessResponse::mutable_translist() {
  set_has_translist();
  if (translist_ == NULL) translist_ = new ::PBMidLayer::TranscriptResult;
  return translist_;
}
inline ::PBMidLayer::TranscriptResult* CallProcessResponse::release_translist() {
  clear_has_translist();
  ::PBMidLayer::TranscriptResult* temp = translist_;
  translist_ = NULL;
  return temp;
}
inline void CallProcessResponse::set_allocated_translist(::PBMidLayer::TranscriptResult* translist) {
  delete translist_;
  translist_ = translist;
  if (translist) {
    set_has_translist();
  } else {
    clear_has_translist();
  }
}

// optional .PBMidLayer.VADResult vad = 10;
inline bool CallProcessResponse::has_vad() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CallProcessResponse::set_has_vad() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CallProcessResponse::clear_has_vad() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CallProcessResponse::clear_vad() {
  if (vad_ != NULL) vad_->::PBMidLayer::VADResult::Clear();
  clear_has_vad();
}
inline const ::PBMidLayer::VADResult& CallProcessResponse::vad() const {
  return vad_ != NULL ? *vad_ : *default_instance_->vad_;
}
inline ::PBMidLayer::VADResult* CallProcessResponse::mutable_vad() {
  set_has_vad();
  if (vad_ == NULL) vad_ = new ::PBMidLayer::VADResult;
  return vad_;
}
inline ::PBMidLayer::VADResult* CallProcessResponse::release_vad() {
  clear_has_vad();
  ::PBMidLayer::VADResult* temp = vad_;
  vad_ = NULL;
  return temp;
}
inline void CallProcessResponse::set_allocated_vad(::PBMidLayer::VADResult* vad) {
  delete vad_;
  vad_ = vad;
  if (vad) {
    set_has_vad();
  } else {
    clear_has_vad();
  }
}

// optional .PBMidLayer.SpeechSegResult speechseg = 11;
inline bool CallProcessResponse::has_speechseg() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CallProcessResponse::set_has_speechseg() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CallProcessResponse::clear_has_speechseg() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CallProcessResponse::clear_speechseg() {
  if (speechseg_ != NULL) speechseg_->::PBMidLayer::SpeechSegResult::Clear();
  clear_has_speechseg();
}
inline const ::PBMidLayer::SpeechSegResult& CallProcessResponse::speechseg() const {
  return speechseg_ != NULL ? *speechseg_ : *default_instance_->speechseg_;
}
inline ::PBMidLayer::SpeechSegResult* CallProcessResponse::mutable_speechseg() {
  set_has_speechseg();
  if (speechseg_ == NULL) speechseg_ = new ::PBMidLayer::SpeechSegResult;
  return speechseg_;
}
inline ::PBMidLayer::SpeechSegResult* CallProcessResponse::release_speechseg() {
  clear_has_speechseg();
  ::PBMidLayer::SpeechSegResult* temp = speechseg_;
  speechseg_ = NULL;
  return temp;
}
inline void CallProcessResponse::set_allocated_speechseg(::PBMidLayer::SpeechSegResult* speechseg) {
  delete speechseg_;
  speechseg_ = speechseg;
  if (speechseg) {
    set_has_speechseg();
  } else {
    clear_has_speechseg();
  }
}

// optional .PBMidLayer.DTMFResult dtmfs = 12;
inline bool CallProcessResponse::has_dtmfs() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CallProcessResponse::set_has_dtmfs() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CallProcessResponse::clear_has_dtmfs() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CallProcessResponse::clear_dtmfs() {
  if (dtmfs_ != NULL) dtmfs_->::PBMidLayer::DTMFResult::Clear();
  clear_has_dtmfs();
}
inline const ::PBMidLayer::DTMFResult& CallProcessResponse::dtmfs() const {
  return dtmfs_ != NULL ? *dtmfs_ : *default_instance_->dtmfs_;
}
inline ::PBMidLayer::DTMFResult* CallProcessResponse::mutable_dtmfs() {
  set_has_dtmfs();
  if (dtmfs_ == NULL) dtmfs_ = new ::PBMidLayer::DTMFResult;
  return dtmfs_;
}
inline ::PBMidLayer::DTMFResult* CallProcessResponse::release_dtmfs() {
  clear_has_dtmfs();
  ::PBMidLayer::DTMFResult* temp = dtmfs_;
  dtmfs_ = NULL;
  return temp;
}
inline void CallProcessResponse::set_allocated_dtmfs(::PBMidLayer::DTMFResult* dtmfs) {
  delete dtmfs_;
  dtmfs_ = dtmfs;
  if (dtmfs) {
    set_has_dtmfs();
  } else {
    clear_has_dtmfs();
  }
}

// optional uint32 resultflag = 13 [default = 7];
inline bool CallProcessResponse::has_resultflag() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CallProcessResponse::set_has_resultflag() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CallProcessResponse::clear_has_resultflag() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CallProcessResponse::clear_resultflag() {
  resultflag_ = 7u;
  clear_has_resultflag();
}
inline ::google::protobuf::uint32 CallProcessResponse::resultflag() const {
  return resultflag_;
}
inline void CallProcessResponse::set_resultflag(::google::protobuf::uint32 value) {
  set_has_resultflag();
  resultflag_ = value;
}

// optional uint64 starttime = 14;
inline bool CallProcessResponse::has_starttime() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CallProcessResponse::set_has_starttime() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CallProcessResponse::clear_has_starttime() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CallProcessResponse::clear_starttime() {
  starttime_ = GOOGLE_ULONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::uint64 CallProcessResponse::starttime() const {
  return starttime_;
}
inline void CallProcessResponse::set_starttime(::google::protobuf::uint64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional .PBMidLayer.SystemCode syscode = 15;
inline bool CallProcessResponse::has_syscode() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CallProcessResponse::set_has_syscode() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CallProcessResponse::clear_has_syscode() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CallProcessResponse::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& CallProcessResponse::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* CallProcessResponse::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* CallProcessResponse::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void CallProcessResponse::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// HistorySearchRequest

// required string taskid = 1;
inline bool HistorySearchRequest::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistorySearchRequest::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistorySearchRequest::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistorySearchRequest::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& HistorySearchRequest::taskid() const {
  return *taskid_;
}
inline void HistorySearchRequest::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void HistorySearchRequest::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void HistorySearchRequest::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistorySearchRequest::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* HistorySearchRequest::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistorySearchRequest::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 packageseq = 2;
inline bool HistorySearchRequest::has_packageseq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistorySearchRequest::set_has_packageseq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistorySearchRequest::clear_has_packageseq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistorySearchRequest::clear_packageseq() {
  packageseq_ = 0;
  clear_has_packageseq();
}
inline ::google::protobuf::int32 HistorySearchRequest::packageseq() const {
  return packageseq_;
}
inline void HistorySearchRequest::set_packageseq(::google::protobuf::int32 value) {
  set_has_packageseq();
  packageseq_ = value;
}

// required int32 endflag = 3;
inline bool HistorySearchRequest::has_endflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistorySearchRequest::set_has_endflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistorySearchRequest::clear_has_endflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistorySearchRequest::clear_endflag() {
  endflag_ = 0;
  clear_has_endflag();
}
inline ::google::protobuf::int32 HistorySearchRequest::endflag() const {
  return endflag_;
}
inline void HistorySearchRequest::set_endflag(::google::protobuf::int32 value) {
  set_has_endflag();
  endflag_ = value;
}

// required int32 records = 4;
inline bool HistorySearchRequest::has_records() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistorySearchRequest::set_has_records() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistorySearchRequest::clear_has_records() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistorySearchRequest::clear_records() {
  records_ = 0;
  clear_has_records();
}
inline ::google::protobuf::int32 HistorySearchRequest::records() const {
  return records_;
}
inline void HistorySearchRequest::set_records(::google::protobuf::int32 value) {
  set_has_records();
  records_ = value;
}

// optional .PBMidLayer.TaskAttribute attribute = 5;
inline bool HistorySearchRequest::has_attribute() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistorySearchRequest::set_has_attribute() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistorySearchRequest::clear_has_attribute() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistorySearchRequest::clear_attribute() {
  if (attribute_ != NULL) attribute_->::PBMidLayer::TaskAttribute::Clear();
  clear_has_attribute();
}
inline const ::PBMidLayer::TaskAttribute& HistorySearchRequest::attribute() const {
  return attribute_ != NULL ? *attribute_ : *default_instance_->attribute_;
}
inline ::PBMidLayer::TaskAttribute* HistorySearchRequest::mutable_attribute() {
  set_has_attribute();
  if (attribute_ == NULL) attribute_ = new ::PBMidLayer::TaskAttribute;
  return attribute_;
}
inline ::PBMidLayer::TaskAttribute* HistorySearchRequest::release_attribute() {
  clear_has_attribute();
  ::PBMidLayer::TaskAttribute* temp = attribute_;
  attribute_ = NULL;
  return temp;
}
inline void HistorySearchRequest::set_allocated_attribute(::PBMidLayer::TaskAttribute* attribute) {
  delete attribute_;
  attribute_ = attribute;
  if (attribute) {
    set_has_attribute();
  } else {
    clear_has_attribute();
  }
}

// repeated string calllist = 6;
inline int HistorySearchRequest::calllist_size() const {
  return calllist_.size();
}
inline void HistorySearchRequest::clear_calllist() {
  calllist_.Clear();
}
inline const ::std::string& HistorySearchRequest::calllist(int index) const {
  return calllist_.Get(index);
}
inline ::std::string* HistorySearchRequest::mutable_calllist(int index) {
  return calllist_.Mutable(index);
}
inline void HistorySearchRequest::set_calllist(int index, const ::std::string& value) {
  calllist_.Mutable(index)->assign(value);
}
inline void HistorySearchRequest::set_calllist(int index, const char* value) {
  calllist_.Mutable(index)->assign(value);
}
inline void HistorySearchRequest::set_calllist(int index, const char* value, size_t size) {
  calllist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistorySearchRequest::add_calllist() {
  return calllist_.Add();
}
inline void HistorySearchRequest::add_calllist(const ::std::string& value) {
  calllist_.Add()->assign(value);
}
inline void HistorySearchRequest::add_calllist(const char* value) {
  calllist_.Add()->assign(value);
}
inline void HistorySearchRequest::add_calllist(const char* value, size_t size) {
  calllist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HistorySearchRequest::calllist() const {
  return calllist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HistorySearchRequest::mutable_calllist() {
  return &calllist_;
}

// optional .PBMidLayer.SystemCode syscode = 7;
inline bool HistorySearchRequest::has_syscode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HistorySearchRequest::set_has_syscode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HistorySearchRequest::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HistorySearchRequest::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& HistorySearchRequest::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* HistorySearchRequest::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* HistorySearchRequest::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void HistorySearchRequest::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// TaskAttribute

// required uint32 total = 1;
inline bool TaskAttribute::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskAttribute::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskAttribute::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskAttribute::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 TaskAttribute::total() const {
  return total_;
}
inline void TaskAttribute::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// required .PBMidLayer.PriorityType priority = 2;
inline bool TaskAttribute::has_priority() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskAttribute::set_has_priority() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskAttribute::clear_has_priority() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskAttribute::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::PBMidLayer::PriorityType TaskAttribute::priority() const {
  return static_cast< ::PBMidLayer::PriorityType >(priority_);
}
inline void TaskAttribute::set_priority(::PBMidLayer::PriorityType value) {
  assert(::PBMidLayer::PriorityType_IsValid(value));
  set_has_priority();
  priority_ = value;
}

// required .PBMidLayer.SearchCondition condition = 3;
inline bool TaskAttribute::has_condition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskAttribute::set_has_condition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskAttribute::clear_has_condition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskAttribute::clear_condition() {
  condition_ = 0;
  clear_has_condition();
}
inline ::PBMidLayer::SearchCondition TaskAttribute::condition() const {
  return static_cast< ::PBMidLayer::SearchCondition >(condition_);
}
inline void TaskAttribute::set_condition(::PBMidLayer::SearchCondition value) {
  assert(::PBMidLayer::SearchCondition_IsValid(value));
  set_has_condition();
  condition_ = value;
}

// repeated string objectids = 4;
inline int TaskAttribute::objectids_size() const {
  return objectids_.size();
}
inline void TaskAttribute::clear_objectids() {
  objectids_.Clear();
}
inline const ::std::string& TaskAttribute::objectids(int index) const {
  return objectids_.Get(index);
}
inline ::std::string* TaskAttribute::mutable_objectids(int index) {
  return objectids_.Mutable(index);
}
inline void TaskAttribute::set_objectids(int index, const ::std::string& value) {
  objectids_.Mutable(index)->assign(value);
}
inline void TaskAttribute::set_objectids(int index, const char* value) {
  objectids_.Mutable(index)->assign(value);
}
inline void TaskAttribute::set_objectids(int index, const char* value, size_t size) {
  objectids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskAttribute::add_objectids() {
  return objectids_.Add();
}
inline void TaskAttribute::add_objectids(const ::std::string& value) {
  objectids_.Add()->assign(value);
}
inline void TaskAttribute::add_objectids(const char* value) {
  objectids_.Add()->assign(value);
}
inline void TaskAttribute::add_objectids(const char* value, size_t size) {
  objectids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TaskAttribute::objectids() const {
  return objectids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TaskAttribute::mutable_objectids() {
  return &objectids_;
}

// optional string languagename = 5;
inline bool TaskAttribute::has_languagename() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskAttribute::set_has_languagename() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskAttribute::clear_has_languagename() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskAttribute::clear_languagename() {
  if (languagename_ != &::google::protobuf::internal::kEmptyString) {
    languagename_->clear();
  }
  clear_has_languagename();
}
inline const ::std::string& TaskAttribute::languagename() const {
  return *languagename_;
}
inline void TaskAttribute::set_languagename(const ::std::string& value) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(value);
}
inline void TaskAttribute::set_languagename(const char* value) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(value);
}
inline void TaskAttribute::set_languagename(const char* value, size_t size) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskAttribute::mutable_languagename() {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  return languagename_;
}
inline ::std::string* TaskAttribute::release_languagename() {
  clear_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = languagename_;
    languagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskAttribute::set_allocated_languagename(::std::string* languagename) {
  if (languagename_ != &::google::protobuf::internal::kEmptyString) {
    delete languagename_;
  }
  if (languagename) {
    set_has_languagename();
    languagename_ = languagename;
  } else {
    clear_has_languagename();
    languagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string keywords = 6;
inline int TaskAttribute::keywords_size() const {
  return keywords_.size();
}
inline void TaskAttribute::clear_keywords() {
  keywords_.Clear();
}
inline const ::std::string& TaskAttribute::keywords(int index) const {
  return keywords_.Get(index);
}
inline ::std::string* TaskAttribute::mutable_keywords(int index) {
  return keywords_.Mutable(index);
}
inline void TaskAttribute::set_keywords(int index, const ::std::string& value) {
  keywords_.Mutable(index)->assign(value);
}
inline void TaskAttribute::set_keywords(int index, const char* value) {
  keywords_.Mutable(index)->assign(value);
}
inline void TaskAttribute::set_keywords(int index, const char* value, size_t size) {
  keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskAttribute::add_keywords() {
  return keywords_.Add();
}
inline void TaskAttribute::add_keywords(const ::std::string& value) {
  keywords_.Add()->assign(value);
}
inline void TaskAttribute::add_keywords(const char* value) {
  keywords_.Add()->assign(value);
}
inline void TaskAttribute::add_keywords(const char* value, size_t size) {
  keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TaskAttribute::keywords() const {
  return keywords_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TaskAttribute::mutable_keywords() {
  return &keywords_;
}

// optional bytes voice = 7;
inline bool TaskAttribute::has_voice() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TaskAttribute::set_has_voice() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TaskAttribute::clear_has_voice() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TaskAttribute::clear_voice() {
  if (voice_ != &::google::protobuf::internal::kEmptyString) {
    voice_->clear();
  }
  clear_has_voice();
}
inline const ::std::string& TaskAttribute::voice() const {
  return *voice_;
}
inline void TaskAttribute::set_voice(const ::std::string& value) {
  set_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    voice_ = new ::std::string;
  }
  voice_->assign(value);
}
inline void TaskAttribute::set_voice(const char* value) {
  set_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    voice_ = new ::std::string;
  }
  voice_->assign(value);
}
inline void TaskAttribute::set_voice(const void* value, size_t size) {
  set_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    voice_ = new ::std::string;
  }
  voice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskAttribute::mutable_voice() {
  set_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    voice_ = new ::std::string;
  }
  return voice_;
}
inline ::std::string* TaskAttribute::release_voice() {
  clear_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = voice_;
    voice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskAttribute::set_allocated_voice(::std::string* voice) {
  if (voice_ != &::google::protobuf::internal::kEmptyString) {
    delete voice_;
  }
  if (voice) {
    set_has_voice();
    voice_ = voice;
  } else {
    clear_has_voice();
    voice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HistorySearchResponse

// required string taskid = 1;
inline bool HistorySearchResponse::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistorySearchResponse::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistorySearchResponse::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistorySearchResponse::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& HistorySearchResponse::taskid() const {
  return *taskid_;
}
inline void HistorySearchResponse::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void HistorySearchResponse::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void HistorySearchResponse::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistorySearchResponse::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* HistorySearchResponse::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistorySearchResponse::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.OperationStatus status = 2;
inline bool HistorySearchResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistorySearchResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistorySearchResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistorySearchResponse::clear_status() {
  if (status_ != NULL) status_->::PBMidLayer::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBMidLayer::OperationStatus& HistorySearchResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBMidLayer::OperationStatus* HistorySearchResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBMidLayer::OperationStatus;
  return status_;
}
inline ::PBMidLayer::OperationStatus* HistorySearchResponse::release_status() {
  clear_has_status();
  ::PBMidLayer::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void HistorySearchResponse::set_allocated_status(::PBMidLayer::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// required .PBMidLayer.SearchCondition condition = 3;
inline bool HistorySearchResponse::has_condition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistorySearchResponse::set_has_condition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistorySearchResponse::clear_has_condition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistorySearchResponse::clear_condition() {
  condition_ = 0;
  clear_has_condition();
}
inline ::PBMidLayer::SearchCondition HistorySearchResponse::condition() const {
  return static_cast< ::PBMidLayer::SearchCondition >(condition_);
}
inline void HistorySearchResponse::set_condition(::PBMidLayer::SearchCondition value) {
  assert(::PBMidLayer::SearchCondition_IsValid(value));
  set_has_condition();
  condition_ = value;
}

// required uint32 count = 4;
inline bool HistorySearchResponse::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistorySearchResponse::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistorySearchResponse::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistorySearchResponse::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 HistorySearchResponse::count() const {
  return count_;
}
inline void HistorySearchResponse::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional .PBMidLayer.SystemCode syscode = 5;
inline bool HistorySearchResponse::has_syscode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistorySearchResponse::set_has_syscode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistorySearchResponse::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistorySearchResponse::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& HistorySearchResponse::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* HistorySearchResponse::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* HistorySearchResponse::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void HistorySearchResponse::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// HistoryTransRequest

// required string taskid = 1;
inline bool HistoryTransRequest::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryTransRequest::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryTransRequest::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryTransRequest::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& HistoryTransRequest::taskid() const {
  return *taskid_;
}
inline void HistoryTransRequest::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void HistoryTransRequest::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void HistoryTransRequest::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryTransRequest::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* HistoryTransRequest::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryTransRequest::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.SearchCondition condition = 2;
inline bool HistoryTransRequest::has_condition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoryTransRequest::set_has_condition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoryTransRequest::clear_has_condition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoryTransRequest::clear_condition() {
  condition_ = 0;
  clear_has_condition();
}
inline ::PBMidLayer::SearchCondition HistoryTransRequest::condition() const {
  return static_cast< ::PBMidLayer::SearchCondition >(condition_);
}
inline void HistoryTransRequest::set_condition(::PBMidLayer::SearchCondition value) {
  assert(::PBMidLayer::SearchCondition_IsValid(value));
  set_has_condition();
  condition_ = value;
}

// required uint32 begin = 3;
inline bool HistoryTransRequest::has_begin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoryTransRequest::set_has_begin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoryTransRequest::clear_has_begin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoryTransRequest::clear_begin() {
  begin_ = 0u;
  clear_has_begin();
}
inline ::google::protobuf::uint32 HistoryTransRequest::begin() const {
  return begin_;
}
inline void HistoryTransRequest::set_begin(::google::protobuf::uint32 value) {
  set_has_begin();
  begin_ = value;
}

// required uint32 end = 4;
inline bool HistoryTransRequest::has_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoryTransRequest::set_has_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoryTransRequest::clear_has_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoryTransRequest::clear_end() {
  end_ = 0u;
  clear_has_end();
}
inline ::google::protobuf::uint32 HistoryTransRequest::end() const {
  return end_;
}
inline void HistoryTransRequest::set_end(::google::protobuf::uint32 value) {
  set_has_end();
  end_ = value;
}

// optional .PBMidLayer.SystemCode syscode = 5;
inline bool HistoryTransRequest::has_syscode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoryTransRequest::set_has_syscode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoryTransRequest::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoryTransRequest::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& HistoryTransRequest::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* HistoryTransRequest::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* HistoryTransRequest::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void HistoryTransRequest::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// HistoryTransResponse

// required string taskid = 1;
inline bool HistoryTransResponse::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryTransResponse::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryTransResponse::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryTransResponse::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& HistoryTransResponse::taskid() const {
  return *taskid_;
}
inline void HistoryTransResponse::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void HistoryTransResponse::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void HistoryTransResponse::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryTransResponse::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* HistoryTransResponse::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryTransResponse::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.OperationStatus status = 2;
inline bool HistoryTransResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoryTransResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoryTransResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoryTransResponse::clear_status() {
  if (status_ != NULL) status_->::PBMidLayer::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBMidLayer::OperationStatus& HistoryTransResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBMidLayer::OperationStatus* HistoryTransResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBMidLayer::OperationStatus;
  return status_;
}
inline ::PBMidLayer::OperationStatus* HistoryTransResponse::release_status() {
  clear_has_status();
  ::PBMidLayer::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void HistoryTransResponse::set_allocated_status(::PBMidLayer::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// required uint32 count = 3;
inline bool HistoryTransResponse::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoryTransResponse::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoryTransResponse::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoryTransResponse::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 HistoryTransResponse::count() const {
  return count_;
}
inline void HistoryTransResponse::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .PBMidLayer.PreprocessResult prelist = 4;
inline int HistoryTransResponse::prelist_size() const {
  return prelist_.size();
}
inline void HistoryTransResponse::clear_prelist() {
  prelist_.Clear();
}
inline const ::PBMidLayer::PreprocessResult& HistoryTransResponse::prelist(int index) const {
  return prelist_.Get(index);
}
inline ::PBMidLayer::PreprocessResult* HistoryTransResponse::mutable_prelist(int index) {
  return prelist_.Mutable(index);
}
inline ::PBMidLayer::PreprocessResult* HistoryTransResponse::add_prelist() {
  return prelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PreprocessResult >&
HistoryTransResponse::prelist() const {
  return prelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PreprocessResult >*
HistoryTransResponse::mutable_prelist() {
  return &prelist_;
}

// repeated .PBMidLayer.SpeakerResult speakerlist = 5;
inline int HistoryTransResponse::speakerlist_size() const {
  return speakerlist_.size();
}
inline void HistoryTransResponse::clear_speakerlist() {
  speakerlist_.Clear();
}
inline const ::PBMidLayer::SpeakerResult& HistoryTransResponse::speakerlist(int index) const {
  return speakerlist_.Get(index);
}
inline ::PBMidLayer::SpeakerResult* HistoryTransResponse::mutable_speakerlist(int index) {
  return speakerlist_.Mutable(index);
}
inline ::PBMidLayer::SpeakerResult* HistoryTransResponse::add_speakerlist() {
  return speakerlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerResult >&
HistoryTransResponse::speakerlist() const {
  return speakerlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerResult >*
HistoryTransResponse::mutable_speakerlist() {
  return &speakerlist_;
}

// repeated .PBMidLayer.KeywordResult keywordlist = 6;
inline int HistoryTransResponse::keywordlist_size() const {
  return keywordlist_.size();
}
inline void HistoryTransResponse::clear_keywordlist() {
  keywordlist_.Clear();
}
inline const ::PBMidLayer::KeywordResult& HistoryTransResponse::keywordlist(int index) const {
  return keywordlist_.Get(index);
}
inline ::PBMidLayer::KeywordResult* HistoryTransResponse::mutable_keywordlist(int index) {
  return keywordlist_.Mutable(index);
}
inline ::PBMidLayer::KeywordResult* HistoryTransResponse::add_keywordlist() {
  return keywordlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordResult >&
HistoryTransResponse::keywordlist() const {
  return keywordlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordResult >*
HistoryTransResponse::mutable_keywordlist() {
  return &keywordlist_;
}

// repeated .PBMidLayer.TranscriptResult translist = 7;
inline int HistoryTransResponse::translist_size() const {
  return translist_.size();
}
inline void HistoryTransResponse::clear_translist() {
  translist_.Clear();
}
inline const ::PBMidLayer::TranscriptResult& HistoryTransResponse::translist(int index) const {
  return translist_.Get(index);
}
inline ::PBMidLayer::TranscriptResult* HistoryTransResponse::mutable_translist(int index) {
  return translist_.Mutable(index);
}
inline ::PBMidLayer::TranscriptResult* HistoryTransResponse::add_translist() {
  return translist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::TranscriptResult >&
HistoryTransResponse::translist() const {
  return translist_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::TranscriptResult >*
HistoryTransResponse::mutable_translist() {
  return &translist_;
}

// repeated .PBMidLayer.VADResult vad = 8;
inline int HistoryTransResponse::vad_size() const {
  return vad_.size();
}
inline void HistoryTransResponse::clear_vad() {
  vad_.Clear();
}
inline const ::PBMidLayer::VADResult& HistoryTransResponse::vad(int index) const {
  return vad_.Get(index);
}
inline ::PBMidLayer::VADResult* HistoryTransResponse::mutable_vad(int index) {
  return vad_.Mutable(index);
}
inline ::PBMidLayer::VADResult* HistoryTransResponse::add_vad() {
  return vad_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::VADResult >&
HistoryTransResponse::vad() const {
  return vad_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::VADResult >*
HistoryTransResponse::mutable_vad() {
  return &vad_;
}

// repeated .PBMidLayer.SpeechSegResult speechseg = 9;
inline int HistoryTransResponse::speechseg_size() const {
  return speechseg_.size();
}
inline void HistoryTransResponse::clear_speechseg() {
  speechseg_.Clear();
}
inline const ::PBMidLayer::SpeechSegResult& HistoryTransResponse::speechseg(int index) const {
  return speechseg_.Get(index);
}
inline ::PBMidLayer::SpeechSegResult* HistoryTransResponse::mutable_speechseg(int index) {
  return speechseg_.Mutable(index);
}
inline ::PBMidLayer::SpeechSegResult* HistoryTransResponse::add_speechseg() {
  return speechseg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegResult >&
HistoryTransResponse::speechseg() const {
  return speechseg_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegResult >*
HistoryTransResponse::mutable_speechseg() {
  return &speechseg_;
}

// repeated .PBMidLayer.DTMFResult dtmfs = 10;
inline int HistoryTransResponse::dtmfs_size() const {
  return dtmfs_.size();
}
inline void HistoryTransResponse::clear_dtmfs() {
  dtmfs_.Clear();
}
inline const ::PBMidLayer::DTMFResult& HistoryTransResponse::dtmfs(int index) const {
  return dtmfs_.Get(index);
}
inline ::PBMidLayer::DTMFResult* HistoryTransResponse::mutable_dtmfs(int index) {
  return dtmfs_.Mutable(index);
}
inline ::PBMidLayer::DTMFResult* HistoryTransResponse::add_dtmfs() {
  return dtmfs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::DTMFResult >&
HistoryTransResponse::dtmfs() const {
  return dtmfs_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::DTMFResult >*
HistoryTransResponse::mutable_dtmfs() {
  return &dtmfs_;
}

// optional .PBMidLayer.SystemCode syscode = 11;
inline bool HistoryTransResponse::has_syscode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HistoryTransResponse::set_has_syscode() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HistoryTransResponse::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HistoryTransResponse::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& HistoryTransResponse::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* HistoryTransResponse::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* HistoryTransResponse::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void HistoryTransResponse::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// FileLocationNotify

// required string callid = 1;
inline bool FileLocationNotify::has_callid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileLocationNotify::set_has_callid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileLocationNotify::clear_has_callid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileLocationNotify::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& FileLocationNotify::callid() const {
  return *callid_;
}
inline void FileLocationNotify::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void FileLocationNotify::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void FileLocationNotify::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileLocationNotify::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* FileLocationNotify::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileLocationNotify::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.AudioFileTag filetag = 2;
inline bool FileLocationNotify::has_filetag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileLocationNotify::set_has_filetag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileLocationNotify::clear_has_filetag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileLocationNotify::clear_filetag() {
  filetag_ = 0;
  clear_has_filetag();
}
inline ::PBMidLayer::AudioFileTag FileLocationNotify::filetag() const {
  return static_cast< ::PBMidLayer::AudioFileTag >(filetag_);
}
inline void FileLocationNotify::set_filetag(::PBMidLayer::AudioFileTag value) {
  assert(::PBMidLayer::AudioFileTag_IsValid(value));
  set_has_filetag();
  filetag_ = value;
}

// required string path = 3;
inline bool FileLocationNotify::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileLocationNotify::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileLocationNotify::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileLocationNotify::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& FileLocationNotify::path() const {
  return *path_;
}
inline void FileLocationNotify::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FileLocationNotify::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FileLocationNotify::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileLocationNotify::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* FileLocationNotify::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileLocationNotify::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.AudioEncodingTag code = 4;
inline bool FileLocationNotify::has_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileLocationNotify::set_has_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileLocationNotify::clear_has_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileLocationNotify::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::PBMidLayer::AudioEncodingTag FileLocationNotify::code() const {
  return static_cast< ::PBMidLayer::AudioEncodingTag >(code_);
}
inline void FileLocationNotify::set_code(::PBMidLayer::AudioEncodingTag value) {
  assert(::PBMidLayer::AudioEncodingTag_IsValid(value));
  set_has_code();
  code_ = value;
}

// optional .PBMidLayer.SystemCode syscode = 5;
inline bool FileLocationNotify::has_syscode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileLocationNotify::set_has_syscode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileLocationNotify::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileLocationNotify::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& FileLocationNotify::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* FileLocationNotify::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* FileLocationNotify::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void FileLocationNotify::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// TargetQueryRequest

// required string taskid = 1;
inline bool TargetQueryRequest::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetQueryRequest::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetQueryRequest::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetQueryRequest::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& TargetQueryRequest::taskid() const {
  return *taskid_;
}
inline void TargetQueryRequest::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void TargetQueryRequest::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void TargetQueryRequest::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetQueryRequest::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* TargetQueryRequest::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TargetQueryRequest::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string target = 2;
inline bool TargetQueryRequest::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetQueryRequest::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TargetQueryRequest::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TargetQueryRequest::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& TargetQueryRequest::target() const {
  return *target_;
}
inline void TargetQueryRequest::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void TargetQueryRequest::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void TargetQueryRequest::set_target(const char* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetQueryRequest::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* TargetQueryRequest::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TargetQueryRequest::set_allocated_target(::std::string* target) {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (target) {
    set_has_target();
    target_ = target;
  } else {
    clear_has_target();
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 starttime = 3;
inline bool TargetQueryRequest::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TargetQueryRequest::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TargetQueryRequest::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TargetQueryRequest::clear_starttime() {
  starttime_ = GOOGLE_ULONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::uint64 TargetQueryRequest::starttime() const {
  return starttime_;
}
inline void TargetQueryRequest::set_starttime(::google::protobuf::uint64 value) {
  set_has_starttime();
  starttime_ = value;
}

// required uint64 endtime = 4;
inline bool TargetQueryRequest::has_endtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TargetQueryRequest::set_has_endtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TargetQueryRequest::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TargetQueryRequest::clear_endtime() {
  endtime_ = GOOGLE_ULONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::uint64 TargetQueryRequest::endtime() const {
  return endtime_;
}
inline void TargetQueryRequest::set_endtime(::google::protobuf::uint64 value) {
  set_has_endtime();
  endtime_ = value;
}

// optional .PBMidLayer.SystemCode syscode = 5;
inline bool TargetQueryRequest::has_syscode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TargetQueryRequest::set_has_syscode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TargetQueryRequest::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TargetQueryRequest::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& TargetQueryRequest::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* TargetQueryRequest::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* TargetQueryRequest::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void TargetQueryRequest::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// TargetQueryResponse

// required string taskid = 1;
inline bool TargetQueryResponse::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetQueryResponse::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetQueryResponse::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetQueryResponse::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& TargetQueryResponse::taskid() const {
  return *taskid_;
}
inline void TargetQueryResponse::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void TargetQueryResponse::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void TargetQueryResponse::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetQueryResponse::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* TargetQueryResponse::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TargetQueryResponse::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.OperationStatus status = 2;
inline bool TargetQueryResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetQueryResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TargetQueryResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TargetQueryResponse::clear_status() {
  if (status_ != NULL) status_->::PBMidLayer::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBMidLayer::OperationStatus& TargetQueryResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBMidLayer::OperationStatus* TargetQueryResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBMidLayer::OperationStatus;
  return status_;
}
inline ::PBMidLayer::OperationStatus* TargetQueryResponse::release_status() {
  clear_has_status();
  ::PBMidLayer::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void TargetQueryResponse::set_allocated_status(::PBMidLayer::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// optional int32 packageseq = 3;
inline bool TargetQueryResponse::has_packageseq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TargetQueryResponse::set_has_packageseq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TargetQueryResponse::clear_has_packageseq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TargetQueryResponse::clear_packageseq() {
  packageseq_ = 0;
  clear_has_packageseq();
}
inline ::google::protobuf::int32 TargetQueryResponse::packageseq() const {
  return packageseq_;
}
inline void TargetQueryResponse::set_packageseq(::google::protobuf::int32 value) {
  set_has_packageseq();
  packageseq_ = value;
}

// optional int32 endflag = 4;
inline bool TargetQueryResponse::has_endflag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TargetQueryResponse::set_has_endflag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TargetQueryResponse::clear_has_endflag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TargetQueryResponse::clear_endflag() {
  endflag_ = 0;
  clear_has_endflag();
}
inline ::google::protobuf::int32 TargetQueryResponse::endflag() const {
  return endflag_;
}
inline void TargetQueryResponse::set_endflag(::google::protobuf::int32 value) {
  set_has_endflag();
  endflag_ = value;
}

// optional int32 records = 5;
inline bool TargetQueryResponse::has_records() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TargetQueryResponse::set_has_records() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TargetQueryResponse::clear_has_records() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TargetQueryResponse::clear_records() {
  records_ = 0;
  clear_has_records();
}
inline ::google::protobuf::int32 TargetQueryResponse::records() const {
  return records_;
}
inline void TargetQueryResponse::set_records(::google::protobuf::int32 value) {
  set_has_records();
  records_ = value;
}

// repeated string calllist = 6;
inline int TargetQueryResponse::calllist_size() const {
  return calllist_.size();
}
inline void TargetQueryResponse::clear_calllist() {
  calllist_.Clear();
}
inline const ::std::string& TargetQueryResponse::calllist(int index) const {
  return calllist_.Get(index);
}
inline ::std::string* TargetQueryResponse::mutable_calllist(int index) {
  return calllist_.Mutable(index);
}
inline void TargetQueryResponse::set_calllist(int index, const ::std::string& value) {
  calllist_.Mutable(index)->assign(value);
}
inline void TargetQueryResponse::set_calllist(int index, const char* value) {
  calllist_.Mutable(index)->assign(value);
}
inline void TargetQueryResponse::set_calllist(int index, const char* value, size_t size) {
  calllist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetQueryResponse::add_calllist() {
  return calllist_.Add();
}
inline void TargetQueryResponse::add_calllist(const ::std::string& value) {
  calllist_.Add()->assign(value);
}
inline void TargetQueryResponse::add_calllist(const char* value) {
  calllist_.Add()->assign(value);
}
inline void TargetQueryResponse::add_calllist(const char* value, size_t size) {
  calllist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TargetQueryResponse::calllist() const {
  return calllist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TargetQueryResponse::mutable_calllist() {
  return &calllist_;
}

// optional .PBMidLayer.SystemCode syscode = 7;
inline bool TargetQueryResponse::has_syscode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TargetQueryResponse::set_has_syscode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TargetQueryResponse::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TargetQueryResponse::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& TargetQueryResponse::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* TargetQueryResponse::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* TargetQueryResponse::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void TargetQueryResponse::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// SetRuleRequest

// required .PBMidLayer.OperationType opertype = 1;
inline bool SetRuleRequest::has_opertype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetRuleRequest::set_has_opertype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetRuleRequest::clear_has_opertype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetRuleRequest::clear_opertype() {
  opertype_ = 0;
  clear_has_opertype();
}
inline ::PBMidLayer::OperationType SetRuleRequest::opertype() const {
  return static_cast< ::PBMidLayer::OperationType >(opertype_);
}
inline void SetRuleRequest::set_opertype(::PBMidLayer::OperationType value) {
  assert(::PBMidLayer::OperationType_IsValid(value));
  set_has_opertype();
  opertype_ = value;
}

// required .PBMidLayer.RuleType operation = 2;
inline bool SetRuleRequest::has_operation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetRuleRequest::set_has_operation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetRuleRequest::clear_has_operation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetRuleRequest::clear_operation() {
  operation_ = 0;
  clear_has_operation();
}
inline ::PBMidLayer::RuleType SetRuleRequest::operation() const {
  return static_cast< ::PBMidLayer::RuleType >(operation_);
}
inline void SetRuleRequest::set_operation(::PBMidLayer::RuleType value) {
  assert(::PBMidLayer::RuleType_IsValid(value));
  set_has_operation();
  operation_ = value;
}

// optional .PBMidLayer.SpeakerRule speaker = 3;
inline bool SetRuleRequest::has_speaker() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetRuleRequest::set_has_speaker() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetRuleRequest::clear_has_speaker() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetRuleRequest::clear_speaker() {
  if (speaker_ != NULL) speaker_->::PBMidLayer::SpeakerRule::Clear();
  clear_has_speaker();
}
inline const ::PBMidLayer::SpeakerRule& SetRuleRequest::speaker() const {
  return speaker_ != NULL ? *speaker_ : *default_instance_->speaker_;
}
inline ::PBMidLayer::SpeakerRule* SetRuleRequest::mutable_speaker() {
  set_has_speaker();
  if (speaker_ == NULL) speaker_ = new ::PBMidLayer::SpeakerRule;
  return speaker_;
}
inline ::PBMidLayer::SpeakerRule* SetRuleRequest::release_speaker() {
  clear_has_speaker();
  ::PBMidLayer::SpeakerRule* temp = speaker_;
  speaker_ = NULL;
  return temp;
}
inline void SetRuleRequest::set_allocated_speaker(::PBMidLayer::SpeakerRule* speaker) {
  delete speaker_;
  speaker_ = speaker;
  if (speaker) {
    set_has_speaker();
  } else {
    clear_has_speaker();
  }
}

// optional .PBMidLayer.KeywordRule keyword = 4;
inline bool SetRuleRequest::has_keyword() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetRuleRequest::set_has_keyword() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetRuleRequest::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetRuleRequest::clear_keyword() {
  if (keyword_ != NULL) keyword_->::PBMidLayer::KeywordRule::Clear();
  clear_has_keyword();
}
inline const ::PBMidLayer::KeywordRule& SetRuleRequest::keyword() const {
  return keyword_ != NULL ? *keyword_ : *default_instance_->keyword_;
}
inline ::PBMidLayer::KeywordRule* SetRuleRequest::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == NULL) keyword_ = new ::PBMidLayer::KeywordRule;
  return keyword_;
}
inline ::PBMidLayer::KeywordRule* SetRuleRequest::release_keyword() {
  clear_has_keyword();
  ::PBMidLayer::KeywordRule* temp = keyword_;
  keyword_ = NULL;
  return temp;
}
inline void SetRuleRequest::set_allocated_keyword(::PBMidLayer::KeywordRule* keyword) {
  delete keyword_;
  keyword_ = keyword;
  if (keyword) {
    set_has_keyword();
  } else {
    clear_has_keyword();
  }
}

// optional .PBMidLayer.SpeechSegRule speechseg = 5;
inline bool SetRuleRequest::has_speechseg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SetRuleRequest::set_has_speechseg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SetRuleRequest::clear_has_speechseg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SetRuleRequest::clear_speechseg() {
  if (speechseg_ != NULL) speechseg_->::PBMidLayer::SpeechSegRule::Clear();
  clear_has_speechseg();
}
inline const ::PBMidLayer::SpeechSegRule& SetRuleRequest::speechseg() const {
  return speechseg_ != NULL ? *speechseg_ : *default_instance_->speechseg_;
}
inline ::PBMidLayer::SpeechSegRule* SetRuleRequest::mutable_speechseg() {
  set_has_speechseg();
  if (speechseg_ == NULL) speechseg_ = new ::PBMidLayer::SpeechSegRule;
  return speechseg_;
}
inline ::PBMidLayer::SpeechSegRule* SetRuleRequest::release_speechseg() {
  clear_has_speechseg();
  ::PBMidLayer::SpeechSegRule* temp = speechseg_;
  speechseg_ = NULL;
  return temp;
}
inline void SetRuleRequest::set_allocated_speechseg(::PBMidLayer::SpeechSegRule* speechseg) {
  delete speechseg_;
  speechseg_ = speechseg;
  if (speechseg) {
    set_has_speechseg();
  } else {
    clear_has_speechseg();
  }
}

// optional .PBMidLayer.SystemCode syscode = 6;
inline bool SetRuleRequest::has_syscode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SetRuleRequest::set_has_syscode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SetRuleRequest::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SetRuleRequest::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& SetRuleRequest::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* SetRuleRequest::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* SetRuleRequest::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void SetRuleRequest::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// SetRuleResponse

// required .PBMidLayer.OperationStatus status = 1;
inline bool SetRuleResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetRuleResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetRuleResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetRuleResponse::clear_status() {
  if (status_ != NULL) status_->::PBMidLayer::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBMidLayer::OperationStatus& SetRuleResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBMidLayer::OperationStatus* SetRuleResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBMidLayer::OperationStatus;
  return status_;
}
inline ::PBMidLayer::OperationStatus* SetRuleResponse::release_status() {
  clear_has_status();
  ::PBMidLayer::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void SetRuleResponse::set_allocated_status(::PBMidLayer::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// optional .PBMidLayer.SystemCode syscode = 2;
inline bool SetRuleResponse::has_syscode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetRuleResponse::set_has_syscode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetRuleResponse::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetRuleResponse::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& SetRuleResponse::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* SetRuleResponse::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* SetRuleResponse::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void SetRuleResponse::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// QueryRuleRequest

// required .PBMidLayer.RuleType operation = 1;
inline bool QueryRuleRequest::has_operation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryRuleRequest::set_has_operation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryRuleRequest::clear_has_operation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryRuleRequest::clear_operation() {
  operation_ = 0;
  clear_has_operation();
}
inline ::PBMidLayer::RuleType QueryRuleRequest::operation() const {
  return static_cast< ::PBMidLayer::RuleType >(operation_);
}
inline void QueryRuleRequest::set_operation(::PBMidLayer::RuleType value) {
  assert(::PBMidLayer::RuleType_IsValid(value));
  set_has_operation();
  operation_ = value;
}

// optional string objectid = 2;
inline bool QueryRuleRequest::has_objectid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryRuleRequest::set_has_objectid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryRuleRequest::clear_has_objectid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryRuleRequest::clear_objectid() {
  if (objectid_ != &::google::protobuf::internal::kEmptyString) {
    objectid_->clear();
  }
  clear_has_objectid();
}
inline const ::std::string& QueryRuleRequest::objectid() const {
  return *objectid_;
}
inline void QueryRuleRequest::set_objectid(const ::std::string& value) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(value);
}
inline void QueryRuleRequest::set_objectid(const char* value) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(value);
}
inline void QueryRuleRequest::set_objectid(const char* value, size_t size) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryRuleRequest::mutable_objectid() {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  return objectid_;
}
inline ::std::string* QueryRuleRequest::release_objectid() {
  clear_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = objectid_;
    objectid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryRuleRequest::set_allocated_objectid(::std::string* objectid) {
  if (objectid_ != &::google::protobuf::internal::kEmptyString) {
    delete objectid_;
  }
  if (objectid) {
    set_has_objectid();
    objectid_ = objectid;
  } else {
    clear_has_objectid();
    objectid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string languagename = 3;
inline bool QueryRuleRequest::has_languagename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryRuleRequest::set_has_languagename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryRuleRequest::clear_has_languagename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryRuleRequest::clear_languagename() {
  if (languagename_ != &::google::protobuf::internal::kEmptyString) {
    languagename_->clear();
  }
  clear_has_languagename();
}
inline const ::std::string& QueryRuleRequest::languagename() const {
  return *languagename_;
}
inline void QueryRuleRequest::set_languagename(const ::std::string& value) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(value);
}
inline void QueryRuleRequest::set_languagename(const char* value) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(value);
}
inline void QueryRuleRequest::set_languagename(const char* value, size_t size) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryRuleRequest::mutable_languagename() {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  return languagename_;
}
inline ::std::string* QueryRuleRequest::release_languagename() {
  clear_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = languagename_;
    languagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryRuleRequest::set_allocated_languagename(::std::string* languagename) {
  if (languagename_ != &::google::protobuf::internal::kEmptyString) {
    delete languagename_;
  }
  if (languagename) {
    set_has_languagename();
    languagename_ = languagename;
  } else {
    clear_has_languagename();
    languagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string keyword = 4;
inline bool QueryRuleRequest::has_keyword() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryRuleRequest::set_has_keyword() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryRuleRequest::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryRuleRequest::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& QueryRuleRequest::keyword() const {
  return *keyword_;
}
inline void QueryRuleRequest::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void QueryRuleRequest::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void QueryRuleRequest::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryRuleRequest::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  return keyword_;
}
inline ::std::string* QueryRuleRequest::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryRuleRequest::set_allocated_keyword(::std::string* keyword) {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    delete keyword_;
  }
  if (keyword) {
    set_has_keyword();
    keyword_ = keyword;
  } else {
    clear_has_keyword();
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string speechseglang = 5;
inline bool QueryRuleRequest::has_speechseglang() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QueryRuleRequest::set_has_speechseglang() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QueryRuleRequest::clear_has_speechseglang() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QueryRuleRequest::clear_speechseglang() {
  if (speechseglang_ != &::google::protobuf::internal::kEmptyString) {
    speechseglang_->clear();
  }
  clear_has_speechseglang();
}
inline const ::std::string& QueryRuleRequest::speechseglang() const {
  return *speechseglang_;
}
inline void QueryRuleRequest::set_speechseglang(const ::std::string& value) {
  set_has_speechseglang();
  if (speechseglang_ == &::google::protobuf::internal::kEmptyString) {
    speechseglang_ = new ::std::string;
  }
  speechseglang_->assign(value);
}
inline void QueryRuleRequest::set_speechseglang(const char* value) {
  set_has_speechseglang();
  if (speechseglang_ == &::google::protobuf::internal::kEmptyString) {
    speechseglang_ = new ::std::string;
  }
  speechseglang_->assign(value);
}
inline void QueryRuleRequest::set_speechseglang(const char* value, size_t size) {
  set_has_speechseglang();
  if (speechseglang_ == &::google::protobuf::internal::kEmptyString) {
    speechseglang_ = new ::std::string;
  }
  speechseglang_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryRuleRequest::mutable_speechseglang() {
  set_has_speechseglang();
  if (speechseglang_ == &::google::protobuf::internal::kEmptyString) {
    speechseglang_ = new ::std::string;
  }
  return speechseglang_;
}
inline ::std::string* QueryRuleRequest::release_speechseglang() {
  clear_has_speechseglang();
  if (speechseglang_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = speechseglang_;
    speechseglang_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryRuleRequest::set_allocated_speechseglang(::std::string* speechseglang) {
  if (speechseglang_ != &::google::protobuf::internal::kEmptyString) {
    delete speechseglang_;
  }
  if (speechseglang) {
    set_has_speechseglang();
    speechseglang_ = speechseglang;
  } else {
    clear_has_speechseglang();
    speechseglang_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string speechsegid = 6;
inline bool QueryRuleRequest::has_speechsegid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void QueryRuleRequest::set_has_speechsegid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void QueryRuleRequest::clear_has_speechsegid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void QueryRuleRequest::clear_speechsegid() {
  if (speechsegid_ != &::google::protobuf::internal::kEmptyString) {
    speechsegid_->clear();
  }
  clear_has_speechsegid();
}
inline const ::std::string& QueryRuleRequest::speechsegid() const {
  return *speechsegid_;
}
inline void QueryRuleRequest::set_speechsegid(const ::std::string& value) {
  set_has_speechsegid();
  if (speechsegid_ == &::google::protobuf::internal::kEmptyString) {
    speechsegid_ = new ::std::string;
  }
  speechsegid_->assign(value);
}
inline void QueryRuleRequest::set_speechsegid(const char* value) {
  set_has_speechsegid();
  if (speechsegid_ == &::google::protobuf::internal::kEmptyString) {
    speechsegid_ = new ::std::string;
  }
  speechsegid_->assign(value);
}
inline void QueryRuleRequest::set_speechsegid(const char* value, size_t size) {
  set_has_speechsegid();
  if (speechsegid_ == &::google::protobuf::internal::kEmptyString) {
    speechsegid_ = new ::std::string;
  }
  speechsegid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryRuleRequest::mutable_speechsegid() {
  set_has_speechsegid();
  if (speechsegid_ == &::google::protobuf::internal::kEmptyString) {
    speechsegid_ = new ::std::string;
  }
  return speechsegid_;
}
inline ::std::string* QueryRuleRequest::release_speechsegid() {
  clear_has_speechsegid();
  if (speechsegid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = speechsegid_;
    speechsegid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryRuleRequest::set_allocated_speechsegid(::std::string* speechsegid) {
  if (speechsegid_ != &::google::protobuf::internal::kEmptyString) {
    delete speechsegid_;
  }
  if (speechsegid) {
    set_has_speechsegid();
    speechsegid_ = speechsegid;
  } else {
    clear_has_speechsegid();
    speechsegid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .PBMidLayer.SystemCode syscode = 7;
inline bool QueryRuleRequest::has_syscode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void QueryRuleRequest::set_has_syscode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void QueryRuleRequest::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void QueryRuleRequest::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& QueryRuleRequest::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* QueryRuleRequest::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* QueryRuleRequest::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void QueryRuleRequest::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// QueryRuleResponse

// required .PBMidLayer.OperationStatus status = 1;
inline bool QueryRuleResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryRuleResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryRuleResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryRuleResponse::clear_status() {
  if (status_ != NULL) status_->::PBMidLayer::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBMidLayer::OperationStatus& QueryRuleResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBMidLayer::OperationStatus* QueryRuleResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBMidLayer::OperationStatus;
  return status_;
}
inline ::PBMidLayer::OperationStatus* QueryRuleResponse::release_status() {
  clear_has_status();
  ::PBMidLayer::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void QueryRuleResponse::set_allocated_status(::PBMidLayer::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// required uint32 count = 2;
inline bool QueryRuleResponse::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryRuleResponse::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryRuleResponse::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryRuleResponse::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 QueryRuleResponse::count() const {
  return count_;
}
inline void QueryRuleResponse::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .PBMidLayer.SpeakerRule speakerlist = 3;
inline int QueryRuleResponse::speakerlist_size() const {
  return speakerlist_.size();
}
inline void QueryRuleResponse::clear_speakerlist() {
  speakerlist_.Clear();
}
inline const ::PBMidLayer::SpeakerRule& QueryRuleResponse::speakerlist(int index) const {
  return speakerlist_.Get(index);
}
inline ::PBMidLayer::SpeakerRule* QueryRuleResponse::mutable_speakerlist(int index) {
  return speakerlist_.Mutable(index);
}
inline ::PBMidLayer::SpeakerRule* QueryRuleResponse::add_speakerlist() {
  return speakerlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerRule >&
QueryRuleResponse::speakerlist() const {
  return speakerlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerRule >*
QueryRuleResponse::mutable_speakerlist() {
  return &speakerlist_;
}

// repeated .PBMidLayer.KeywordRule keywordlist = 4;
inline int QueryRuleResponse::keywordlist_size() const {
  return keywordlist_.size();
}
inline void QueryRuleResponse::clear_keywordlist() {
  keywordlist_.Clear();
}
inline const ::PBMidLayer::KeywordRule& QueryRuleResponse::keywordlist(int index) const {
  return keywordlist_.Get(index);
}
inline ::PBMidLayer::KeywordRule* QueryRuleResponse::mutable_keywordlist(int index) {
  return keywordlist_.Mutable(index);
}
inline ::PBMidLayer::KeywordRule* QueryRuleResponse::add_keywordlist() {
  return keywordlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordRule >&
QueryRuleResponse::keywordlist() const {
  return keywordlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordRule >*
QueryRuleResponse::mutable_keywordlist() {
  return &keywordlist_;
}

// repeated .PBMidLayer.SpeechSegRule speechseg = 5;
inline int QueryRuleResponse::speechseg_size() const {
  return speechseg_.size();
}
inline void QueryRuleResponse::clear_speechseg() {
  speechseg_.Clear();
}
inline const ::PBMidLayer::SpeechSegRule& QueryRuleResponse::speechseg(int index) const {
  return speechseg_.Get(index);
}
inline ::PBMidLayer::SpeechSegRule* QueryRuleResponse::mutable_speechseg(int index) {
  return speechseg_.Mutable(index);
}
inline ::PBMidLayer::SpeechSegRule* QueryRuleResponse::add_speechseg() {
  return speechseg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegRule >&
QueryRuleResponse::speechseg() const {
  return speechseg_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegRule >*
QueryRuleResponse::mutable_speechseg() {
  return &speechseg_;
}

// optional .PBMidLayer.SystemCode syscode = 6;
inline bool QueryRuleResponse::has_syscode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void QueryRuleResponse::set_has_syscode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void QueryRuleResponse::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void QueryRuleResponse::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& QueryRuleResponse::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* QueryRuleResponse::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* QueryRuleResponse::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void QueryRuleResponse::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// SetSysParaRequest

// required .PBMidLayer.SystemParaType type = 1;
inline bool SetSysParaRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetSysParaRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetSysParaRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetSysParaRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::PBMidLayer::SystemParaType SetSysParaRequest::type() const {
  return static_cast< ::PBMidLayer::SystemParaType >(type_);
}
inline void SetSysParaRequest::set_type(::PBMidLayer::SystemParaType value) {
  assert(::PBMidLayer::SystemParaType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional float languagethreshold = 2;
inline bool SetSysParaRequest::has_languagethreshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetSysParaRequest::set_has_languagethreshold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetSysParaRequest::clear_has_languagethreshold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetSysParaRequest::clear_languagethreshold() {
  languagethreshold_ = 0;
  clear_has_languagethreshold();
}
inline float SetSysParaRequest::languagethreshold() const {
  return languagethreshold_;
}
inline void SetSysParaRequest::set_languagethreshold(float value) {
  set_has_languagethreshold();
  languagethreshold_ = value;
}

// optional float speakerthreshold = 3;
inline bool SetSysParaRequest::has_speakerthreshold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetSysParaRequest::set_has_speakerthreshold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetSysParaRequest::clear_has_speakerthreshold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetSysParaRequest::clear_speakerthreshold() {
  speakerthreshold_ = 0;
  clear_has_speakerthreshold();
}
inline float SetSysParaRequest::speakerthreshold() const {
  return speakerthreshold_;
}
inline void SetSysParaRequest::set_speakerthreshold(float value) {
  set_has_speakerthreshold();
  speakerthreshold_ = value;
}

// optional float keywordthreshold = 4;
inline bool SetSysParaRequest::has_keywordthreshold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetSysParaRequest::set_has_keywordthreshold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetSysParaRequest::clear_has_keywordthreshold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetSysParaRequest::clear_keywordthreshold() {
  keywordthreshold_ = 0;
  clear_has_keywordthreshold();
}
inline float SetSysParaRequest::keywordthreshold() const {
  return keywordthreshold_;
}
inline void SetSysParaRequest::set_keywordthreshold(float value) {
  set_has_keywordthreshold();
  keywordthreshold_ = value;
}

// optional int32 languagecount = 5;
inline bool SetSysParaRequest::has_languagecount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SetSysParaRequest::set_has_languagecount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SetSysParaRequest::clear_has_languagecount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SetSysParaRequest::clear_languagecount() {
  languagecount_ = 0;
  clear_has_languagecount();
}
inline ::google::protobuf::int32 SetSysParaRequest::languagecount() const {
  return languagecount_;
}
inline void SetSysParaRequest::set_languagecount(::google::protobuf::int32 value) {
  set_has_languagecount();
  languagecount_ = value;
}

// optional int32 speakercount = 6;
inline bool SetSysParaRequest::has_speakercount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SetSysParaRequest::set_has_speakercount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SetSysParaRequest::clear_has_speakercount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SetSysParaRequest::clear_speakercount() {
  speakercount_ = 0;
  clear_has_speakercount();
}
inline ::google::protobuf::int32 SetSysParaRequest::speakercount() const {
  return speakercount_;
}
inline void SetSysParaRequest::set_speakercount(::google::protobuf::int32 value) {
  set_has_speakercount();
  speakercount_ = value;
}

// optional .PBMidLayer.SystemCode syscode = 7;
inline bool SetSysParaRequest::has_syscode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SetSysParaRequest::set_has_syscode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SetSysParaRequest::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SetSysParaRequest::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& SetSysParaRequest::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* SetSysParaRequest::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* SetSysParaRequest::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void SetSysParaRequest::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// SetSysParaResponse

// required .PBMidLayer.OperationStatus status = 1;
inline bool SetSysParaResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetSysParaResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetSysParaResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetSysParaResponse::clear_status() {
  if (status_ != NULL) status_->::PBMidLayer::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBMidLayer::OperationStatus& SetSysParaResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBMidLayer::OperationStatus* SetSysParaResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBMidLayer::OperationStatus;
  return status_;
}
inline ::PBMidLayer::OperationStatus* SetSysParaResponse::release_status() {
  clear_has_status();
  ::PBMidLayer::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void SetSysParaResponse::set_allocated_status(::PBMidLayer::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// optional .PBMidLayer.SystemCode syscode = 2;
inline bool SetSysParaResponse::has_syscode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetSysParaResponse::set_has_syscode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetSysParaResponse::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetSysParaResponse::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& SetSysParaResponse::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* SetSysParaResponse::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* SetSysParaResponse::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void SetSysParaResponse::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// QuerySysParaRequest

// optional .PBMidLayer.SystemCode syscode = 1;
inline bool QuerySysParaRequest::has_syscode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuerySysParaRequest::set_has_syscode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuerySysParaRequest::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuerySysParaRequest::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& QuerySysParaRequest::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* QuerySysParaRequest::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* QuerySysParaRequest::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void QuerySysParaRequest::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// QuerySysParaResponse

// required .PBMidLayer.OperationStatus status = 1;
inline bool QuerySysParaResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuerySysParaResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuerySysParaResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuerySysParaResponse::clear_status() {
  if (status_ != NULL) status_->::PBMidLayer::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBMidLayer::OperationStatus& QuerySysParaResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBMidLayer::OperationStatus* QuerySysParaResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBMidLayer::OperationStatus;
  return status_;
}
inline ::PBMidLayer::OperationStatus* QuerySysParaResponse::release_status() {
  clear_has_status();
  ::PBMidLayer::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void QuerySysParaResponse::set_allocated_status(::PBMidLayer::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// optional float languagethreshold = 2;
inline bool QuerySysParaResponse::has_languagethreshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuerySysParaResponse::set_has_languagethreshold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuerySysParaResponse::clear_has_languagethreshold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuerySysParaResponse::clear_languagethreshold() {
  languagethreshold_ = 0;
  clear_has_languagethreshold();
}
inline float QuerySysParaResponse::languagethreshold() const {
  return languagethreshold_;
}
inline void QuerySysParaResponse::set_languagethreshold(float value) {
  set_has_languagethreshold();
  languagethreshold_ = value;
}

// optional float speakerthreshold = 3;
inline bool QuerySysParaResponse::has_speakerthreshold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QuerySysParaResponse::set_has_speakerthreshold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QuerySysParaResponse::clear_has_speakerthreshold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QuerySysParaResponse::clear_speakerthreshold() {
  speakerthreshold_ = 0;
  clear_has_speakerthreshold();
}
inline float QuerySysParaResponse::speakerthreshold() const {
  return speakerthreshold_;
}
inline void QuerySysParaResponse::set_speakerthreshold(float value) {
  set_has_speakerthreshold();
  speakerthreshold_ = value;
}

// optional float keywordthreshold = 4;
inline bool QuerySysParaResponse::has_keywordthreshold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QuerySysParaResponse::set_has_keywordthreshold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QuerySysParaResponse::clear_has_keywordthreshold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QuerySysParaResponse::clear_keywordthreshold() {
  keywordthreshold_ = 0;
  clear_has_keywordthreshold();
}
inline float QuerySysParaResponse::keywordthreshold() const {
  return keywordthreshold_;
}
inline void QuerySysParaResponse::set_keywordthreshold(float value) {
  set_has_keywordthreshold();
  keywordthreshold_ = value;
}

// optional int32 languagecount = 5;
inline bool QuerySysParaResponse::has_languagecount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QuerySysParaResponse::set_has_languagecount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QuerySysParaResponse::clear_has_languagecount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QuerySysParaResponse::clear_languagecount() {
  languagecount_ = 0;
  clear_has_languagecount();
}
inline ::google::protobuf::int32 QuerySysParaResponse::languagecount() const {
  return languagecount_;
}
inline void QuerySysParaResponse::set_languagecount(::google::protobuf::int32 value) {
  set_has_languagecount();
  languagecount_ = value;
}

// optional int32 speakercount = 6;
inline bool QuerySysParaResponse::has_speakercount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void QuerySysParaResponse::set_has_speakercount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void QuerySysParaResponse::clear_has_speakercount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void QuerySysParaResponse::clear_speakercount() {
  speakercount_ = 0;
  clear_has_speakercount();
}
inline ::google::protobuf::int32 QuerySysParaResponse::speakercount() const {
  return speakercount_;
}
inline void QuerySysParaResponse::set_speakercount(::google::protobuf::int32 value) {
  set_has_speakercount();
  speakercount_ = value;
}

// required uint32 supportlangs = 7;
inline bool QuerySysParaResponse::has_supportlangs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void QuerySysParaResponse::set_has_supportlangs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void QuerySysParaResponse::clear_has_supportlangs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void QuerySysParaResponse::clear_supportlangs() {
  supportlangs_ = 0u;
  clear_has_supportlangs();
}
inline ::google::protobuf::uint32 QuerySysParaResponse::supportlangs() const {
  return supportlangs_;
}
inline void QuerySysParaResponse::set_supportlangs(::google::protobuf::uint32 value) {
  set_has_supportlangs();
  supportlangs_ = value;
}

// repeated .PBMidLayer.LanguageInfo langlist = 8;
inline int QuerySysParaResponse::langlist_size() const {
  return langlist_.size();
}
inline void QuerySysParaResponse::clear_langlist() {
  langlist_.Clear();
}
inline const ::PBMidLayer::LanguageInfo& QuerySysParaResponse::langlist(int index) const {
  return langlist_.Get(index);
}
inline ::PBMidLayer::LanguageInfo* QuerySysParaResponse::mutable_langlist(int index) {
  return langlist_.Mutable(index);
}
inline ::PBMidLayer::LanguageInfo* QuerySysParaResponse::add_langlist() {
  return langlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::LanguageInfo >&
QuerySysParaResponse::langlist() const {
  return langlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::LanguageInfo >*
QuerySysParaResponse::mutable_langlist() {
  return &langlist_;
}

// optional .PBMidLayer.SystemCode syscode = 9;
inline bool QuerySysParaResponse::has_syscode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void QuerySysParaResponse::set_has_syscode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void QuerySysParaResponse::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void QuerySysParaResponse::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& QuerySysParaResponse::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* QuerySysParaResponse::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* QuerySysParaResponse::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void QuerySysParaResponse::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// AlarmNotify

// required string alarmtime = 1;
inline bool AlarmNotify::has_alarmtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlarmNotify::set_has_alarmtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlarmNotify::clear_has_alarmtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlarmNotify::clear_alarmtime() {
  if (alarmtime_ != &::google::protobuf::internal::kEmptyString) {
    alarmtime_->clear();
  }
  clear_has_alarmtime();
}
inline const ::std::string& AlarmNotify::alarmtime() const {
  return *alarmtime_;
}
inline void AlarmNotify::set_alarmtime(const ::std::string& value) {
  set_has_alarmtime();
  if (alarmtime_ == &::google::protobuf::internal::kEmptyString) {
    alarmtime_ = new ::std::string;
  }
  alarmtime_->assign(value);
}
inline void AlarmNotify::set_alarmtime(const char* value) {
  set_has_alarmtime();
  if (alarmtime_ == &::google::protobuf::internal::kEmptyString) {
    alarmtime_ = new ::std::string;
  }
  alarmtime_->assign(value);
}
inline void AlarmNotify::set_alarmtime(const char* value, size_t size) {
  set_has_alarmtime();
  if (alarmtime_ == &::google::protobuf::internal::kEmptyString) {
    alarmtime_ = new ::std::string;
  }
  alarmtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AlarmNotify::mutable_alarmtime() {
  set_has_alarmtime();
  if (alarmtime_ == &::google::protobuf::internal::kEmptyString) {
    alarmtime_ = new ::std::string;
  }
  return alarmtime_;
}
inline ::std::string* AlarmNotify::release_alarmtime() {
  clear_has_alarmtime();
  if (alarmtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alarmtime_;
    alarmtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AlarmNotify::set_allocated_alarmtime(::std::string* alarmtime) {
  if (alarmtime_ != &::google::protobuf::internal::kEmptyString) {
    delete alarmtime_;
  }
  if (alarmtime) {
    set_has_alarmtime();
    alarmtime_ = alarmtime;
  } else {
    clear_has_alarmtime();
    alarmtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.AlarmLevel level = 2;
inline bool AlarmNotify::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AlarmNotify::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AlarmNotify::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AlarmNotify::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::PBMidLayer::AlarmLevel AlarmNotify::level() const {
  return static_cast< ::PBMidLayer::AlarmLevel >(level_);
}
inline void AlarmNotify::set_level(::PBMidLayer::AlarmLevel value) {
  assert(::PBMidLayer::AlarmLevel_IsValid(value));
  set_has_level();
  level_ = value;
}

// required string content = 3;
inline bool AlarmNotify::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AlarmNotify::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AlarmNotify::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AlarmNotify::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& AlarmNotify::content() const {
  return *content_;
}
inline void AlarmNotify::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void AlarmNotify::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void AlarmNotify::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AlarmNotify::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* AlarmNotify::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AlarmNotify::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string modulename = 4;
inline bool AlarmNotify::has_modulename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AlarmNotify::set_has_modulename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AlarmNotify::clear_has_modulename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AlarmNotify::clear_modulename() {
  if (modulename_ != &::google::protobuf::internal::kEmptyString) {
    modulename_->clear();
  }
  clear_has_modulename();
}
inline const ::std::string& AlarmNotify::modulename() const {
  return *modulename_;
}
inline void AlarmNotify::set_modulename(const ::std::string& value) {
  set_has_modulename();
  if (modulename_ == &::google::protobuf::internal::kEmptyString) {
    modulename_ = new ::std::string;
  }
  modulename_->assign(value);
}
inline void AlarmNotify::set_modulename(const char* value) {
  set_has_modulename();
  if (modulename_ == &::google::protobuf::internal::kEmptyString) {
    modulename_ = new ::std::string;
  }
  modulename_->assign(value);
}
inline void AlarmNotify::set_modulename(const char* value, size_t size) {
  set_has_modulename();
  if (modulename_ == &::google::protobuf::internal::kEmptyString) {
    modulename_ = new ::std::string;
  }
  modulename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AlarmNotify::mutable_modulename() {
  set_has_modulename();
  if (modulename_ == &::google::protobuf::internal::kEmptyString) {
    modulename_ = new ::std::string;
  }
  return modulename_;
}
inline ::std::string* AlarmNotify::release_modulename() {
  clear_has_modulename();
  if (modulename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modulename_;
    modulename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AlarmNotify::set_allocated_modulename(::std::string* modulename) {
  if (modulename_ != &::google::protobuf::internal::kEmptyString) {
    delete modulename_;
  }
  if (modulename) {
    set_has_modulename();
    modulename_ = modulename;
  } else {
    clear_has_modulename();
    modulename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .PBMidLayer.SystemCode syscode = 5;
inline bool AlarmNotify::has_syscode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AlarmNotify::set_has_syscode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AlarmNotify::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AlarmNotify::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& AlarmNotify::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* AlarmNotify::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* AlarmNotify::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void AlarmNotify::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// StatusNotify

// required string modulename = 1;
inline bool StatusNotify::has_modulename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusNotify::set_has_modulename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusNotify::clear_has_modulename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusNotify::clear_modulename() {
  if (modulename_ != &::google::protobuf::internal::kEmptyString) {
    modulename_->clear();
  }
  clear_has_modulename();
}
inline const ::std::string& StatusNotify::modulename() const {
  return *modulename_;
}
inline void StatusNotify::set_modulename(const ::std::string& value) {
  set_has_modulename();
  if (modulename_ == &::google::protobuf::internal::kEmptyString) {
    modulename_ = new ::std::string;
  }
  modulename_->assign(value);
}
inline void StatusNotify::set_modulename(const char* value) {
  set_has_modulename();
  if (modulename_ == &::google::protobuf::internal::kEmptyString) {
    modulename_ = new ::std::string;
  }
  modulename_->assign(value);
}
inline void StatusNotify::set_modulename(const char* value, size_t size) {
  set_has_modulename();
  if (modulename_ == &::google::protobuf::internal::kEmptyString) {
    modulename_ = new ::std::string;
  }
  modulename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusNotify::mutable_modulename() {
  set_has_modulename();
  if (modulename_ == &::google::protobuf::internal::kEmptyString) {
    modulename_ = new ::std::string;
  }
  return modulename_;
}
inline ::std::string* StatusNotify::release_modulename() {
  clear_has_modulename();
  if (modulename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modulename_;
    modulename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatusNotify::set_allocated_modulename(::std::string* modulename) {
  if (modulename_ != &::google::protobuf::internal::kEmptyString) {
    delete modulename_;
  }
  if (modulename) {
    set_has_modulename();
    modulename_ = modulename;
  } else {
    clear_has_modulename();
    modulename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ip = 2;
inline bool StatusNotify::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatusNotify::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatusNotify::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatusNotify::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& StatusNotify::ip() const {
  return *ip_;
}
inline void StatusNotify::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void StatusNotify::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void StatusNotify::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusNotify::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* StatusNotify::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatusNotify::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required float cpuusage = 3;
inline bool StatusNotify::has_cpuusage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StatusNotify::set_has_cpuusage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StatusNotify::clear_has_cpuusage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StatusNotify::clear_cpuusage() {
  cpuusage_ = 0;
  clear_has_cpuusage();
}
inline float StatusNotify::cpuusage() const {
  return cpuusage_;
}
inline void StatusNotify::set_cpuusage(float value) {
  set_has_cpuusage();
  cpuusage_ = value;
}

// required int32 totalmemory = 4;
inline bool StatusNotify::has_totalmemory() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StatusNotify::set_has_totalmemory() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StatusNotify::clear_has_totalmemory() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StatusNotify::clear_totalmemory() {
  totalmemory_ = 0;
  clear_has_totalmemory();
}
inline ::google::protobuf::int32 StatusNotify::totalmemory() const {
  return totalmemory_;
}
inline void StatusNotify::set_totalmemory(::google::protobuf::int32 value) {
  set_has_totalmemory();
  totalmemory_ = value;
}

// required int32 memoryused = 5;
inline bool StatusNotify::has_memoryused() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StatusNotify::set_has_memoryused() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StatusNotify::clear_has_memoryused() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StatusNotify::clear_memoryused() {
  memoryused_ = 0;
  clear_has_memoryused();
}
inline ::google::protobuf::int32 StatusNotify::memoryused() const {
  return memoryused_;
}
inline void StatusNotify::set_memoryused(::google::protobuf::int32 value) {
  set_has_memoryused();
  memoryused_ = value;
}

// required int32 currenttasks = 6;
inline bool StatusNotify::has_currenttasks() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StatusNotify::set_has_currenttasks() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StatusNotify::clear_has_currenttasks() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StatusNotify::clear_currenttasks() {
  currenttasks_ = 0;
  clear_has_currenttasks();
}
inline ::google::protobuf::int32 StatusNotify::currenttasks() const {
  return currenttasks_;
}
inline void StatusNotify::set_currenttasks(::google::protobuf::int32 value) {
  set_has_currenttasks();
  currenttasks_ = value;
}

// required string recordtime = 7;
inline bool StatusNotify::has_recordtime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StatusNotify::set_has_recordtime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StatusNotify::clear_has_recordtime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StatusNotify::clear_recordtime() {
  if (recordtime_ != &::google::protobuf::internal::kEmptyString) {
    recordtime_->clear();
  }
  clear_has_recordtime();
}
inline const ::std::string& StatusNotify::recordtime() const {
  return *recordtime_;
}
inline void StatusNotify::set_recordtime(const ::std::string& value) {
  set_has_recordtime();
  if (recordtime_ == &::google::protobuf::internal::kEmptyString) {
    recordtime_ = new ::std::string;
  }
  recordtime_->assign(value);
}
inline void StatusNotify::set_recordtime(const char* value) {
  set_has_recordtime();
  if (recordtime_ == &::google::protobuf::internal::kEmptyString) {
    recordtime_ = new ::std::string;
  }
  recordtime_->assign(value);
}
inline void StatusNotify::set_recordtime(const char* value, size_t size) {
  set_has_recordtime();
  if (recordtime_ == &::google::protobuf::internal::kEmptyString) {
    recordtime_ = new ::std::string;
  }
  recordtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusNotify::mutable_recordtime() {
  set_has_recordtime();
  if (recordtime_ == &::google::protobuf::internal::kEmptyString) {
    recordtime_ = new ::std::string;
  }
  return recordtime_;
}
inline ::std::string* StatusNotify::release_recordtime() {
  clear_has_recordtime();
  if (recordtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recordtime_;
    recordtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatusNotify::set_allocated_recordtime(::std::string* recordtime) {
  if (recordtime_ != &::google::protobuf::internal::kEmptyString) {
    delete recordtime_;
  }
  if (recordtime) {
    set_has_recordtime();
    recordtime_ = recordtime;
  } else {
    clear_has_recordtime();
    recordtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .PBMidLayer.SystemCode syscode = 8;
inline bool StatusNotify::has_syscode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StatusNotify::set_has_syscode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StatusNotify::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StatusNotify::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& StatusNotify::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* StatusNotify::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* StatusNotify::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void StatusNotify::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// repeated .PBMidLayer.SystemStateItem states = 9;
inline int StatusNotify::states_size() const {
  return states_.size();
}
inline void StatusNotify::clear_states() {
  states_.Clear();
}
inline const ::PBMidLayer::SystemStateItem& StatusNotify::states(int index) const {
  return states_.Get(index);
}
inline ::PBMidLayer::SystemStateItem* StatusNotify::mutable_states(int index) {
  return states_.Mutable(index);
}
inline ::PBMidLayer::SystemStateItem* StatusNotify::add_states() {
  return states_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SystemStateItem >&
StatusNotify::states() const {
  return states_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SystemStateItem >*
StatusNotify::mutable_states() {
  return &states_;
}

// -------------------------------------------------------------------

// ObjectManageRequest

// required string objectid = 1;
inline bool ObjectManageRequest::has_objectid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectManageRequest::set_has_objectid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectManageRequest::clear_has_objectid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectManageRequest::clear_objectid() {
  if (objectid_ != &::google::protobuf::internal::kEmptyString) {
    objectid_->clear();
  }
  clear_has_objectid();
}
inline const ::std::string& ObjectManageRequest::objectid() const {
  return *objectid_;
}
inline void ObjectManageRequest::set_objectid(const ::std::string& value) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(value);
}
inline void ObjectManageRequest::set_objectid(const char* value) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(value);
}
inline void ObjectManageRequest::set_objectid(const char* value, size_t size) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ObjectManageRequest::mutable_objectid() {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  return objectid_;
}
inline ::std::string* ObjectManageRequest::release_objectid() {
  clear_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = objectid_;
    objectid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ObjectManageRequest::set_allocated_objectid(::std::string* objectid) {
  if (objectid_ != &::google::protobuf::internal::kEmptyString) {
    delete objectid_;
  }
  if (objectid) {
    set_has_objectid();
    objectid_ = objectid;
  } else {
    clear_has_objectid();
    objectid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.OperationType opertype = 2;
inline bool ObjectManageRequest::has_opertype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectManageRequest::set_has_opertype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectManageRequest::clear_has_opertype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectManageRequest::clear_opertype() {
  opertype_ = 0;
  clear_has_opertype();
}
inline ::PBMidLayer::OperationType ObjectManageRequest::opertype() const {
  return static_cast< ::PBMidLayer::OperationType >(opertype_);
}
inline void ObjectManageRequest::set_opertype(::PBMidLayer::OperationType value) {
  assert(::PBMidLayer::OperationType_IsValid(value));
  set_has_opertype();
  opertype_ = value;
}

// required uint32 count = 3;
inline bool ObjectManageRequest::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObjectManageRequest::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObjectManageRequest::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObjectManageRequest::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 ObjectManageRequest::count() const {
  return count_;
}
inline void ObjectManageRequest::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .PBMidLayer.TrainInfo list = 4;
inline int ObjectManageRequest::list_size() const {
  return list_.size();
}
inline void ObjectManageRequest::clear_list() {
  list_.Clear();
}
inline const ::PBMidLayer::TrainInfo& ObjectManageRequest::list(int index) const {
  return list_.Get(index);
}
inline ::PBMidLayer::TrainInfo* ObjectManageRequest::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::PBMidLayer::TrainInfo* ObjectManageRequest::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::TrainInfo >&
ObjectManageRequest::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::TrainInfo >*
ObjectManageRequest::mutable_list() {
  return &list_;
}

// optional string objectname = 5;
inline bool ObjectManageRequest::has_objectname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ObjectManageRequest::set_has_objectname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ObjectManageRequest::clear_has_objectname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ObjectManageRequest::clear_objectname() {
  if (objectname_ != &::google::protobuf::internal::kEmptyString) {
    objectname_->clear();
  }
  clear_has_objectname();
}
inline const ::std::string& ObjectManageRequest::objectname() const {
  return *objectname_;
}
inline void ObjectManageRequest::set_objectname(const ::std::string& value) {
  set_has_objectname();
  if (objectname_ == &::google::protobuf::internal::kEmptyString) {
    objectname_ = new ::std::string;
  }
  objectname_->assign(value);
}
inline void ObjectManageRequest::set_objectname(const char* value) {
  set_has_objectname();
  if (objectname_ == &::google::protobuf::internal::kEmptyString) {
    objectname_ = new ::std::string;
  }
  objectname_->assign(value);
}
inline void ObjectManageRequest::set_objectname(const char* value, size_t size) {
  set_has_objectname();
  if (objectname_ == &::google::protobuf::internal::kEmptyString) {
    objectname_ = new ::std::string;
  }
  objectname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ObjectManageRequest::mutable_objectname() {
  set_has_objectname();
  if (objectname_ == &::google::protobuf::internal::kEmptyString) {
    objectname_ = new ::std::string;
  }
  return objectname_;
}
inline ::std::string* ObjectManageRequest::release_objectname() {
  clear_has_objectname();
  if (objectname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = objectname_;
    objectname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ObjectManageRequest::set_allocated_objectname(::std::string* objectname) {
  if (objectname_ != &::google::protobuf::internal::kEmptyString) {
    delete objectname_;
  }
  if (objectname) {
    set_has_objectname();
    objectname_ = objectname;
  } else {
    clear_has_objectname();
    objectname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isautotrain = 6;
inline bool ObjectManageRequest::has_isautotrain() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ObjectManageRequest::set_has_isautotrain() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ObjectManageRequest::clear_has_isautotrain() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ObjectManageRequest::clear_isautotrain() {
  isautotrain_ = false;
  clear_has_isautotrain();
}
inline bool ObjectManageRequest::isautotrain() const {
  return isautotrain_;
}
inline void ObjectManageRequest::set_isautotrain(bool value) {
  set_has_isautotrain();
  isautotrain_ = value;
}

// optional .PBMidLayer.SystemCode syscode = 7;
inline bool ObjectManageRequest::has_syscode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ObjectManageRequest::set_has_syscode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ObjectManageRequest::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ObjectManageRequest::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& ObjectManageRequest::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* ObjectManageRequest::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* ObjectManageRequest::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void ObjectManageRequest::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// optional .PBMidLayer.GenderType gender = 8;
inline bool ObjectManageRequest::has_gender() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ObjectManageRequest::set_has_gender() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ObjectManageRequest::clear_has_gender() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ObjectManageRequest::clear_gender() {
  gender_ = 0;
  clear_has_gender();
}
inline ::PBMidLayer::GenderType ObjectManageRequest::gender() const {
  return static_cast< ::PBMidLayer::GenderType >(gender_);
}
inline void ObjectManageRequest::set_gender(::PBMidLayer::GenderType value) {
  assert(::PBMidLayer::GenderType_IsValid(value));
  set_has_gender();
  gender_ = value;
}

// -------------------------------------------------------------------

// ObjectManageNotify

// required .PBMidLayer.OperationStatus status = 1;
inline bool ObjectManageNotify::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectManageNotify::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectManageNotify::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectManageNotify::clear_status() {
  if (status_ != NULL) status_->::PBMidLayer::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBMidLayer::OperationStatus& ObjectManageNotify::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBMidLayer::OperationStatus* ObjectManageNotify::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBMidLayer::OperationStatus;
  return status_;
}
inline ::PBMidLayer::OperationStatus* ObjectManageNotify::release_status() {
  clear_has_status();
  ::PBMidLayer::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void ObjectManageNotify::set_allocated_status(::PBMidLayer::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// optional string objectid = 2;
inline bool ObjectManageNotify::has_objectid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectManageNotify::set_has_objectid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectManageNotify::clear_has_objectid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectManageNotify::clear_objectid() {
  if (objectid_ != &::google::protobuf::internal::kEmptyString) {
    objectid_->clear();
  }
  clear_has_objectid();
}
inline const ::std::string& ObjectManageNotify::objectid() const {
  return *objectid_;
}
inline void ObjectManageNotify::set_objectid(const ::std::string& value) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(value);
}
inline void ObjectManageNotify::set_objectid(const char* value) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(value);
}
inline void ObjectManageNotify::set_objectid(const char* value, size_t size) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ObjectManageNotify::mutable_objectid() {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  return objectid_;
}
inline ::std::string* ObjectManageNotify::release_objectid() {
  clear_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = objectid_;
    objectid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ObjectManageNotify::set_allocated_objectid(::std::string* objectid) {
  if (objectid_ != &::google::protobuf::internal::kEmptyString) {
    delete objectid_;
  }
  if (objectid) {
    set_has_objectid();
    objectid_ = objectid;
  } else {
    clear_has_objectid();
    objectid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .PBMidLayer.SystemCode syscode = 3;
inline bool ObjectManageNotify::has_syscode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObjectManageNotify::set_has_syscode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObjectManageNotify::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObjectManageNotify::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& ObjectManageNotify::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* ObjectManageNotify::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* ObjectManageNotify::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void ObjectManageNotify::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// ObjectManageResponse

// required .PBMidLayer.OperationStatus status = 1;
inline bool ObjectManageResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectManageResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectManageResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectManageResponse::clear_status() {
  if (status_ != NULL) status_->::PBMidLayer::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBMidLayer::OperationStatus& ObjectManageResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBMidLayer::OperationStatus* ObjectManageResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBMidLayer::OperationStatus;
  return status_;
}
inline ::PBMidLayer::OperationStatus* ObjectManageResponse::release_status() {
  clear_has_status();
  ::PBMidLayer::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void ObjectManageResponse::set_allocated_status(::PBMidLayer::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// optional string objectid = 2;
inline bool ObjectManageResponse::has_objectid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectManageResponse::set_has_objectid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectManageResponse::clear_has_objectid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectManageResponse::clear_objectid() {
  if (objectid_ != &::google::protobuf::internal::kEmptyString) {
    objectid_->clear();
  }
  clear_has_objectid();
}
inline const ::std::string& ObjectManageResponse::objectid() const {
  return *objectid_;
}
inline void ObjectManageResponse::set_objectid(const ::std::string& value) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(value);
}
inline void ObjectManageResponse::set_objectid(const char* value) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(value);
}
inline void ObjectManageResponse::set_objectid(const char* value, size_t size) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ObjectManageResponse::mutable_objectid() {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  return objectid_;
}
inline ::std::string* ObjectManageResponse::release_objectid() {
  clear_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = objectid_;
    objectid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ObjectManageResponse::set_allocated_objectid(::std::string* objectid) {
  if (objectid_ != &::google::protobuf::internal::kEmptyString) {
    delete objectid_;
  }
  if (objectid) {
    set_has_objectid();
    objectid_ = objectid;
  } else {
    clear_has_objectid();
    objectid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .PBMidLayer.SystemCode syscode = 3;
inline bool ObjectManageResponse::has_syscode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObjectManageResponse::set_has_syscode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObjectManageResponse::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObjectManageResponse::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& ObjectManageResponse::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* ObjectManageResponse::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* ObjectManageResponse::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void ObjectManageResponse::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// FeedbackNotify

// required string callid = 1;
inline bool FeedbackNotify::has_callid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeedbackNotify::set_has_callid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeedbackNotify::clear_has_callid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeedbackNotify::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& FeedbackNotify::callid() const {
  return *callid_;
}
inline void FeedbackNotify::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void FeedbackNotify::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void FeedbackNotify::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeedbackNotify::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* FeedbackNotify::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FeedbackNotify::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.AudioFileTag filetag = 2;
inline bool FeedbackNotify::has_filetag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeedbackNotify::set_has_filetag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeedbackNotify::clear_has_filetag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeedbackNotify::clear_filetag() {
  filetag_ = 0;
  clear_has_filetag();
}
inline ::PBMidLayer::AudioFileTag FeedbackNotify::filetag() const {
  return static_cast< ::PBMidLayer::AudioFileTag >(filetag_);
}
inline void FeedbackNotify::set_filetag(::PBMidLayer::AudioFileTag value) {
  assert(::PBMidLayer::AudioFileTag_IsValid(value));
  set_has_filetag();
  filetag_ = value;
}

// optional int32 type = 3;
inline bool FeedbackNotify::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FeedbackNotify::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FeedbackNotify::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FeedbackNotify::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 FeedbackNotify::type() const {
  return type_;
}
inline void FeedbackNotify::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 result = 4;
inline bool FeedbackNotify::has_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FeedbackNotify::set_has_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FeedbackNotify::clear_has_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FeedbackNotify::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 FeedbackNotify::result() const {
  return result_;
}
inline void FeedbackNotify::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .PBMidLayer.PreprocessResult errorpp = 5;
inline bool FeedbackNotify::has_errorpp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FeedbackNotify::set_has_errorpp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FeedbackNotify::clear_has_errorpp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FeedbackNotify::clear_errorpp() {
  if (errorpp_ != NULL) errorpp_->::PBMidLayer::PreprocessResult::Clear();
  clear_has_errorpp();
}
inline const ::PBMidLayer::PreprocessResult& FeedbackNotify::errorpp() const {
  return errorpp_ != NULL ? *errorpp_ : *default_instance_->errorpp_;
}
inline ::PBMidLayer::PreprocessResult* FeedbackNotify::mutable_errorpp() {
  set_has_errorpp();
  if (errorpp_ == NULL) errorpp_ = new ::PBMidLayer::PreprocessResult;
  return errorpp_;
}
inline ::PBMidLayer::PreprocessResult* FeedbackNotify::release_errorpp() {
  clear_has_errorpp();
  ::PBMidLayer::PreprocessResult* temp = errorpp_;
  errorpp_ = NULL;
  return temp;
}
inline void FeedbackNotify::set_allocated_errorpp(::PBMidLayer::PreprocessResult* errorpp) {
  delete errorpp_;
  errorpp_ = errorpp;
  if (errorpp) {
    set_has_errorpp();
  } else {
    clear_has_errorpp();
  }
}

// optional .PBMidLayer.PreprocessResult rightpp = 6;
inline bool FeedbackNotify::has_rightpp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FeedbackNotify::set_has_rightpp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FeedbackNotify::clear_has_rightpp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FeedbackNotify::clear_rightpp() {
  if (rightpp_ != NULL) rightpp_->::PBMidLayer::PreprocessResult::Clear();
  clear_has_rightpp();
}
inline const ::PBMidLayer::PreprocessResult& FeedbackNotify::rightpp() const {
  return rightpp_ != NULL ? *rightpp_ : *default_instance_->rightpp_;
}
inline ::PBMidLayer::PreprocessResult* FeedbackNotify::mutable_rightpp() {
  set_has_rightpp();
  if (rightpp_ == NULL) rightpp_ = new ::PBMidLayer::PreprocessResult;
  return rightpp_;
}
inline ::PBMidLayer::PreprocessResult* FeedbackNotify::release_rightpp() {
  clear_has_rightpp();
  ::PBMidLayer::PreprocessResult* temp = rightpp_;
  rightpp_ = NULL;
  return temp;
}
inline void FeedbackNotify::set_allocated_rightpp(::PBMidLayer::PreprocessResult* rightpp) {
  delete rightpp_;
  rightpp_ = rightpp;
  if (rightpp) {
    set_has_rightpp();
  } else {
    clear_has_rightpp();
  }
}

// optional .PBMidLayer.SpeakerResult errorsp = 7;
inline bool FeedbackNotify::has_errorsp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FeedbackNotify::set_has_errorsp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FeedbackNotify::clear_has_errorsp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FeedbackNotify::clear_errorsp() {
  if (errorsp_ != NULL) errorsp_->::PBMidLayer::SpeakerResult::Clear();
  clear_has_errorsp();
}
inline const ::PBMidLayer::SpeakerResult& FeedbackNotify::errorsp() const {
  return errorsp_ != NULL ? *errorsp_ : *default_instance_->errorsp_;
}
inline ::PBMidLayer::SpeakerResult* FeedbackNotify::mutable_errorsp() {
  set_has_errorsp();
  if (errorsp_ == NULL) errorsp_ = new ::PBMidLayer::SpeakerResult;
  return errorsp_;
}
inline ::PBMidLayer::SpeakerResult* FeedbackNotify::release_errorsp() {
  clear_has_errorsp();
  ::PBMidLayer::SpeakerResult* temp = errorsp_;
  errorsp_ = NULL;
  return temp;
}
inline void FeedbackNotify::set_allocated_errorsp(::PBMidLayer::SpeakerResult* errorsp) {
  delete errorsp_;
  errorsp_ = errorsp;
  if (errorsp) {
    set_has_errorsp();
  } else {
    clear_has_errorsp();
  }
}

// optional .PBMidLayer.SpeakerResult rightsp = 8;
inline bool FeedbackNotify::has_rightsp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FeedbackNotify::set_has_rightsp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FeedbackNotify::clear_has_rightsp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FeedbackNotify::clear_rightsp() {
  if (rightsp_ != NULL) rightsp_->::PBMidLayer::SpeakerResult::Clear();
  clear_has_rightsp();
}
inline const ::PBMidLayer::SpeakerResult& FeedbackNotify::rightsp() const {
  return rightsp_ != NULL ? *rightsp_ : *default_instance_->rightsp_;
}
inline ::PBMidLayer::SpeakerResult* FeedbackNotify::mutable_rightsp() {
  set_has_rightsp();
  if (rightsp_ == NULL) rightsp_ = new ::PBMidLayer::SpeakerResult;
  return rightsp_;
}
inline ::PBMidLayer::SpeakerResult* FeedbackNotify::release_rightsp() {
  clear_has_rightsp();
  ::PBMidLayer::SpeakerResult* temp = rightsp_;
  rightsp_ = NULL;
  return temp;
}
inline void FeedbackNotify::set_allocated_rightsp(::PBMidLayer::SpeakerResult* rightsp) {
  delete rightsp_;
  rightsp_ = rightsp;
  if (rightsp) {
    set_has_rightsp();
  } else {
    clear_has_rightsp();
  }
}

// optional .PBMidLayer.KeywordResult errorkw = 9;
inline bool FeedbackNotify::has_errorkw() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FeedbackNotify::set_has_errorkw() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FeedbackNotify::clear_has_errorkw() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FeedbackNotify::clear_errorkw() {
  if (errorkw_ != NULL) errorkw_->::PBMidLayer::KeywordResult::Clear();
  clear_has_errorkw();
}
inline const ::PBMidLayer::KeywordResult& FeedbackNotify::errorkw() const {
  return errorkw_ != NULL ? *errorkw_ : *default_instance_->errorkw_;
}
inline ::PBMidLayer::KeywordResult* FeedbackNotify::mutable_errorkw() {
  set_has_errorkw();
  if (errorkw_ == NULL) errorkw_ = new ::PBMidLayer::KeywordResult;
  return errorkw_;
}
inline ::PBMidLayer::KeywordResult* FeedbackNotify::release_errorkw() {
  clear_has_errorkw();
  ::PBMidLayer::KeywordResult* temp = errorkw_;
  errorkw_ = NULL;
  return temp;
}
inline void FeedbackNotify::set_allocated_errorkw(::PBMidLayer::KeywordResult* errorkw) {
  delete errorkw_;
  errorkw_ = errorkw;
  if (errorkw) {
    set_has_errorkw();
  } else {
    clear_has_errorkw();
  }
}

// optional .PBMidLayer.KeywordResult rightkw = 10;
inline bool FeedbackNotify::has_rightkw() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FeedbackNotify::set_has_rightkw() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FeedbackNotify::clear_has_rightkw() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FeedbackNotify::clear_rightkw() {
  if (rightkw_ != NULL) rightkw_->::PBMidLayer::KeywordResult::Clear();
  clear_has_rightkw();
}
inline const ::PBMidLayer::KeywordResult& FeedbackNotify::rightkw() const {
  return rightkw_ != NULL ? *rightkw_ : *default_instance_->rightkw_;
}
inline ::PBMidLayer::KeywordResult* FeedbackNotify::mutable_rightkw() {
  set_has_rightkw();
  if (rightkw_ == NULL) rightkw_ = new ::PBMidLayer::KeywordResult;
  return rightkw_;
}
inline ::PBMidLayer::KeywordResult* FeedbackNotify::release_rightkw() {
  clear_has_rightkw();
  ::PBMidLayer::KeywordResult* temp = rightkw_;
  rightkw_ = NULL;
  return temp;
}
inline void FeedbackNotify::set_allocated_rightkw(::PBMidLayer::KeywordResult* rightkw) {
  delete rightkw_;
  rightkw_ = rightkw;
  if (rightkw) {
    set_has_rightkw();
  } else {
    clear_has_rightkw();
  }
}

// optional .PBMidLayer.TranscriptResult errorts = 11;
inline bool FeedbackNotify::has_errorts() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FeedbackNotify::set_has_errorts() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FeedbackNotify::clear_has_errorts() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FeedbackNotify::clear_errorts() {
  if (errorts_ != NULL) errorts_->::PBMidLayer::TranscriptResult::Clear();
  clear_has_errorts();
}
inline const ::PBMidLayer::TranscriptResult& FeedbackNotify::errorts() const {
  return errorts_ != NULL ? *errorts_ : *default_instance_->errorts_;
}
inline ::PBMidLayer::TranscriptResult* FeedbackNotify::mutable_errorts() {
  set_has_errorts();
  if (errorts_ == NULL) errorts_ = new ::PBMidLayer::TranscriptResult;
  return errorts_;
}
inline ::PBMidLayer::TranscriptResult* FeedbackNotify::release_errorts() {
  clear_has_errorts();
  ::PBMidLayer::TranscriptResult* temp = errorts_;
  errorts_ = NULL;
  return temp;
}
inline void FeedbackNotify::set_allocated_errorts(::PBMidLayer::TranscriptResult* errorts) {
  delete errorts_;
  errorts_ = errorts;
  if (errorts) {
    set_has_errorts();
  } else {
    clear_has_errorts();
  }
}

// optional .PBMidLayer.TranscriptResult rightts = 12;
inline bool FeedbackNotify::has_rightts() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FeedbackNotify::set_has_rightts() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FeedbackNotify::clear_has_rightts() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FeedbackNotify::clear_rightts() {
  if (rightts_ != NULL) rightts_->::PBMidLayer::TranscriptResult::Clear();
  clear_has_rightts();
}
inline const ::PBMidLayer::TranscriptResult& FeedbackNotify::rightts() const {
  return rightts_ != NULL ? *rightts_ : *default_instance_->rightts_;
}
inline ::PBMidLayer::TranscriptResult* FeedbackNotify::mutable_rightts() {
  set_has_rightts();
  if (rightts_ == NULL) rightts_ = new ::PBMidLayer::TranscriptResult;
  return rightts_;
}
inline ::PBMidLayer::TranscriptResult* FeedbackNotify::release_rightts() {
  clear_has_rightts();
  ::PBMidLayer::TranscriptResult* temp = rightts_;
  rightts_ = NULL;
  return temp;
}
inline void FeedbackNotify::set_allocated_rightts(::PBMidLayer::TranscriptResult* rightts) {
  delete rightts_;
  rightts_ = rightts;
  if (rightts) {
    set_has_rightts();
  } else {
    clear_has_rightts();
  }
}

// optional .PBMidLayer.VADResult rightvad = 13;
inline bool FeedbackNotify::has_rightvad() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FeedbackNotify::set_has_rightvad() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FeedbackNotify::clear_has_rightvad() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void FeedbackNotify::clear_rightvad() {
  if (rightvad_ != NULL) rightvad_->::PBMidLayer::VADResult::Clear();
  clear_has_rightvad();
}
inline const ::PBMidLayer::VADResult& FeedbackNotify::rightvad() const {
  return rightvad_ != NULL ? *rightvad_ : *default_instance_->rightvad_;
}
inline ::PBMidLayer::VADResult* FeedbackNotify::mutable_rightvad() {
  set_has_rightvad();
  if (rightvad_ == NULL) rightvad_ = new ::PBMidLayer::VADResult;
  return rightvad_;
}
inline ::PBMidLayer::VADResult* FeedbackNotify::release_rightvad() {
  clear_has_rightvad();
  ::PBMidLayer::VADResult* temp = rightvad_;
  rightvad_ = NULL;
  return temp;
}
inline void FeedbackNotify::set_allocated_rightvad(::PBMidLayer::VADResult* rightvad) {
  delete rightvad_;
  rightvad_ = rightvad;
  if (rightvad) {
    set_has_rightvad();
  } else {
    clear_has_rightvad();
  }
}

// optional .PBMidLayer.VADResult errorvad = 14;
inline bool FeedbackNotify::has_errorvad() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void FeedbackNotify::set_has_errorvad() {
  _has_bits_[0] |= 0x00002000u;
}
inline void FeedbackNotify::clear_has_errorvad() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void FeedbackNotify::clear_errorvad() {
  if (errorvad_ != NULL) errorvad_->::PBMidLayer::VADResult::Clear();
  clear_has_errorvad();
}
inline const ::PBMidLayer::VADResult& FeedbackNotify::errorvad() const {
  return errorvad_ != NULL ? *errorvad_ : *default_instance_->errorvad_;
}
inline ::PBMidLayer::VADResult* FeedbackNotify::mutable_errorvad() {
  set_has_errorvad();
  if (errorvad_ == NULL) errorvad_ = new ::PBMidLayer::VADResult;
  return errorvad_;
}
inline ::PBMidLayer::VADResult* FeedbackNotify::release_errorvad() {
  clear_has_errorvad();
  ::PBMidLayer::VADResult* temp = errorvad_;
  errorvad_ = NULL;
  return temp;
}
inline void FeedbackNotify::set_allocated_errorvad(::PBMidLayer::VADResult* errorvad) {
  delete errorvad_;
  errorvad_ = errorvad;
  if (errorvad) {
    set_has_errorvad();
  } else {
    clear_has_errorvad();
  }
}

// optional .PBMidLayer.SpeechSegResult rightss = 15;
inline bool FeedbackNotify::has_rightss() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void FeedbackNotify::set_has_rightss() {
  _has_bits_[0] |= 0x00004000u;
}
inline void FeedbackNotify::clear_has_rightss() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void FeedbackNotify::clear_rightss() {
  if (rightss_ != NULL) rightss_->::PBMidLayer::SpeechSegResult::Clear();
  clear_has_rightss();
}
inline const ::PBMidLayer::SpeechSegResult& FeedbackNotify::rightss() const {
  return rightss_ != NULL ? *rightss_ : *default_instance_->rightss_;
}
inline ::PBMidLayer::SpeechSegResult* FeedbackNotify::mutable_rightss() {
  set_has_rightss();
  if (rightss_ == NULL) rightss_ = new ::PBMidLayer::SpeechSegResult;
  return rightss_;
}
inline ::PBMidLayer::SpeechSegResult* FeedbackNotify::release_rightss() {
  clear_has_rightss();
  ::PBMidLayer::SpeechSegResult* temp = rightss_;
  rightss_ = NULL;
  return temp;
}
inline void FeedbackNotify::set_allocated_rightss(::PBMidLayer::SpeechSegResult* rightss) {
  delete rightss_;
  rightss_ = rightss;
  if (rightss) {
    set_has_rightss();
  } else {
    clear_has_rightss();
  }
}

// optional .PBMidLayer.SpeechSegResult errorss = 16;
inline bool FeedbackNotify::has_errorss() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void FeedbackNotify::set_has_errorss() {
  _has_bits_[0] |= 0x00008000u;
}
inline void FeedbackNotify::clear_has_errorss() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void FeedbackNotify::clear_errorss() {
  if (errorss_ != NULL) errorss_->::PBMidLayer::SpeechSegResult::Clear();
  clear_has_errorss();
}
inline const ::PBMidLayer::SpeechSegResult& FeedbackNotify::errorss() const {
  return errorss_ != NULL ? *errorss_ : *default_instance_->errorss_;
}
inline ::PBMidLayer::SpeechSegResult* FeedbackNotify::mutable_errorss() {
  set_has_errorss();
  if (errorss_ == NULL) errorss_ = new ::PBMidLayer::SpeechSegResult;
  return errorss_;
}
inline ::PBMidLayer::SpeechSegResult* FeedbackNotify::release_errorss() {
  clear_has_errorss();
  ::PBMidLayer::SpeechSegResult* temp = errorss_;
  errorss_ = NULL;
  return temp;
}
inline void FeedbackNotify::set_allocated_errorss(::PBMidLayer::SpeechSegResult* errorss) {
  delete errorss_;
  errorss_ = errorss;
  if (errorss) {
    set_has_errorss();
  } else {
    clear_has_errorss();
  }
}

// optional .PBMidLayer.DTMFResult rightdtmf = 17;
inline bool FeedbackNotify::has_rightdtmf() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void FeedbackNotify::set_has_rightdtmf() {
  _has_bits_[0] |= 0x00010000u;
}
inline void FeedbackNotify::clear_has_rightdtmf() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void FeedbackNotify::clear_rightdtmf() {
  if (rightdtmf_ != NULL) rightdtmf_->::PBMidLayer::DTMFResult::Clear();
  clear_has_rightdtmf();
}
inline const ::PBMidLayer::DTMFResult& FeedbackNotify::rightdtmf() const {
  return rightdtmf_ != NULL ? *rightdtmf_ : *default_instance_->rightdtmf_;
}
inline ::PBMidLayer::DTMFResult* FeedbackNotify::mutable_rightdtmf() {
  set_has_rightdtmf();
  if (rightdtmf_ == NULL) rightdtmf_ = new ::PBMidLayer::DTMFResult;
  return rightdtmf_;
}
inline ::PBMidLayer::DTMFResult* FeedbackNotify::release_rightdtmf() {
  clear_has_rightdtmf();
  ::PBMidLayer::DTMFResult* temp = rightdtmf_;
  rightdtmf_ = NULL;
  return temp;
}
inline void FeedbackNotify::set_allocated_rightdtmf(::PBMidLayer::DTMFResult* rightdtmf) {
  delete rightdtmf_;
  rightdtmf_ = rightdtmf;
  if (rightdtmf) {
    set_has_rightdtmf();
  } else {
    clear_has_rightdtmf();
  }
}

// optional .PBMidLayer.DTMFResult errordtmf = 18;
inline bool FeedbackNotify::has_errordtmf() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void FeedbackNotify::set_has_errordtmf() {
  _has_bits_[0] |= 0x00020000u;
}
inline void FeedbackNotify::clear_has_errordtmf() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void FeedbackNotify::clear_errordtmf() {
  if (errordtmf_ != NULL) errordtmf_->::PBMidLayer::DTMFResult::Clear();
  clear_has_errordtmf();
}
inline const ::PBMidLayer::DTMFResult& FeedbackNotify::errordtmf() const {
  return errordtmf_ != NULL ? *errordtmf_ : *default_instance_->errordtmf_;
}
inline ::PBMidLayer::DTMFResult* FeedbackNotify::mutable_errordtmf() {
  set_has_errordtmf();
  if (errordtmf_ == NULL) errordtmf_ = new ::PBMidLayer::DTMFResult;
  return errordtmf_;
}
inline ::PBMidLayer::DTMFResult* FeedbackNotify::release_errordtmf() {
  clear_has_errordtmf();
  ::PBMidLayer::DTMFResult* temp = errordtmf_;
  errordtmf_ = NULL;
  return temp;
}
inline void FeedbackNotify::set_allocated_errordtmf(::PBMidLayer::DTMFResult* errordtmf) {
  delete errordtmf_;
  errordtmf_ = errordtmf;
  if (errordtmf) {
    set_has_errordtmf();
  } else {
    clear_has_errordtmf();
  }
}

// optional .PBMidLayer.SystemCode syscode = 19;
inline bool FeedbackNotify::has_syscode() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void FeedbackNotify::set_has_syscode() {
  _has_bits_[0] |= 0x00040000u;
}
inline void FeedbackNotify::clear_has_syscode() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void FeedbackNotify::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& FeedbackNotify::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* FeedbackNotify::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* FeedbackNotify::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void FeedbackNotify::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// SearchRequest

// required string taskid = 1;
inline bool SearchRequest::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchRequest::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchRequest::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchRequest::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& SearchRequest::taskid() const {
  return *taskid_;
}
inline void SearchRequest::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SearchRequest::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SearchRequest::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchRequest::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* SearchRequest::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchRequest::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.SystemCode syscode = 2;
inline bool SearchRequest::has_syscode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchRequest::set_has_syscode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchRequest::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchRequest::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& SearchRequest::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* SearchRequest::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* SearchRequest::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void SearchRequest::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// required int32 maxresult = 3;
inline bool SearchRequest::has_maxresult() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchRequest::set_has_maxresult() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchRequest::clear_has_maxresult() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchRequest::clear_maxresult() {
  maxresult_ = 0;
  clear_has_maxresult();
}
inline ::google::protobuf::int32 SearchRequest::maxresult() const {
  return maxresult_;
}
inline void SearchRequest::set_maxresult(::google::protobuf::int32 value) {
  set_has_maxresult();
  maxresult_ = value;
}

// required .PBMidLayer.SearchTaskType tasktype = 4;
inline bool SearchRequest::has_tasktype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SearchRequest::set_has_tasktype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SearchRequest::clear_has_tasktype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SearchRequest::clear_tasktype() {
  tasktype_ = 0;
  clear_has_tasktype();
}
inline ::PBMidLayer::SearchTaskType SearchRequest::tasktype() const {
  return static_cast< ::PBMidLayer::SearchTaskType >(tasktype_);
}
inline void SearchRequest::set_tasktype(::PBMidLayer::SearchTaskType value) {
  assert(::PBMidLayer::SearchTaskType_IsValid(value));
  set_has_tasktype();
  tasktype_ = value;
}

// optional .PBMidLayer.GenderType gender = 5;
inline bool SearchRequest::has_gender() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SearchRequest::set_has_gender() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SearchRequest::clear_has_gender() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SearchRequest::clear_gender() {
  gender_ = 0;
  clear_has_gender();
}
inline ::PBMidLayer::GenderType SearchRequest::gender() const {
  return static_cast< ::PBMidLayer::GenderType >(gender_);
}
inline void SearchRequest::set_gender(::PBMidLayer::GenderType value) {
  assert(::PBMidLayer::GenderType_IsValid(value));
  set_has_gender();
  gender_ = value;
}

// optional uint64 starttime = 6;
inline bool SearchRequest::has_starttime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SearchRequest::set_has_starttime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SearchRequest::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SearchRequest::clear_starttime() {
  starttime_ = GOOGLE_ULONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::uint64 SearchRequest::starttime() const {
  return starttime_;
}
inline void SearchRequest::set_starttime(::google::protobuf::uint64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional uint64 endtime = 7;
inline bool SearchRequest::has_endtime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SearchRequest::set_has_endtime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SearchRequest::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SearchRequest::clear_endtime() {
  endtime_ = GOOGLE_ULONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::uint64 SearchRequest::endtime() const {
  return endtime_;
}
inline void SearchRequest::set_endtime(::google::protobuf::uint64 value) {
  set_has_endtime();
  endtime_ = value;
}

// repeated .PBMidLayer.PhoneNumber telpattern = 8;
inline int SearchRequest::telpattern_size() const {
  return telpattern_.size();
}
inline void SearchRequest::clear_telpattern() {
  telpattern_.Clear();
}
inline const ::PBMidLayer::PhoneNumber& SearchRequest::telpattern(int index) const {
  return telpattern_.Get(index);
}
inline ::PBMidLayer::PhoneNumber* SearchRequest::mutable_telpattern(int index) {
  return telpattern_.Mutable(index);
}
inline ::PBMidLayer::PhoneNumber* SearchRequest::add_telpattern() {
  return telpattern_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber >&
SearchRequest::telpattern() const {
  return telpattern_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber >*
SearchRequest::mutable_telpattern() {
  return &telpattern_;
}

// optional string lang = 9;
inline bool SearchRequest::has_lang() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SearchRequest::set_has_lang() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SearchRequest::clear_has_lang() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SearchRequest::clear_lang() {
  if (lang_ != &::google::protobuf::internal::kEmptyString) {
    lang_->clear();
  }
  clear_has_lang();
}
inline const ::std::string& SearchRequest::lang() const {
  return *lang_;
}
inline void SearchRequest::set_lang(const ::std::string& value) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    lang_ = new ::std::string;
  }
  lang_->assign(value);
}
inline void SearchRequest::set_lang(const char* value) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    lang_ = new ::std::string;
  }
  lang_->assign(value);
}
inline void SearchRequest::set_lang(const char* value, size_t size) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    lang_ = new ::std::string;
  }
  lang_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchRequest::mutable_lang() {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    lang_ = new ::std::string;
  }
  return lang_;
}
inline ::std::string* SearchRequest::release_lang() {
  clear_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lang_;
    lang_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchRequest::set_allocated_lang(::std::string* lang) {
  if (lang_ != &::google::protobuf::internal::kEmptyString) {
    delete lang_;
  }
  if (lang) {
    set_has_lang();
    lang_ = lang;
  } else {
    clear_has_lang();
    lang_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .PBMidLayer.KeywordRule keywords = 10;
inline int SearchRequest::keywords_size() const {
  return keywords_.size();
}
inline void SearchRequest::clear_keywords() {
  keywords_.Clear();
}
inline const ::PBMidLayer::KeywordRule& SearchRequest::keywords(int index) const {
  return keywords_.Get(index);
}
inline ::PBMidLayer::KeywordRule* SearchRequest::mutable_keywords(int index) {
  return keywords_.Mutable(index);
}
inline ::PBMidLayer::KeywordRule* SearchRequest::add_keywords() {
  return keywords_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordRule >&
SearchRequest::keywords() const {
  return keywords_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordRule >*
SearchRequest::mutable_keywords() {
  return &keywords_;
}

// repeated .PBMidLayer.SpeechSegRule speechseg = 11;
inline int SearchRequest::speechseg_size() const {
  return speechseg_.size();
}
inline void SearchRequest::clear_speechseg() {
  speechseg_.Clear();
}
inline const ::PBMidLayer::SpeechSegRule& SearchRequest::speechseg(int index) const {
  return speechseg_.Get(index);
}
inline ::PBMidLayer::SpeechSegRule* SearchRequest::mutable_speechseg(int index) {
  return speechseg_.Mutable(index);
}
inline ::PBMidLayer::SpeechSegRule* SearchRequest::add_speechseg() {
  return speechseg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegRule >&
SearchRequest::speechseg() const {
  return speechseg_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegRule >*
SearchRequest::mutable_speechseg() {
  return &speechseg_;
}

// repeated .PBMidLayer.SpeakerRule speakers = 12;
inline int SearchRequest::speakers_size() const {
  return speakers_.size();
}
inline void SearchRequest::clear_speakers() {
  speakers_.Clear();
}
inline const ::PBMidLayer::SpeakerRule& SearchRequest::speakers(int index) const {
  return speakers_.Get(index);
}
inline ::PBMidLayer::SpeakerRule* SearchRequest::mutable_speakers(int index) {
  return speakers_.Mutable(index);
}
inline ::PBMidLayer::SpeakerRule* SearchRequest::add_speakers() {
  return speakers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerRule >&
SearchRequest::speakers() const {
  return speakers_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerRule >*
SearchRequest::mutable_speakers() {
  return &speakers_;
}

// optional bytes voice = 13;
inline bool SearchRequest::has_voice() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SearchRequest::set_has_voice() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SearchRequest::clear_has_voice() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SearchRequest::clear_voice() {
  if (voice_ != &::google::protobuf::internal::kEmptyString) {
    voice_->clear();
  }
  clear_has_voice();
}
inline const ::std::string& SearchRequest::voice() const {
  return *voice_;
}
inline void SearchRequest::set_voice(const ::std::string& value) {
  set_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    voice_ = new ::std::string;
  }
  voice_->assign(value);
}
inline void SearchRequest::set_voice(const char* value) {
  set_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    voice_ = new ::std::string;
  }
  voice_->assign(value);
}
inline void SearchRequest::set_voice(const void* value, size_t size) {
  set_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    voice_ = new ::std::string;
  }
  voice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchRequest::mutable_voice() {
  set_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    voice_ = new ::std::string;
  }
  return voice_;
}
inline ::std::string* SearchRequest::release_voice() {
  clear_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = voice_;
    voice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchRequest::set_allocated_voice(::std::string* voice) {
  if (voice_ != &::google::protobuf::internal::kEmptyString) {
    delete voice_;
  }
  if (voice) {
    set_has_voice();
    voice_ = voice;
  } else {
    clear_has_voice();
    voice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string calllist = 14;
inline int SearchRequest::calllist_size() const {
  return calllist_.size();
}
inline void SearchRequest::clear_calllist() {
  calllist_.Clear();
}
inline const ::std::string& SearchRequest::calllist(int index) const {
  return calllist_.Get(index);
}
inline ::std::string* SearchRequest::mutable_calllist(int index) {
  return calllist_.Mutable(index);
}
inline void SearchRequest::set_calllist(int index, const ::std::string& value) {
  calllist_.Mutable(index)->assign(value);
}
inline void SearchRequest::set_calllist(int index, const char* value) {
  calllist_.Mutable(index)->assign(value);
}
inline void SearchRequest::set_calllist(int index, const char* value, size_t size) {
  calllist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchRequest::add_calllist() {
  return calllist_.Add();
}
inline void SearchRequest::add_calllist(const ::std::string& value) {
  calllist_.Add()->assign(value);
}
inline void SearchRequest::add_calllist(const char* value) {
  calllist_.Add()->assign(value);
}
inline void SearchRequest::add_calllist(const char* value, size_t size) {
  calllist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SearchRequest::calllist() const {
  return calllist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SearchRequest::mutable_calllist() {
  return &calllist_;
}

// -------------------------------------------------------------------

// SearchAbortRequest

// required string taskid = 1;
inline bool SearchAbortRequest::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchAbortRequest::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchAbortRequest::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchAbortRequest::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& SearchAbortRequest::taskid() const {
  return *taskid_;
}
inline void SearchAbortRequest::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SearchAbortRequest::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SearchAbortRequest::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchAbortRequest::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* SearchAbortRequest::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchAbortRequest::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.SystemCode syscode = 2;
inline bool SearchAbortRequest::has_syscode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchAbortRequest::set_has_syscode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchAbortRequest::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchAbortRequest::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& SearchAbortRequest::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* SearchAbortRequest::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* SearchAbortRequest::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void SearchAbortRequest::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// required string aborttaskid = 3;
inline bool SearchAbortRequest::has_aborttaskid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchAbortRequest::set_has_aborttaskid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchAbortRequest::clear_has_aborttaskid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchAbortRequest::clear_aborttaskid() {
  if (aborttaskid_ != &::google::protobuf::internal::kEmptyString) {
    aborttaskid_->clear();
  }
  clear_has_aborttaskid();
}
inline const ::std::string& SearchAbortRequest::aborttaskid() const {
  return *aborttaskid_;
}
inline void SearchAbortRequest::set_aborttaskid(const ::std::string& value) {
  set_has_aborttaskid();
  if (aborttaskid_ == &::google::protobuf::internal::kEmptyString) {
    aborttaskid_ = new ::std::string;
  }
  aborttaskid_->assign(value);
}
inline void SearchAbortRequest::set_aborttaskid(const char* value) {
  set_has_aborttaskid();
  if (aborttaskid_ == &::google::protobuf::internal::kEmptyString) {
    aborttaskid_ = new ::std::string;
  }
  aborttaskid_->assign(value);
}
inline void SearchAbortRequest::set_aborttaskid(const char* value, size_t size) {
  set_has_aborttaskid();
  if (aborttaskid_ == &::google::protobuf::internal::kEmptyString) {
    aborttaskid_ = new ::std::string;
  }
  aborttaskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchAbortRequest::mutable_aborttaskid() {
  set_has_aborttaskid();
  if (aborttaskid_ == &::google::protobuf::internal::kEmptyString) {
    aborttaskid_ = new ::std::string;
  }
  return aborttaskid_;
}
inline ::std::string* SearchAbortRequest::release_aborttaskid() {
  clear_has_aborttaskid();
  if (aborttaskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = aborttaskid_;
    aborttaskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchAbortRequest::set_allocated_aborttaskid(::std::string* aborttaskid) {
  if (aborttaskid_ != &::google::protobuf::internal::kEmptyString) {
    delete aborttaskid_;
  }
  if (aborttaskid) {
    set_has_aborttaskid();
    aborttaskid_ = aborttaskid;
  } else {
    clear_has_aborttaskid();
    aborttaskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SearchResultNotify

// required string taskid = 1;
inline bool SearchResultNotify::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchResultNotify::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchResultNotify::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchResultNotify::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& SearchResultNotify::taskid() const {
  return *taskid_;
}
inline void SearchResultNotify::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SearchResultNotify::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SearchResultNotify::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchResultNotify::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* SearchResultNotify::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchResultNotify::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.SystemCode syscode = 2;
inline bool SearchResultNotify::has_syscode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchResultNotify::set_has_syscode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchResultNotify::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchResultNotify::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& SearchResultNotify::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* SearchResultNotify::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* SearchResultNotify::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void SearchResultNotify::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// required .PBMidLayer.OperationStatus status = 3;
inline bool SearchResultNotify::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchResultNotify::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchResultNotify::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchResultNotify::clear_status() {
  if (status_ != NULL) status_->::PBMidLayer::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBMidLayer::OperationStatus& SearchResultNotify::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBMidLayer::OperationStatus* SearchResultNotify::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBMidLayer::OperationStatus;
  return status_;
}
inline ::PBMidLayer::OperationStatus* SearchResultNotify::release_status() {
  clear_has_status();
  ::PBMidLayer::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void SearchResultNotify::set_allocated_status(::PBMidLayer::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// optional .PBMidLayer.SearchTaskType tasktype = 4;
inline bool SearchResultNotify::has_tasktype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SearchResultNotify::set_has_tasktype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SearchResultNotify::clear_has_tasktype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SearchResultNotify::clear_tasktype() {
  tasktype_ = 0;
  clear_has_tasktype();
}
inline ::PBMidLayer::SearchTaskType SearchResultNotify::tasktype() const {
  return static_cast< ::PBMidLayer::SearchTaskType >(tasktype_);
}
inline void SearchResultNotify::set_tasktype(::PBMidLayer::SearchTaskType value) {
  assert(::PBMidLayer::SearchTaskType_IsValid(value));
  set_has_tasktype();
  tasktype_ = value;
}

// repeated .PBMidLayer.SearchFileResult voices = 5;
inline int SearchResultNotify::voices_size() const {
  return voices_.size();
}
inline void SearchResultNotify::clear_voices() {
  voices_.Clear();
}
inline const ::PBMidLayer::SearchFileResult& SearchResultNotify::voices(int index) const {
  return voices_.Get(index);
}
inline ::PBMidLayer::SearchFileResult* SearchResultNotify::mutable_voices(int index) {
  return voices_.Mutable(index);
}
inline ::PBMidLayer::SearchFileResult* SearchResultNotify::add_voices() {
  return voices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SearchFileResult >&
SearchResultNotify::voices() const {
  return voices_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SearchFileResult >*
SearchResultNotify::mutable_voices() {
  return &voices_;
}

// repeated .PBMidLayer.SpeakerItem speakers = 6;
inline int SearchResultNotify::speakers_size() const {
  return speakers_.size();
}
inline void SearchResultNotify::clear_speakers() {
  speakers_.Clear();
}
inline const ::PBMidLayer::SpeakerItem& SearchResultNotify::speakers(int index) const {
  return speakers_.Get(index);
}
inline ::PBMidLayer::SpeakerItem* SearchResultNotify::mutable_speakers(int index) {
  return speakers_.Mutable(index);
}
inline ::PBMidLayer::SpeakerItem* SearchResultNotify::add_speakers() {
  return speakers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerItem >&
SearchResultNotify::speakers() const {
  return speakers_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerItem >*
SearchResultNotify::mutable_speakers() {
  return &speakers_;
}

// -------------------------------------------------------------------

// SearchResponse

// required string taskid = 1;
inline bool SearchResponse::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchResponse::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchResponse::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchResponse::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& SearchResponse::taskid() const {
  return *taskid_;
}
inline void SearchResponse::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SearchResponse::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SearchResponse::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchResponse::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* SearchResponse::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchResponse::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.SystemCode syscode = 2;
inline bool SearchResponse::has_syscode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchResponse::set_has_syscode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchResponse::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchResponse::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& SearchResponse::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* SearchResponse::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* SearchResponse::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void SearchResponse::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// required .PBMidLayer.OperationStatus status = 3;
inline bool SearchResponse::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchResponse::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchResponse::clear_status() {
  if (status_ != NULL) status_->::PBMidLayer::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBMidLayer::OperationStatus& SearchResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBMidLayer::OperationStatus* SearchResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBMidLayer::OperationStatus;
  return status_;
}
inline ::PBMidLayer::OperationStatus* SearchResponse::release_status() {
  clear_has_status();
  ::PBMidLayer::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void SearchResponse::set_allocated_status(::PBMidLayer::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// -------------------------------------------------------------------

// SearchStateRequest

// required string operid = 1;
inline bool SearchStateRequest::has_operid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchStateRequest::set_has_operid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchStateRequest::clear_has_operid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchStateRequest::clear_operid() {
  if (operid_ != &::google::protobuf::internal::kEmptyString) {
    operid_->clear();
  }
  clear_has_operid();
}
inline const ::std::string& SearchStateRequest::operid() const {
  return *operid_;
}
inline void SearchStateRequest::set_operid(const ::std::string& value) {
  set_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    operid_ = new ::std::string;
  }
  operid_->assign(value);
}
inline void SearchStateRequest::set_operid(const char* value) {
  set_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    operid_ = new ::std::string;
  }
  operid_->assign(value);
}
inline void SearchStateRequest::set_operid(const char* value, size_t size) {
  set_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    operid_ = new ::std::string;
  }
  operid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchStateRequest::mutable_operid() {
  set_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    operid_ = new ::std::string;
  }
  return operid_;
}
inline ::std::string* SearchStateRequest::release_operid() {
  clear_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operid_;
    operid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchStateRequest::set_allocated_operid(::std::string* operid) {
  if (operid_ != &::google::protobuf::internal::kEmptyString) {
    delete operid_;
  }
  if (operid) {
    set_has_operid();
    operid_ = operid;
  } else {
    clear_has_operid();
    operid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.SystemCode syscode = 2;
inline bool SearchStateRequest::has_syscode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchStateRequest::set_has_syscode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchStateRequest::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchStateRequest::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& SearchStateRequest::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* SearchStateRequest::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* SearchStateRequest::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void SearchStateRequest::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// required string requesttaskid = 3;
inline bool SearchStateRequest::has_requesttaskid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchStateRequest::set_has_requesttaskid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchStateRequest::clear_has_requesttaskid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchStateRequest::clear_requesttaskid() {
  if (requesttaskid_ != &::google::protobuf::internal::kEmptyString) {
    requesttaskid_->clear();
  }
  clear_has_requesttaskid();
}
inline const ::std::string& SearchStateRequest::requesttaskid() const {
  return *requesttaskid_;
}
inline void SearchStateRequest::set_requesttaskid(const ::std::string& value) {
  set_has_requesttaskid();
  if (requesttaskid_ == &::google::protobuf::internal::kEmptyString) {
    requesttaskid_ = new ::std::string;
  }
  requesttaskid_->assign(value);
}
inline void SearchStateRequest::set_requesttaskid(const char* value) {
  set_has_requesttaskid();
  if (requesttaskid_ == &::google::protobuf::internal::kEmptyString) {
    requesttaskid_ = new ::std::string;
  }
  requesttaskid_->assign(value);
}
inline void SearchStateRequest::set_requesttaskid(const char* value, size_t size) {
  set_has_requesttaskid();
  if (requesttaskid_ == &::google::protobuf::internal::kEmptyString) {
    requesttaskid_ = new ::std::string;
  }
  requesttaskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchStateRequest::mutable_requesttaskid() {
  set_has_requesttaskid();
  if (requesttaskid_ == &::google::protobuf::internal::kEmptyString) {
    requesttaskid_ = new ::std::string;
  }
  return requesttaskid_;
}
inline ::std::string* SearchStateRequest::release_requesttaskid() {
  clear_has_requesttaskid();
  if (requesttaskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = requesttaskid_;
    requesttaskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchStateRequest::set_allocated_requesttaskid(::std::string* requesttaskid) {
  if (requesttaskid_ != &::google::protobuf::internal::kEmptyString) {
    delete requesttaskid_;
  }
  if (requesttaskid) {
    set_has_requesttaskid();
    requesttaskid_ = requesttaskid;
  } else {
    clear_has_requesttaskid();
    requesttaskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SearchStateResponse

// required string operid = 1;
inline bool SearchStateResponse::has_operid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchStateResponse::set_has_operid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchStateResponse::clear_has_operid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchStateResponse::clear_operid() {
  if (operid_ != &::google::protobuf::internal::kEmptyString) {
    operid_->clear();
  }
  clear_has_operid();
}
inline const ::std::string& SearchStateResponse::operid() const {
  return *operid_;
}
inline void SearchStateResponse::set_operid(const ::std::string& value) {
  set_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    operid_ = new ::std::string;
  }
  operid_->assign(value);
}
inline void SearchStateResponse::set_operid(const char* value) {
  set_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    operid_ = new ::std::string;
  }
  operid_->assign(value);
}
inline void SearchStateResponse::set_operid(const char* value, size_t size) {
  set_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    operid_ = new ::std::string;
  }
  operid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchStateResponse::mutable_operid() {
  set_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    operid_ = new ::std::string;
  }
  return operid_;
}
inline ::std::string* SearchStateResponse::release_operid() {
  clear_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operid_;
    operid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchStateResponse::set_allocated_operid(::std::string* operid) {
  if (operid_ != &::google::protobuf::internal::kEmptyString) {
    delete operid_;
  }
  if (operid) {
    set_has_operid();
    operid_ = operid;
  } else {
    clear_has_operid();
    operid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.SystemCode syscode = 2;
inline bool SearchStateResponse::has_syscode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchStateResponse::set_has_syscode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchStateResponse::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchStateResponse::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& SearchStateResponse::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* SearchStateResponse::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* SearchStateResponse::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void SearchStateResponse::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// required .PBMidLayer.OperationStatus status = 3;
inline bool SearchStateResponse::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchStateResponse::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchStateResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchStateResponse::clear_status() {
  if (status_ != NULL) status_->::PBMidLayer::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBMidLayer::OperationStatus& SearchStateResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBMidLayer::OperationStatus* SearchStateResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBMidLayer::OperationStatus;
  return status_;
}
inline ::PBMidLayer::OperationStatus* SearchStateResponse::release_status() {
  clear_has_status();
  ::PBMidLayer::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void SearchStateResponse::set_allocated_status(::PBMidLayer::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// required .PBMidLayer.SearchTaskState state = 4;
inline bool SearchStateResponse::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SearchStateResponse::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SearchStateResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SearchStateResponse::clear_state() {
  if (state_ != NULL) state_->::PBMidLayer::SearchTaskState::Clear();
  clear_has_state();
}
inline const ::PBMidLayer::SearchTaskState& SearchStateResponse::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::PBMidLayer::SearchTaskState* SearchStateResponse::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::PBMidLayer::SearchTaskState;
  return state_;
}
inline ::PBMidLayer::SearchTaskState* SearchStateResponse::release_state() {
  clear_has_state();
  ::PBMidLayer::SearchTaskState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void SearchStateResponse::set_allocated_state(::PBMidLayer::SearchTaskState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// -------------------------------------------------------------------

// GetFileRequest

// required string operid = 1;
inline bool GetFileRequest::has_operid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFileRequest::set_has_operid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFileRequest::clear_has_operid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFileRequest::clear_operid() {
  if (operid_ != &::google::protobuf::internal::kEmptyString) {
    operid_->clear();
  }
  clear_has_operid();
}
inline const ::std::string& GetFileRequest::operid() const {
  return *operid_;
}
inline void GetFileRequest::set_operid(const ::std::string& value) {
  set_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    operid_ = new ::std::string;
  }
  operid_->assign(value);
}
inline void GetFileRequest::set_operid(const char* value) {
  set_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    operid_ = new ::std::string;
  }
  operid_->assign(value);
}
inline void GetFileRequest::set_operid(const char* value, size_t size) {
  set_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    operid_ = new ::std::string;
  }
  operid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetFileRequest::mutable_operid() {
  set_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    operid_ = new ::std::string;
  }
  return operid_;
}
inline ::std::string* GetFileRequest::release_operid() {
  clear_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operid_;
    operid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetFileRequest::set_allocated_operid(::std::string* operid) {
  if (operid_ != &::google::protobuf::internal::kEmptyString) {
    delete operid_;
  }
  if (operid) {
    set_has_operid();
    operid_ = operid;
  } else {
    clear_has_operid();
    operid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.SystemCode syscode = 2;
inline bool GetFileRequest::has_syscode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetFileRequest::set_has_syscode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetFileRequest::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetFileRequest::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& GetFileRequest::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* GetFileRequest::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* GetFileRequest::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void GetFileRequest::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// required string callid = 3;
inline bool GetFileRequest::has_callid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetFileRequest::set_has_callid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetFileRequest::clear_has_callid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetFileRequest::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& GetFileRequest::callid() const {
  return *callid_;
}
inline void GetFileRequest::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void GetFileRequest::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void GetFileRequest::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetFileRequest::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* GetFileRequest::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetFileRequest::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.AudioFileTag filetag = 4;
inline bool GetFileRequest::has_filetag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetFileRequest::set_has_filetag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetFileRequest::clear_has_filetag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetFileRequest::clear_filetag() {
  filetag_ = 0;
  clear_has_filetag();
}
inline ::PBMidLayer::AudioFileTag GetFileRequest::filetag() const {
  return static_cast< ::PBMidLayer::AudioFileTag >(filetag_);
}
inline void GetFileRequest::set_filetag(::PBMidLayer::AudioFileTag value) {
  assert(::PBMidLayer::AudioFileTag_IsValid(value));
  set_has_filetag();
  filetag_ = value;
}

// -------------------------------------------------------------------

// GetFileResponse

// required string operid = 1;
inline bool GetFileResponse::has_operid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFileResponse::set_has_operid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFileResponse::clear_has_operid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFileResponse::clear_operid() {
  if (operid_ != &::google::protobuf::internal::kEmptyString) {
    operid_->clear();
  }
  clear_has_operid();
}
inline const ::std::string& GetFileResponse::operid() const {
  return *operid_;
}
inline void GetFileResponse::set_operid(const ::std::string& value) {
  set_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    operid_ = new ::std::string;
  }
  operid_->assign(value);
}
inline void GetFileResponse::set_operid(const char* value) {
  set_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    operid_ = new ::std::string;
  }
  operid_->assign(value);
}
inline void GetFileResponse::set_operid(const char* value, size_t size) {
  set_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    operid_ = new ::std::string;
  }
  operid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetFileResponse::mutable_operid() {
  set_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    operid_ = new ::std::string;
  }
  return operid_;
}
inline ::std::string* GetFileResponse::release_operid() {
  clear_has_operid();
  if (operid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operid_;
    operid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetFileResponse::set_allocated_operid(::std::string* operid) {
  if (operid_ != &::google::protobuf::internal::kEmptyString) {
    delete operid_;
  }
  if (operid) {
    set_has_operid();
    operid_ = operid;
  } else {
    clear_has_operid();
    operid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.SystemCode syscode = 2;
inline bool GetFileResponse::has_syscode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetFileResponse::set_has_syscode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetFileResponse::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetFileResponse::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& GetFileResponse::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* GetFileResponse::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* GetFileResponse::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void GetFileResponse::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// required bool isdata = 3;
inline bool GetFileResponse::has_isdata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetFileResponse::set_has_isdata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetFileResponse::clear_has_isdata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetFileResponse::clear_isdata() {
  isdata_ = false;
  clear_has_isdata();
}
inline bool GetFileResponse::isdata() const {
  return isdata_;
}
inline void GetFileResponse::set_isdata(bool value) {
  set_has_isdata();
  isdata_ = value;
}

// optional .PBMidLayer.FileLocationNotify filelocation = 4;
inline bool GetFileResponse::has_filelocation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetFileResponse::set_has_filelocation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetFileResponse::clear_has_filelocation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetFileResponse::clear_filelocation() {
  if (filelocation_ != NULL) filelocation_->::PBMidLayer::FileLocationNotify::Clear();
  clear_has_filelocation();
}
inline const ::PBMidLayer::FileLocationNotify& GetFileResponse::filelocation() const {
  return filelocation_ != NULL ? *filelocation_ : *default_instance_->filelocation_;
}
inline ::PBMidLayer::FileLocationNotify* GetFileResponse::mutable_filelocation() {
  set_has_filelocation();
  if (filelocation_ == NULL) filelocation_ = new ::PBMidLayer::FileLocationNotify;
  return filelocation_;
}
inline ::PBMidLayer::FileLocationNotify* GetFileResponse::release_filelocation() {
  clear_has_filelocation();
  ::PBMidLayer::FileLocationNotify* temp = filelocation_;
  filelocation_ = NULL;
  return temp;
}
inline void GetFileResponse::set_allocated_filelocation(::PBMidLayer::FileLocationNotify* filelocation) {
  delete filelocation_;
  filelocation_ = filelocation;
  if (filelocation) {
    set_has_filelocation();
  } else {
    clear_has_filelocation();
  }
}

// optional .PBMidLayer.FileDataNotify filedata = 5;
inline bool GetFileResponse::has_filedata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetFileResponse::set_has_filedata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetFileResponse::clear_has_filedata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetFileResponse::clear_filedata() {
  if (filedata_ != NULL) filedata_->::PBMidLayer::FileDataNotify::Clear();
  clear_has_filedata();
}
inline const ::PBMidLayer::FileDataNotify& GetFileResponse::filedata() const {
  return filedata_ != NULL ? *filedata_ : *default_instance_->filedata_;
}
inline ::PBMidLayer::FileDataNotify* GetFileResponse::mutable_filedata() {
  set_has_filedata();
  if (filedata_ == NULL) filedata_ = new ::PBMidLayer::FileDataNotify;
  return filedata_;
}
inline ::PBMidLayer::FileDataNotify* GetFileResponse::release_filedata() {
  clear_has_filedata();
  ::PBMidLayer::FileDataNotify* temp = filedata_;
  filedata_ = NULL;
  return temp;
}
inline void GetFileResponse::set_allocated_filedata(::PBMidLayer::FileDataNotify* filedata) {
  delete filedata_;
  filedata_ = filedata;
  if (filedata) {
    set_has_filedata();
  } else {
    clear_has_filedata();
  }
}

// -------------------------------------------------------------------

// AddLangSampRequest

// required string taskid = 1;
inline bool AddLangSampRequest::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddLangSampRequest::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddLangSampRequest::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddLangSampRequest::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& AddLangSampRequest::taskid() const {
  return *taskid_;
}
inline void AddLangSampRequest::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void AddLangSampRequest::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void AddLangSampRequest::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddLangSampRequest::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* AddLangSampRequest::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddLangSampRequest::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.SystemCode syscode = 2;
inline bool AddLangSampRequest::has_syscode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddLangSampRequest::set_has_syscode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddLangSampRequest::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddLangSampRequest::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& AddLangSampRequest::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* AddLangSampRequest::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* AddLangSampRequest::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void AddLangSampRequest::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// required string lang = 3;
inline bool AddLangSampRequest::has_lang() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddLangSampRequest::set_has_lang() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddLangSampRequest::clear_has_lang() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddLangSampRequest::clear_lang() {
  if (lang_ != &::google::protobuf::internal::kEmptyString) {
    lang_->clear();
  }
  clear_has_lang();
}
inline const ::std::string& AddLangSampRequest::lang() const {
  return *lang_;
}
inline void AddLangSampRequest::set_lang(const ::std::string& value) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    lang_ = new ::std::string;
  }
  lang_->assign(value);
}
inline void AddLangSampRequest::set_lang(const char* value) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    lang_ = new ::std::string;
  }
  lang_->assign(value);
}
inline void AddLangSampRequest::set_lang(const char* value, size_t size) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    lang_ = new ::std::string;
  }
  lang_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddLangSampRequest::mutable_lang() {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    lang_ = new ::std::string;
  }
  return lang_;
}
inline ::std::string* AddLangSampRequest::release_lang() {
  clear_has_lang();
  if (lang_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lang_;
    lang_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddLangSampRequest::set_allocated_lang(::std::string* lang) {
  if (lang_ != &::google::protobuf::internal::kEmptyString) {
    delete lang_;
  }
  if (lang) {
    set_has_lang();
    lang_ = lang;
  } else {
    clear_has_lang();
    lang_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .PBMidLayer.FileLocationNotify files = 4;
inline int AddLangSampRequest::files_size() const {
  return files_.size();
}
inline void AddLangSampRequest::clear_files() {
  files_.Clear();
}
inline const ::PBMidLayer::FileLocationNotify& AddLangSampRequest::files(int index) const {
  return files_.Get(index);
}
inline ::PBMidLayer::FileLocationNotify* AddLangSampRequest::mutable_files(int index) {
  return files_.Mutable(index);
}
inline ::PBMidLayer::FileLocationNotify* AddLangSampRequest::add_files() {
  return files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::FileLocationNotify >&
AddLangSampRequest::files() const {
  return files_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::FileLocationNotify >*
AddLangSampRequest::mutable_files() {
  return &files_;
}

// -------------------------------------------------------------------

// AddLangSampResponse

// required string taskid = 1;
inline bool AddLangSampResponse::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddLangSampResponse::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddLangSampResponse::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddLangSampResponse::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& AddLangSampResponse::taskid() const {
  return *taskid_;
}
inline void AddLangSampResponse::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void AddLangSampResponse::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void AddLangSampResponse::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddLangSampResponse::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* AddLangSampResponse::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddLangSampResponse::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.SystemCode syscode = 2;
inline bool AddLangSampResponse::has_syscode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddLangSampResponse::set_has_syscode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddLangSampResponse::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddLangSampResponse::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& AddLangSampResponse::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* AddLangSampResponse::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* AddLangSampResponse::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void AddLangSampResponse::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// required .PBMidLayer.OperationStatus status = 3;
inline bool AddLangSampResponse::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddLangSampResponse::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddLangSampResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddLangSampResponse::clear_status() {
  if (status_ != NULL) status_->::PBMidLayer::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBMidLayer::OperationStatus& AddLangSampResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBMidLayer::OperationStatus* AddLangSampResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBMidLayer::OperationStatus;
  return status_;
}
inline ::PBMidLayer::OperationStatus* AddLangSampResponse::release_status() {
  clear_has_status();
  ::PBMidLayer::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void AddLangSampResponse::set_allocated_status(::PBMidLayer::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// -------------------------------------------------------------------

// OperationStatus

// required int32 code = 1;
inline bool OperationStatus::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationStatus::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationStatus::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationStatus::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 OperationStatus::code() const {
  return code_;
}
inline void OperationStatus::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional string description = 2;
inline bool OperationStatus::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationStatus::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationStatus::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationStatus::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& OperationStatus::description() const {
  return *description_;
}
inline void OperationStatus::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void OperationStatus::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void OperationStatus::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationStatus::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* OperationStatus::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationStatus::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PreprocessResult

// required .PBMidLayer.SpeechType type = 1;
inline bool PreprocessResult::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PreprocessResult::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PreprocessResult::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PreprocessResult::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::PBMidLayer::SpeechType PreprocessResult::type() const {
  return static_cast< ::PBMidLayer::SpeechType >(type_);
}
inline void PreprocessResult::set_type(::PBMidLayer::SpeechType value) {
  assert(::PBMidLayer::SpeechType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string languagename = 2;
inline bool PreprocessResult::has_languagename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PreprocessResult::set_has_languagename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PreprocessResult::clear_has_languagename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PreprocessResult::clear_languagename() {
  if (languagename_ != &::google::protobuf::internal::kEmptyString) {
    languagename_->clear();
  }
  clear_has_languagename();
}
inline const ::std::string& PreprocessResult::languagename() const {
  return *languagename_;
}
inline void PreprocessResult::set_languagename(const ::std::string& value) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(value);
}
inline void PreprocessResult::set_languagename(const char* value) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(value);
}
inline void PreprocessResult::set_languagename(const char* value, size_t size) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PreprocessResult::mutable_languagename() {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  return languagename_;
}
inline ::std::string* PreprocessResult::release_languagename() {
  clear_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = languagename_;
    languagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PreprocessResult::set_allocated_languagename(::std::string* languagename) {
  if (languagename_ != &::google::protobuf::internal::kEmptyString) {
    delete languagename_;
  }
  if (languagename) {
    set_has_languagename();
    languagename_ = languagename;
  } else {
    clear_has_languagename();
    languagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float score = 3;
inline bool PreprocessResult::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PreprocessResult::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PreprocessResult::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PreprocessResult::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float PreprocessResult::score() const {
  return score_;
}
inline void PreprocessResult::set_score(float value) {
  set_has_score();
  score_ = value;
}

// optional uint32 validlen = 4;
inline bool PreprocessResult::has_validlen() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PreprocessResult::set_has_validlen() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PreprocessResult::clear_has_validlen() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PreprocessResult::clear_validlen() {
  validlen_ = 0u;
  clear_has_validlen();
}
inline ::google::protobuf::uint32 PreprocessResult::validlen() const {
  return validlen_;
}
inline void PreprocessResult::set_validlen(::google::protobuf::uint32 value) {
  set_has_validlen();
  validlen_ = value;
}

// optional .PBMidLayer.GenderType gender = 5;
inline bool PreprocessResult::has_gender() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PreprocessResult::set_has_gender() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PreprocessResult::clear_has_gender() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PreprocessResult::clear_gender() {
  gender_ = 0;
  clear_has_gender();
}
inline ::PBMidLayer::GenderType PreprocessResult::gender() const {
  return static_cast< ::PBMidLayer::GenderType >(gender_);
}
inline void PreprocessResult::set_gender(::PBMidLayer::GenderType value) {
  assert(::PBMidLayer::GenderType_IsValid(value));
  set_has_gender();
  gender_ = value;
}

// optional int32 speakernum = 6;
inline bool PreprocessResult::has_speakernum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PreprocessResult::set_has_speakernum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PreprocessResult::clear_has_speakernum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PreprocessResult::clear_speakernum() {
  speakernum_ = 0;
  clear_has_speakernum();
}
inline ::google::protobuf::int32 PreprocessResult::speakernum() const {
  return speakernum_;
}
inline void PreprocessResult::set_speakernum(::google::protobuf::int32 value) {
  set_has_speakernum();
  speakernum_ = value;
}

// optional string callid = 7;
inline bool PreprocessResult::has_callid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PreprocessResult::set_has_callid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PreprocessResult::clear_has_callid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PreprocessResult::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& PreprocessResult::callid() const {
  return *callid_;
}
inline void PreprocessResult::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void PreprocessResult::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void PreprocessResult::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PreprocessResult::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* PreprocessResult::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PreprocessResult::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .PBMidLayer.AudioFileTag filetag = 8;
inline bool PreprocessResult::has_filetag() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PreprocessResult::set_has_filetag() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PreprocessResult::clear_has_filetag() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PreprocessResult::clear_filetag() {
  filetag_ = 0;
  clear_has_filetag();
}
inline ::PBMidLayer::AudioFileTag PreprocessResult::filetag() const {
  return static_cast< ::PBMidLayer::AudioFileTag >(filetag_);
}
inline void PreprocessResult::set_filetag(::PBMidLayer::AudioFileTag value) {
  assert(::PBMidLayer::AudioFileTag_IsValid(value));
  set_has_filetag();
  filetag_ = value;
}

// -------------------------------------------------------------------

// SpeakerResult

// required int32 speakernum = 1;
inline bool SpeakerResult::has_speakernum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeakerResult::set_has_speakernum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeakerResult::clear_has_speakernum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeakerResult::clear_speakernum() {
  speakernum_ = 0;
  clear_has_speakernum();
}
inline ::google::protobuf::int32 SpeakerResult::speakernum() const {
  return speakernum_;
}
inline void SpeakerResult::set_speakernum(::google::protobuf::int32 value) {
  set_has_speakernum();
  speakernum_ = value;
}

// repeated .PBMidLayer.SpeakerItem speakers = 2;
inline int SpeakerResult::speakers_size() const {
  return speakers_.size();
}
inline void SpeakerResult::clear_speakers() {
  speakers_.Clear();
}
inline const ::PBMidLayer::SpeakerItem& SpeakerResult::speakers(int index) const {
  return speakers_.Get(index);
}
inline ::PBMidLayer::SpeakerItem* SpeakerResult::mutable_speakers(int index) {
  return speakers_.Mutable(index);
}
inline ::PBMidLayer::SpeakerItem* SpeakerResult::add_speakers() {
  return speakers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerItem >&
SpeakerResult::speakers() const {
  return speakers_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerItem >*
SpeakerResult::mutable_speakers() {
  return &speakers_;
}

// optional string callid = 3;
inline bool SpeakerResult::has_callid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpeakerResult::set_has_callid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpeakerResult::clear_has_callid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpeakerResult::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& SpeakerResult::callid() const {
  return *callid_;
}
inline void SpeakerResult::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void SpeakerResult::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void SpeakerResult::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpeakerResult::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* SpeakerResult::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpeakerResult::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .PBMidLayer.AudioFileTag filetag = 4;
inline bool SpeakerResult::has_filetag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpeakerResult::set_has_filetag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpeakerResult::clear_has_filetag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SpeakerResult::clear_filetag() {
  filetag_ = 0;
  clear_has_filetag();
}
inline ::PBMidLayer::AudioFileTag SpeakerResult::filetag() const {
  return static_cast< ::PBMidLayer::AudioFileTag >(filetag_);
}
inline void SpeakerResult::set_filetag(::PBMidLayer::AudioFileTag value) {
  assert(::PBMidLayer::AudioFileTag_IsValid(value));
  set_has_filetag();
  filetag_ = value;
}

// -------------------------------------------------------------------

// SpeakerItem

// required string objectid = 1;
inline bool SpeakerItem::has_objectid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeakerItem::set_has_objectid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeakerItem::clear_has_objectid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeakerItem::clear_objectid() {
  if (objectid_ != &::google::protobuf::internal::kEmptyString) {
    objectid_->clear();
  }
  clear_has_objectid();
}
inline const ::std::string& SpeakerItem::objectid() const {
  return *objectid_;
}
inline void SpeakerItem::set_objectid(const ::std::string& value) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(value);
}
inline void SpeakerItem::set_objectid(const char* value) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(value);
}
inline void SpeakerItem::set_objectid(const char* value, size_t size) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpeakerItem::mutable_objectid() {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  return objectid_;
}
inline ::std::string* SpeakerItem::release_objectid() {
  clear_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = objectid_;
    objectid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpeakerItem::set_allocated_objectid(::std::string* objectid) {
  if (objectid_ != &::google::protobuf::internal::kEmptyString) {
    delete objectid_;
  }
  if (objectid) {
    set_has_objectid();
    objectid_ = objectid;
  } else {
    clear_has_objectid();
    objectid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required float score = 2;
inline bool SpeakerItem::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpeakerItem::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpeakerItem::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpeakerItem::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float SpeakerItem::score() const {
  return score_;
}
inline void SpeakerItem::set_score(float value) {
  set_has_score();
  score_ = value;
}

// optional string spyid = 3;
inline bool SpeakerItem::has_spyid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpeakerItem::set_has_spyid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpeakerItem::clear_has_spyid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpeakerItem::clear_spyid() {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    spyid_->clear();
  }
  clear_has_spyid();
}
inline const ::std::string& SpeakerItem::spyid() const {
  return *spyid_;
}
inline void SpeakerItem::set_spyid(const ::std::string& value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void SpeakerItem::set_spyid(const char* value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void SpeakerItem::set_spyid(const char* value, size_t size) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpeakerItem::mutable_spyid() {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  return spyid_;
}
inline ::std::string* SpeakerItem::release_spyid() {
  clear_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spyid_;
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpeakerItem::set_allocated_spyid(::std::string* spyid) {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    delete spyid_;
  }
  if (spyid) {
    set_has_spyid();
    spyid_ = spyid;
  } else {
    clear_has_spyid();
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// KeywordResult

// required int32 keywordnum = 1;
inline bool KeywordResult::has_keywordnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeywordResult::set_has_keywordnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeywordResult::clear_has_keywordnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeywordResult::clear_keywordnum() {
  keywordnum_ = 0;
  clear_has_keywordnum();
}
inline ::google::protobuf::int32 KeywordResult::keywordnum() const {
  return keywordnum_;
}
inline void KeywordResult::set_keywordnum(::google::protobuf::int32 value) {
  set_has_keywordnum();
  keywordnum_ = value;
}

// repeated .PBMidLayer.KeywordSnippet keywords = 2;
inline int KeywordResult::keywords_size() const {
  return keywords_.size();
}
inline void KeywordResult::clear_keywords() {
  keywords_.Clear();
}
inline const ::PBMidLayer::KeywordSnippet& KeywordResult::keywords(int index) const {
  return keywords_.Get(index);
}
inline ::PBMidLayer::KeywordSnippet* KeywordResult::mutable_keywords(int index) {
  return keywords_.Mutable(index);
}
inline ::PBMidLayer::KeywordSnippet* KeywordResult::add_keywords() {
  return keywords_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordSnippet >&
KeywordResult::keywords() const {
  return keywords_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordSnippet >*
KeywordResult::mutable_keywords() {
  return &keywords_;
}

// optional string callid = 3;
inline bool KeywordResult::has_callid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeywordResult::set_has_callid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeywordResult::clear_has_callid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeywordResult::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& KeywordResult::callid() const {
  return *callid_;
}
inline void KeywordResult::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void KeywordResult::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void KeywordResult::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeywordResult::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* KeywordResult::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeywordResult::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .PBMidLayer.AudioFileTag filetag = 4;
inline bool KeywordResult::has_filetag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KeywordResult::set_has_filetag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KeywordResult::clear_has_filetag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KeywordResult::clear_filetag() {
  filetag_ = 0;
  clear_has_filetag();
}
inline ::PBMidLayer::AudioFileTag KeywordResult::filetag() const {
  return static_cast< ::PBMidLayer::AudioFileTag >(filetag_);
}
inline void KeywordResult::set_filetag(::PBMidLayer::AudioFileTag value) {
  assert(::PBMidLayer::AudioFileTag_IsValid(value));
  set_has_filetag();
  filetag_ = value;
}

// -------------------------------------------------------------------

// KeywordSnippet

// required string keyword = 1;
inline bool KeywordSnippet::has_keyword() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeywordSnippet::set_has_keyword() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeywordSnippet::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeywordSnippet::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& KeywordSnippet::keyword() const {
  return *keyword_;
}
inline void KeywordSnippet::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void KeywordSnippet::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void KeywordSnippet::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeywordSnippet::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  return keyword_;
}
inline ::std::string* KeywordSnippet::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeywordSnippet::set_allocated_keyword(::std::string* keyword) {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    delete keyword_;
  }
  if (keyword) {
    set_has_keyword();
    keyword_ = keyword;
  } else {
    clear_has_keyword();
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string languagename = 2;
inline bool KeywordSnippet::has_languagename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeywordSnippet::set_has_languagename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeywordSnippet::clear_has_languagename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeywordSnippet::clear_languagename() {
  if (languagename_ != &::google::protobuf::internal::kEmptyString) {
    languagename_->clear();
  }
  clear_has_languagename();
}
inline const ::std::string& KeywordSnippet::languagename() const {
  return *languagename_;
}
inline void KeywordSnippet::set_languagename(const ::std::string& value) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(value);
}
inline void KeywordSnippet::set_languagename(const char* value) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(value);
}
inline void KeywordSnippet::set_languagename(const char* value, size_t size) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeywordSnippet::mutable_languagename() {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  return languagename_;
}
inline ::std::string* KeywordSnippet::release_languagename() {
  clear_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = languagename_;
    languagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeywordSnippet::set_allocated_languagename(::std::string* languagename) {
  if (languagename_ != &::google::protobuf::internal::kEmptyString) {
    delete languagename_;
  }
  if (languagename) {
    set_has_languagename();
    languagename_ = languagename;
  } else {
    clear_has_languagename();
    languagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required float score = 3;
inline bool KeywordSnippet::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeywordSnippet::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeywordSnippet::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeywordSnippet::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float KeywordSnippet::score() const {
  return score_;
}
inline void KeywordSnippet::set_score(float value) {
  set_has_score();
  score_ = value;
}

// required uint32 begintime = 4;
inline bool KeywordSnippet::has_begintime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KeywordSnippet::set_has_begintime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KeywordSnippet::clear_has_begintime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KeywordSnippet::clear_begintime() {
  begintime_ = 0u;
  clear_has_begintime();
}
inline ::google::protobuf::uint32 KeywordSnippet::begintime() const {
  return begintime_;
}
inline void KeywordSnippet::set_begintime(::google::protobuf::uint32 value) {
  set_has_begintime();
  begintime_ = value;
}

// required uint32 endtime = 5;
inline bool KeywordSnippet::has_endtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KeywordSnippet::set_has_endtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KeywordSnippet::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KeywordSnippet::clear_endtime() {
  endtime_ = 0u;
  clear_has_endtime();
}
inline ::google::protobuf::uint32 KeywordSnippet::endtime() const {
  return endtime_;
}
inline void KeywordSnippet::set_endtime(::google::protobuf::uint32 value) {
  set_has_endtime();
  endtime_ = value;
}

// optional string text = 6;
inline bool KeywordSnippet::has_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void KeywordSnippet::set_has_text() {
  _has_bits_[0] |= 0x00000020u;
}
inline void KeywordSnippet::clear_has_text() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void KeywordSnippet::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& KeywordSnippet::text() const {
  return *text_;
}
inline void KeywordSnippet::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void KeywordSnippet::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void KeywordSnippet::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeywordSnippet::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* KeywordSnippet::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeywordSnippet::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string spyid = 7;
inline bool KeywordSnippet::has_spyid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void KeywordSnippet::set_has_spyid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void KeywordSnippet::clear_has_spyid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void KeywordSnippet::clear_spyid() {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    spyid_->clear();
  }
  clear_has_spyid();
}
inline const ::std::string& KeywordSnippet::spyid() const {
  return *spyid_;
}
inline void KeywordSnippet::set_spyid(const ::std::string& value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void KeywordSnippet::set_spyid(const char* value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void KeywordSnippet::set_spyid(const char* value, size_t size) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeywordSnippet::mutable_spyid() {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  return spyid_;
}
inline ::std::string* KeywordSnippet::release_spyid() {
  clear_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spyid_;
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeywordSnippet::set_allocated_spyid(::std::string* spyid) {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    delete spyid_;
  }
  if (spyid) {
    set_has_spyid();
    spyid_ = spyid;
  } else {
    clear_has_spyid();
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TranscriptResult

// required int32 segmentnum = 1;
inline bool TranscriptResult::has_segmentnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TranscriptResult::set_has_segmentnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TranscriptResult::clear_has_segmentnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TranscriptResult::clear_segmentnum() {
  segmentnum_ = 0;
  clear_has_segmentnum();
}
inline ::google::protobuf::int32 TranscriptResult::segmentnum() const {
  return segmentnum_;
}
inline void TranscriptResult::set_segmentnum(::google::protobuf::int32 value) {
  set_has_segmentnum();
  segmentnum_ = value;
}

// repeated .PBMidLayer.SegmentTranscript segments = 2;
inline int TranscriptResult::segments_size() const {
  return segments_.size();
}
inline void TranscriptResult::clear_segments() {
  segments_.Clear();
}
inline const ::PBMidLayer::SegmentTranscript& TranscriptResult::segments(int index) const {
  return segments_.Get(index);
}
inline ::PBMidLayer::SegmentTranscript* TranscriptResult::mutable_segments(int index) {
  return segments_.Mutable(index);
}
inline ::PBMidLayer::SegmentTranscript* TranscriptResult::add_segments() {
  return segments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SegmentTranscript >&
TranscriptResult::segments() const {
  return segments_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SegmentTranscript >*
TranscriptResult::mutable_segments() {
  return &segments_;
}

// optional string callid = 3;
inline bool TranscriptResult::has_callid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TranscriptResult::set_has_callid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TranscriptResult::clear_has_callid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TranscriptResult::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& TranscriptResult::callid() const {
  return *callid_;
}
inline void TranscriptResult::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void TranscriptResult::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void TranscriptResult::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranscriptResult::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* TranscriptResult::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TranscriptResult::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .PBMidLayer.AudioFileTag filetag = 4;
inline bool TranscriptResult::has_filetag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TranscriptResult::set_has_filetag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TranscriptResult::clear_has_filetag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TranscriptResult::clear_filetag() {
  filetag_ = 0;
  clear_has_filetag();
}
inline ::PBMidLayer::AudioFileTag TranscriptResult::filetag() const {
  return static_cast< ::PBMidLayer::AudioFileTag >(filetag_);
}
inline void TranscriptResult::set_filetag(::PBMidLayer::AudioFileTag value) {
  assert(::PBMidLayer::AudioFileTag_IsValid(value));
  set_has_filetag();
  filetag_ = value;
}

// -------------------------------------------------------------------

// SegmentTranscript

// required string content = 1;
inline bool SegmentTranscript::has_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SegmentTranscript::set_has_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SegmentTranscript::clear_has_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SegmentTranscript::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& SegmentTranscript::content() const {
  return *content_;
}
inline void SegmentTranscript::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void SegmentTranscript::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void SegmentTranscript::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SegmentTranscript::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* SegmentTranscript::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SegmentTranscript::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string languagename = 2;
inline bool SegmentTranscript::has_languagename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SegmentTranscript::set_has_languagename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SegmentTranscript::clear_has_languagename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SegmentTranscript::clear_languagename() {
  if (languagename_ != &::google::protobuf::internal::kEmptyString) {
    languagename_->clear();
  }
  clear_has_languagename();
}
inline const ::std::string& SegmentTranscript::languagename() const {
  return *languagename_;
}
inline void SegmentTranscript::set_languagename(const ::std::string& value) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(value);
}
inline void SegmentTranscript::set_languagename(const char* value) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(value);
}
inline void SegmentTranscript::set_languagename(const char* value, size_t size) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SegmentTranscript::mutable_languagename() {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  return languagename_;
}
inline ::std::string* SegmentTranscript::release_languagename() {
  clear_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = languagename_;
    languagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SegmentTranscript::set_allocated_languagename(::std::string* languagename) {
  if (languagename_ != &::google::protobuf::internal::kEmptyString) {
    delete languagename_;
  }
  if (languagename) {
    set_has_languagename();
    languagename_ = languagename;
  } else {
    clear_has_languagename();
    languagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required float score = 3;
inline bool SegmentTranscript::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SegmentTranscript::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SegmentTranscript::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SegmentTranscript::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float SegmentTranscript::score() const {
  return score_;
}
inline void SegmentTranscript::set_score(float value) {
  set_has_score();
  score_ = value;
}

// required uint32 begintime = 4;
inline bool SegmentTranscript::has_begintime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SegmentTranscript::set_has_begintime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SegmentTranscript::clear_has_begintime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SegmentTranscript::clear_begintime() {
  begintime_ = 0u;
  clear_has_begintime();
}
inline ::google::protobuf::uint32 SegmentTranscript::begintime() const {
  return begintime_;
}
inline void SegmentTranscript::set_begintime(::google::protobuf::uint32 value) {
  set_has_begintime();
  begintime_ = value;
}

// required uint32 endtime = 5;
inline bool SegmentTranscript::has_endtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SegmentTranscript::set_has_endtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SegmentTranscript::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SegmentTranscript::clear_endtime() {
  endtime_ = 0u;
  clear_has_endtime();
}
inline ::google::protobuf::uint32 SegmentTranscript::endtime() const {
  return endtime_;
}
inline void SegmentTranscript::set_endtime(::google::protobuf::uint32 value) {
  set_has_endtime();
  endtime_ = value;
}

// -------------------------------------------------------------------

// SpeakerRule

// required string objectid = 1;
inline bool SpeakerRule::has_objectid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeakerRule::set_has_objectid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeakerRule::clear_has_objectid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeakerRule::clear_objectid() {
  if (objectid_ != &::google::protobuf::internal::kEmptyString) {
    objectid_->clear();
  }
  clear_has_objectid();
}
inline const ::std::string& SpeakerRule::objectid() const {
  return *objectid_;
}
inline void SpeakerRule::set_objectid(const ::std::string& value) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(value);
}
inline void SpeakerRule::set_objectid(const char* value) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(value);
}
inline void SpeakerRule::set_objectid(const char* value, size_t size) {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  objectid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpeakerRule::mutable_objectid() {
  set_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    objectid_ = new ::std::string;
  }
  return objectid_;
}
inline ::std::string* SpeakerRule::release_objectid() {
  clear_has_objectid();
  if (objectid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = objectid_;
    objectid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpeakerRule::set_allocated_objectid(::std::string* objectid) {
  if (objectid_ != &::google::protobuf::internal::kEmptyString) {
    delete objectid_;
  }
  if (objectid) {
    set_has_objectid();
    objectid_ = objectid;
  } else {
    clear_has_objectid();
    objectid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 thresholdflag = 2;
inline bool SpeakerRule::has_thresholdflag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpeakerRule::set_has_thresholdflag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpeakerRule::clear_has_thresholdflag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpeakerRule::clear_thresholdflag() {
  thresholdflag_ = 0;
  clear_has_thresholdflag();
}
inline ::google::protobuf::int32 SpeakerRule::thresholdflag() const {
  return thresholdflag_;
}
inline void SpeakerRule::set_thresholdflag(::google::protobuf::int32 value) {
  set_has_thresholdflag();
  thresholdflag_ = value;
}

// optional float lowthreshold = 3;
inline bool SpeakerRule::has_lowthreshold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpeakerRule::set_has_lowthreshold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpeakerRule::clear_has_lowthreshold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpeakerRule::clear_lowthreshold() {
  lowthreshold_ = 0;
  clear_has_lowthreshold();
}
inline float SpeakerRule::lowthreshold() const {
  return lowthreshold_;
}
inline void SpeakerRule::set_lowthreshold(float value) {
  set_has_lowthreshold();
  lowthreshold_ = value;
}

// optional float highthreshold = 4;
inline bool SpeakerRule::has_highthreshold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpeakerRule::set_has_highthreshold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpeakerRule::clear_has_highthreshold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SpeakerRule::clear_highthreshold() {
  highthreshold_ = 0;
  clear_has_highthreshold();
}
inline float SpeakerRule::highthreshold() const {
  return highthreshold_;
}
inline void SpeakerRule::set_highthreshold(float value) {
  set_has_highthreshold();
  highthreshold_ = value;
}

// repeated .PBMidLayer.PhoneNumber telrule = 5;
inline int SpeakerRule::telrule_size() const {
  return telrule_.size();
}
inline void SpeakerRule::clear_telrule() {
  telrule_.Clear();
}
inline const ::PBMidLayer::PhoneNumber& SpeakerRule::telrule(int index) const {
  return telrule_.Get(index);
}
inline ::PBMidLayer::PhoneNumber* SpeakerRule::mutable_telrule(int index) {
  return telrule_.Mutable(index);
}
inline ::PBMidLayer::PhoneNumber* SpeakerRule::add_telrule() {
  return telrule_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber >&
SpeakerRule::telrule() const {
  return telrule_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber >*
SpeakerRule::mutable_telrule() {
  return &telrule_;
}

// -------------------------------------------------------------------

// KeywordRule

// required string languagename = 1;
inline bool KeywordRule::has_languagename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeywordRule::set_has_languagename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeywordRule::clear_has_languagename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeywordRule::clear_languagename() {
  if (languagename_ != &::google::protobuf::internal::kEmptyString) {
    languagename_->clear();
  }
  clear_has_languagename();
}
inline const ::std::string& KeywordRule::languagename() const {
  return *languagename_;
}
inline void KeywordRule::set_languagename(const ::std::string& value) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(value);
}
inline void KeywordRule::set_languagename(const char* value) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(value);
}
inline void KeywordRule::set_languagename(const char* value, size_t size) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeywordRule::mutable_languagename() {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  return languagename_;
}
inline ::std::string* KeywordRule::release_languagename() {
  clear_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = languagename_;
    languagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeywordRule::set_allocated_languagename(::std::string* languagename) {
  if (languagename_ != &::google::protobuf::internal::kEmptyString) {
    delete languagename_;
  }
  if (languagename) {
    set_has_languagename();
    languagename_ = languagename;
  } else {
    clear_has_languagename();
    languagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string keyword = 2;
inline bool KeywordRule::has_keyword() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeywordRule::set_has_keyword() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeywordRule::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeywordRule::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& KeywordRule::keyword() const {
  return *keyword_;
}
inline void KeywordRule::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void KeywordRule::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void KeywordRule::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeywordRule::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  return keyword_;
}
inline ::std::string* KeywordRule::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeywordRule::set_allocated_keyword(::std::string* keyword) {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    delete keyword_;
  }
  if (keyword) {
    set_has_keyword();
    keyword_ = keyword;
  } else {
    clear_has_keyword();
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float threshold = 3;
inline bool KeywordRule::has_threshold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeywordRule::set_has_threshold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeywordRule::clear_has_threshold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeywordRule::clear_threshold() {
  threshold_ = 0;
  clear_has_threshold();
}
inline float KeywordRule::threshold() const {
  return threshold_;
}
inline void KeywordRule::set_threshold(float value) {
  set_has_threshold();
  threshold_ = value;
}

// repeated .PBMidLayer.PhoneNumber telrule = 5;
inline int KeywordRule::telrule_size() const {
  return telrule_.size();
}
inline void KeywordRule::clear_telrule() {
  telrule_.Clear();
}
inline const ::PBMidLayer::PhoneNumber& KeywordRule::telrule(int index) const {
  return telrule_.Get(index);
}
inline ::PBMidLayer::PhoneNumber* KeywordRule::mutable_telrule(int index) {
  return telrule_.Mutable(index);
}
inline ::PBMidLayer::PhoneNumber* KeywordRule::add_telrule() {
  return telrule_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber >&
KeywordRule::telrule() const {
  return telrule_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber >*
KeywordRule::mutable_telrule() {
  return &telrule_;
}

// -------------------------------------------------------------------

// SpeechSegRule

// required string languagename = 1;
inline bool SpeechSegRule::has_languagename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeechSegRule::set_has_languagename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeechSegRule::clear_has_languagename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeechSegRule::clear_languagename() {
  if (languagename_ != &::google::protobuf::internal::kEmptyString) {
    languagename_->clear();
  }
  clear_has_languagename();
}
inline const ::std::string& SpeechSegRule::languagename() const {
  return *languagename_;
}
inline void SpeechSegRule::set_languagename(const ::std::string& value) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(value);
}
inline void SpeechSegRule::set_languagename(const char* value) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(value);
}
inline void SpeechSegRule::set_languagename(const char* value, size_t size) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpeechSegRule::mutable_languagename() {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  return languagename_;
}
inline ::std::string* SpeechSegRule::release_languagename() {
  clear_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = languagename_;
    languagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpeechSegRule::set_allocated_languagename(::std::string* languagename) {
  if (languagename_ != &::google::protobuf::internal::kEmptyString) {
    delete languagename_;
  }
  if (languagename) {
    set_has_languagename();
    languagename_ = languagename;
  } else {
    clear_has_languagename();
    languagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string speechsegid = 2;
inline bool SpeechSegRule::has_speechsegid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpeechSegRule::set_has_speechsegid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpeechSegRule::clear_has_speechsegid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpeechSegRule::clear_speechsegid() {
  if (speechsegid_ != &::google::protobuf::internal::kEmptyString) {
    speechsegid_->clear();
  }
  clear_has_speechsegid();
}
inline const ::std::string& SpeechSegRule::speechsegid() const {
  return *speechsegid_;
}
inline void SpeechSegRule::set_speechsegid(const ::std::string& value) {
  set_has_speechsegid();
  if (speechsegid_ == &::google::protobuf::internal::kEmptyString) {
    speechsegid_ = new ::std::string;
  }
  speechsegid_->assign(value);
}
inline void SpeechSegRule::set_speechsegid(const char* value) {
  set_has_speechsegid();
  if (speechsegid_ == &::google::protobuf::internal::kEmptyString) {
    speechsegid_ = new ::std::string;
  }
  speechsegid_->assign(value);
}
inline void SpeechSegRule::set_speechsegid(const char* value, size_t size) {
  set_has_speechsegid();
  if (speechsegid_ == &::google::protobuf::internal::kEmptyString) {
    speechsegid_ = new ::std::string;
  }
  speechsegid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpeechSegRule::mutable_speechsegid() {
  set_has_speechsegid();
  if (speechsegid_ == &::google::protobuf::internal::kEmptyString) {
    speechsegid_ = new ::std::string;
  }
  return speechsegid_;
}
inline ::std::string* SpeechSegRule::release_speechsegid() {
  clear_has_speechsegid();
  if (speechsegid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = speechsegid_;
    speechsegid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpeechSegRule::set_allocated_speechsegid(::std::string* speechsegid) {
  if (speechsegid_ != &::google::protobuf::internal::kEmptyString) {
    delete speechsegid_;
  }
  if (speechsegid) {
    set_has_speechsegid();
    speechsegid_ = speechsegid;
  } else {
    clear_has_speechsegid();
    speechsegid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes data = 3;
inline bool SpeechSegRule::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpeechSegRule::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpeechSegRule::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpeechSegRule::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& SpeechSegRule::data() const {
  return *data_;
}
inline void SpeechSegRule::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void SpeechSegRule::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void SpeechSegRule::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpeechSegRule::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* SpeechSegRule::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpeechSegRule::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string speechsegname = 4;
inline bool SpeechSegRule::has_speechsegname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpeechSegRule::set_has_speechsegname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpeechSegRule::clear_has_speechsegname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SpeechSegRule::clear_speechsegname() {
  if (speechsegname_ != &::google::protobuf::internal::kEmptyString) {
    speechsegname_->clear();
  }
  clear_has_speechsegname();
}
inline const ::std::string& SpeechSegRule::speechsegname() const {
  return *speechsegname_;
}
inline void SpeechSegRule::set_speechsegname(const ::std::string& value) {
  set_has_speechsegname();
  if (speechsegname_ == &::google::protobuf::internal::kEmptyString) {
    speechsegname_ = new ::std::string;
  }
  speechsegname_->assign(value);
}
inline void SpeechSegRule::set_speechsegname(const char* value) {
  set_has_speechsegname();
  if (speechsegname_ == &::google::protobuf::internal::kEmptyString) {
    speechsegname_ = new ::std::string;
  }
  speechsegname_->assign(value);
}
inline void SpeechSegRule::set_speechsegname(const char* value, size_t size) {
  set_has_speechsegname();
  if (speechsegname_ == &::google::protobuf::internal::kEmptyString) {
    speechsegname_ = new ::std::string;
  }
  speechsegname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpeechSegRule::mutable_speechsegname() {
  set_has_speechsegname();
  if (speechsegname_ == &::google::protobuf::internal::kEmptyString) {
    speechsegname_ = new ::std::string;
  }
  return speechsegname_;
}
inline ::std::string* SpeechSegRule::release_speechsegname() {
  clear_has_speechsegname();
  if (speechsegname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = speechsegname_;
    speechsegname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpeechSegRule::set_allocated_speechsegname(::std::string* speechsegname) {
  if (speechsegname_ != &::google::protobuf::internal::kEmptyString) {
    delete speechsegname_;
  }
  if (speechsegname) {
    set_has_speechsegname();
    speechsegname_ = speechsegname;
  } else {
    clear_has_speechsegname();
    speechsegname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float threshold = 5;
inline bool SpeechSegRule::has_threshold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SpeechSegRule::set_has_threshold() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SpeechSegRule::clear_has_threshold() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SpeechSegRule::clear_threshold() {
  threshold_ = 0;
  clear_has_threshold();
}
inline float SpeechSegRule::threshold() const {
  return threshold_;
}
inline void SpeechSegRule::set_threshold(float value) {
  set_has_threshold();
  threshold_ = value;
}

// repeated .PBMidLayer.PhoneNumber telrule = 6;
inline int SpeechSegRule::telrule_size() const {
  return telrule_.size();
}
inline void SpeechSegRule::clear_telrule() {
  telrule_.Clear();
}
inline const ::PBMidLayer::PhoneNumber& SpeechSegRule::telrule(int index) const {
  return telrule_.Get(index);
}
inline ::PBMidLayer::PhoneNumber* SpeechSegRule::mutable_telrule(int index) {
  return telrule_.Mutable(index);
}
inline ::PBMidLayer::PhoneNumber* SpeechSegRule::add_telrule() {
  return telrule_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber >&
SpeechSegRule::telrule() const {
  return telrule_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::PhoneNumber >*
SpeechSegRule::mutable_telrule() {
  return &telrule_;
}

// -------------------------------------------------------------------

// LanguageInfo

// required string languagename = 1;
inline bool LanguageInfo::has_languagename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LanguageInfo::set_has_languagename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LanguageInfo::clear_has_languagename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LanguageInfo::clear_languagename() {
  if (languagename_ != &::google::protobuf::internal::kEmptyString) {
    languagename_->clear();
  }
  clear_has_languagename();
}
inline const ::std::string& LanguageInfo::languagename() const {
  return *languagename_;
}
inline void LanguageInfo::set_languagename(const ::std::string& value) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(value);
}
inline void LanguageInfo::set_languagename(const char* value) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(value);
}
inline void LanguageInfo::set_languagename(const char* value, size_t size) {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  languagename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LanguageInfo::mutable_languagename() {
  set_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    languagename_ = new ::std::string;
  }
  return languagename_;
}
inline ::std::string* LanguageInfo::release_languagename() {
  clear_has_languagename();
  if (languagename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = languagename_;
    languagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LanguageInfo::set_allocated_languagename(::std::string* languagename) {
  if (languagename_ != &::google::protobuf::internal::kEmptyString) {
    delete languagename_;
  }
  if (languagename) {
    set_has_languagename();
    languagename_ = languagename;
  } else {
    clear_has_languagename();
    languagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 keywordsupported = 2;
inline bool LanguageInfo::has_keywordsupported() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LanguageInfo::set_has_keywordsupported() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LanguageInfo::clear_has_keywordsupported() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LanguageInfo::clear_keywordsupported() {
  keywordsupported_ = 0;
  clear_has_keywordsupported();
}
inline ::google::protobuf::int32 LanguageInfo::keywordsupported() const {
  return keywordsupported_;
}
inline void LanguageInfo::set_keywordsupported(::google::protobuf::int32 value) {
  set_has_keywordsupported();
  keywordsupported_ = value;
}

// required int32 transsupported = 3;
inline bool LanguageInfo::has_transsupported() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LanguageInfo::set_has_transsupported() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LanguageInfo::clear_has_transsupported() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LanguageInfo::clear_transsupported() {
  transsupported_ = 0;
  clear_has_transsupported();
}
inline ::google::protobuf::int32 LanguageInfo::transsupported() const {
  return transsupported_;
}
inline void LanguageInfo::set_transsupported(::google::protobuf::int32 value) {
  set_has_transsupported();
  transsupported_ = value;
}

// -------------------------------------------------------------------

// TrainInfo

// required .PBMidLayer.AudioEncodingTag code = 1;
inline bool TrainInfo::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrainInfo::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrainInfo::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrainInfo::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::PBMidLayer::AudioEncodingTag TrainInfo::code() const {
  return static_cast< ::PBMidLayer::AudioEncodingTag >(code_);
}
inline void TrainInfo::set_code(::PBMidLayer::AudioEncodingTag value) {
  assert(::PBMidLayer::AudioEncodingTag_IsValid(value));
  set_has_code();
  code_ = value;
}

// required bool isdata = 2;
inline bool TrainInfo::has_isdata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrainInfo::set_has_isdata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrainInfo::clear_has_isdata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrainInfo::clear_isdata() {
  isdata_ = false;
  clear_has_isdata();
}
inline bool TrainInfo::isdata() const {
  return isdata_;
}
inline void TrainInfo::set_isdata(bool value) {
  set_has_isdata();
  isdata_ = value;
}

// optional bytes voice = 3;
inline bool TrainInfo::has_voice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrainInfo::set_has_voice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrainInfo::clear_has_voice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrainInfo::clear_voice() {
  if (voice_ != &::google::protobuf::internal::kEmptyString) {
    voice_->clear();
  }
  clear_has_voice();
}
inline const ::std::string& TrainInfo::voice() const {
  return *voice_;
}
inline void TrainInfo::set_voice(const ::std::string& value) {
  set_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    voice_ = new ::std::string;
  }
  voice_->assign(value);
}
inline void TrainInfo::set_voice(const char* value) {
  set_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    voice_ = new ::std::string;
  }
  voice_->assign(value);
}
inline void TrainInfo::set_voice(const void* value, size_t size) {
  set_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    voice_ = new ::std::string;
  }
  voice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrainInfo::mutable_voice() {
  set_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    voice_ = new ::std::string;
  }
  return voice_;
}
inline ::std::string* TrainInfo::release_voice() {
  clear_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = voice_;
    voice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrainInfo::set_allocated_voice(::std::string* voice) {
  if (voice_ != &::google::protobuf::internal::kEmptyString) {
    delete voice_;
  }
  if (voice) {
    set_has_voice();
    voice_ = voice;
  } else {
    clear_has_voice();
    voice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string path = 4;
inline bool TrainInfo::has_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrainInfo::set_has_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrainInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrainInfo::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TrainInfo::path() const {
  return *path_;
}
inline void TrainInfo::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TrainInfo::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TrainInfo::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrainInfo::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* TrainInfo::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrainInfo::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PhoneNumber

// required string telnumber = 1;
inline bool PhoneNumber::has_telnumber() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PhoneNumber::set_has_telnumber() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PhoneNumber::clear_has_telnumber() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PhoneNumber::clear_telnumber() {
  if (telnumber_ != &::google::protobuf::internal::kEmptyString) {
    telnumber_->clear();
  }
  clear_has_telnumber();
}
inline const ::std::string& PhoneNumber::telnumber() const {
  return *telnumber_;
}
inline void PhoneNumber::set_telnumber(const ::std::string& value) {
  set_has_telnumber();
  if (telnumber_ == &::google::protobuf::internal::kEmptyString) {
    telnumber_ = new ::std::string;
  }
  telnumber_->assign(value);
}
inline void PhoneNumber::set_telnumber(const char* value) {
  set_has_telnumber();
  if (telnumber_ == &::google::protobuf::internal::kEmptyString) {
    telnumber_ = new ::std::string;
  }
  telnumber_->assign(value);
}
inline void PhoneNumber::set_telnumber(const char* value, size_t size) {
  set_has_telnumber();
  if (telnumber_ == &::google::protobuf::internal::kEmptyString) {
    telnumber_ = new ::std::string;
  }
  telnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneNumber::mutable_telnumber() {
  set_has_telnumber();
  if (telnumber_ == &::google::protobuf::internal::kEmptyString) {
    telnumber_ = new ::std::string;
  }
  return telnumber_;
}
inline ::std::string* PhoneNumber::release_telnumber() {
  clear_has_telnumber();
  if (telnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = telnumber_;
    telnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneNumber::set_allocated_telnumber(::std::string* telnumber) {
  if (telnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete telnumber_;
  }
  if (telnumber) {
    set_has_telnumber();
    telnumber_ = telnumber;
  } else {
    clear_has_telnumber();
    telnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string countrycode = 2;
inline bool PhoneNumber::has_countrycode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PhoneNumber::set_has_countrycode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PhoneNumber::clear_has_countrycode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PhoneNumber::clear_countrycode() {
  if (countrycode_ != &::google::protobuf::internal::kEmptyString) {
    countrycode_->clear();
  }
  clear_has_countrycode();
}
inline const ::std::string& PhoneNumber::countrycode() const {
  return *countrycode_;
}
inline void PhoneNumber::set_countrycode(const ::std::string& value) {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::kEmptyString) {
    countrycode_ = new ::std::string;
  }
  countrycode_->assign(value);
}
inline void PhoneNumber::set_countrycode(const char* value) {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::kEmptyString) {
    countrycode_ = new ::std::string;
  }
  countrycode_->assign(value);
}
inline void PhoneNumber::set_countrycode(const char* value, size_t size) {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::kEmptyString) {
    countrycode_ = new ::std::string;
  }
  countrycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneNumber::mutable_countrycode() {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::kEmptyString) {
    countrycode_ = new ::std::string;
  }
  return countrycode_;
}
inline ::std::string* PhoneNumber::release_countrycode() {
  clear_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = countrycode_;
    countrycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneNumber::set_allocated_countrycode(::std::string* countrycode) {
  if (countrycode_ != &::google::protobuf::internal::kEmptyString) {
    delete countrycode_;
  }
  if (countrycode) {
    set_has_countrycode();
    countrycode_ = countrycode;
  } else {
    clear_has_countrycode();
    countrycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string provincecode = 3;
inline bool PhoneNumber::has_provincecode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PhoneNumber::set_has_provincecode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PhoneNumber::clear_has_provincecode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PhoneNumber::clear_provincecode() {
  if (provincecode_ != &::google::protobuf::internal::kEmptyString) {
    provincecode_->clear();
  }
  clear_has_provincecode();
}
inline const ::std::string& PhoneNumber::provincecode() const {
  return *provincecode_;
}
inline void PhoneNumber::set_provincecode(const ::std::string& value) {
  set_has_provincecode();
  if (provincecode_ == &::google::protobuf::internal::kEmptyString) {
    provincecode_ = new ::std::string;
  }
  provincecode_->assign(value);
}
inline void PhoneNumber::set_provincecode(const char* value) {
  set_has_provincecode();
  if (provincecode_ == &::google::protobuf::internal::kEmptyString) {
    provincecode_ = new ::std::string;
  }
  provincecode_->assign(value);
}
inline void PhoneNumber::set_provincecode(const char* value, size_t size) {
  set_has_provincecode();
  if (provincecode_ == &::google::protobuf::internal::kEmptyString) {
    provincecode_ = new ::std::string;
  }
  provincecode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneNumber::mutable_provincecode() {
  set_has_provincecode();
  if (provincecode_ == &::google::protobuf::internal::kEmptyString) {
    provincecode_ = new ::std::string;
  }
  return provincecode_;
}
inline ::std::string* PhoneNumber::release_provincecode() {
  clear_has_provincecode();
  if (provincecode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = provincecode_;
    provincecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneNumber::set_allocated_provincecode(::std::string* provincecode) {
  if (provincecode_ != &::google::protobuf::internal::kEmptyString) {
    delete provincecode_;
  }
  if (provincecode) {
    set_has_provincecode();
    provincecode_ = provincecode;
  } else {
    clear_has_provincecode();
    provincecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string areacode = 4;
inline bool PhoneNumber::has_areacode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PhoneNumber::set_has_areacode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PhoneNumber::clear_has_areacode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PhoneNumber::clear_areacode() {
  if (areacode_ != &::google::protobuf::internal::kEmptyString) {
    areacode_->clear();
  }
  clear_has_areacode();
}
inline const ::std::string& PhoneNumber::areacode() const {
  return *areacode_;
}
inline void PhoneNumber::set_areacode(const ::std::string& value) {
  set_has_areacode();
  if (areacode_ == &::google::protobuf::internal::kEmptyString) {
    areacode_ = new ::std::string;
  }
  areacode_->assign(value);
}
inline void PhoneNumber::set_areacode(const char* value) {
  set_has_areacode();
  if (areacode_ == &::google::protobuf::internal::kEmptyString) {
    areacode_ = new ::std::string;
  }
  areacode_->assign(value);
}
inline void PhoneNumber::set_areacode(const char* value, size_t size) {
  set_has_areacode();
  if (areacode_ == &::google::protobuf::internal::kEmptyString) {
    areacode_ = new ::std::string;
  }
  areacode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneNumber::mutable_areacode() {
  set_has_areacode();
  if (areacode_ == &::google::protobuf::internal::kEmptyString) {
    areacode_ = new ::std::string;
  }
  return areacode_;
}
inline ::std::string* PhoneNumber::release_areacode() {
  clear_has_areacode();
  if (areacode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = areacode_;
    areacode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneNumber::set_allocated_areacode(::std::string* areacode) {
  if (areacode_ != &::google::protobuf::internal::kEmptyString) {
    delete areacode_;
  }
  if (areacode) {
    set_has_areacode();
    areacode_ = areacode;
  } else {
    clear_has_areacode();
    areacode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SearchTaskState

// required .PBMidLayer.SearchTaskRunState runstate = 1;
inline bool SearchTaskState::has_runstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchTaskState::set_has_runstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchTaskState::clear_has_runstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchTaskState::clear_runstate() {
  runstate_ = 0;
  clear_has_runstate();
}
inline ::PBMidLayer::SearchTaskRunState SearchTaskState::runstate() const {
  return static_cast< ::PBMidLayer::SearchTaskRunState >(runstate_);
}
inline void SearchTaskState::set_runstate(::PBMidLayer::SearchTaskRunState value) {
  assert(::PBMidLayer::SearchTaskRunState_IsValid(value));
  set_has_runstate();
  runstate_ = value;
}

// required uint64 queuetime = 2;
inline bool SearchTaskState::has_queuetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchTaskState::set_has_queuetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchTaskState::clear_has_queuetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchTaskState::clear_queuetime() {
  queuetime_ = GOOGLE_ULONGLONG(0);
  clear_has_queuetime();
}
inline ::google::protobuf::uint64 SearchTaskState::queuetime() const {
  return queuetime_;
}
inline void SearchTaskState::set_queuetime(::google::protobuf::uint64 value) {
  set_has_queuetime();
  queuetime_ = value;
}

// optional uint64 starttime = 3;
inline bool SearchTaskState::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchTaskState::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchTaskState::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchTaskState::clear_starttime() {
  starttime_ = GOOGLE_ULONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::uint64 SearchTaskState::starttime() const {
  return starttime_;
}
inline void SearchTaskState::set_starttime(::google::protobuf::uint64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional uint64 finishtime = 4;
inline bool SearchTaskState::has_finishtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SearchTaskState::set_has_finishtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SearchTaskState::clear_has_finishtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SearchTaskState::clear_finishtime() {
  finishtime_ = GOOGLE_ULONGLONG(0);
  clear_has_finishtime();
}
inline ::google::protobuf::uint64 SearchTaskState::finishtime() const {
  return finishtime_;
}
inline void SearchTaskState::set_finishtime(::google::protobuf::uint64 value) {
  set_has_finishtime();
  finishtime_ = value;
}

// optional uint64 aborttime = 5;
inline bool SearchTaskState::has_aborttime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SearchTaskState::set_has_aborttime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SearchTaskState::clear_has_aborttime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SearchTaskState::clear_aborttime() {
  aborttime_ = GOOGLE_ULONGLONG(0);
  clear_has_aborttime();
}
inline ::google::protobuf::uint64 SearchTaskState::aborttime() const {
  return aborttime_;
}
inline void SearchTaskState::set_aborttime(::google::protobuf::uint64 value) {
  set_has_aborttime();
  aborttime_ = value;
}

// optional string msg = 6;
inline bool SearchTaskState::has_msg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SearchTaskState::set_has_msg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SearchTaskState::clear_has_msg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SearchTaskState::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& SearchTaskState::msg() const {
  return *msg_;
}
inline void SearchTaskState::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void SearchTaskState::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void SearchTaskState::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchTaskState::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* SearchTaskState::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchTaskState::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SystemCode

// optional string spyid = 1;
inline bool SystemCode::has_spyid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemCode::set_has_spyid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemCode::clear_has_spyid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemCode::clear_spyid() {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    spyid_->clear();
  }
  clear_has_spyid();
}
inline const ::std::string& SystemCode::spyid() const {
  return *spyid_;
}
inline void SystemCode::set_spyid(const ::std::string& value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void SystemCode::set_spyid(const char* value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void SystemCode::set_spyid(const char* value, size_t size) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemCode::mutable_spyid() {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  return spyid_;
}
inline ::std::string* SystemCode::release_spyid() {
  clear_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spyid_;
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SystemCode::set_allocated_spyid(::std::string* spyid) {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    delete spyid_;
  }
  if (spyid) {
    set_has_spyid();
    spyid_ = spyid;
  } else {
    clear_has_spyid();
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string srid = 2;
inline bool SystemCode::has_srid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemCode::set_has_srid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemCode::clear_has_srid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemCode::clear_srid() {
  if (srid_ != &::google::protobuf::internal::kEmptyString) {
    srid_->clear();
  }
  clear_has_srid();
}
inline const ::std::string& SystemCode::srid() const {
  return *srid_;
}
inline void SystemCode::set_srid(const ::std::string& value) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(value);
}
inline void SystemCode::set_srid(const char* value) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(value);
}
inline void SystemCode::set_srid(const char* value, size_t size) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemCode::mutable_srid() {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  return srid_;
}
inline ::std::string* SystemCode::release_srid() {
  clear_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srid_;
    srid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SystemCode::set_allocated_srid(::std::string* srid) {
  if (srid_ != &::google::protobuf::internal::kEmptyString) {
    delete srid_;
  }
  if (srid) {
    set_has_srid();
    srid_ = srid;
  } else {
    clear_has_srid();
    srid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string datasource = 3;
inline int SystemCode::datasource_size() const {
  return datasource_.size();
}
inline void SystemCode::clear_datasource() {
  datasource_.Clear();
}
inline const ::std::string& SystemCode::datasource(int index) const {
  return datasource_.Get(index);
}
inline ::std::string* SystemCode::mutable_datasource(int index) {
  return datasource_.Mutable(index);
}
inline void SystemCode::set_datasource(int index, const ::std::string& value) {
  datasource_.Mutable(index)->assign(value);
}
inline void SystemCode::set_datasource(int index, const char* value) {
  datasource_.Mutable(index)->assign(value);
}
inline void SystemCode::set_datasource(int index, const char* value, size_t size) {
  datasource_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemCode::add_datasource() {
  return datasource_.Add();
}
inline void SystemCode::add_datasource(const ::std::string& value) {
  datasource_.Add()->assign(value);
}
inline void SystemCode::add_datasource(const char* value) {
  datasource_.Add()->assign(value);
}
inline void SystemCode::add_datasource(const char* value, size_t size) {
  datasource_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SystemCode::datasource() const {
  return datasource_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SystemCode::mutable_datasource() {
  return &datasource_;
}

// -------------------------------------------------------------------

// SearchFileResult

// required string callid = 1;
inline bool SearchFileResult::has_callid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchFileResult::set_has_callid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchFileResult::clear_has_callid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchFileResult::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& SearchFileResult::callid() const {
  return *callid_;
}
inline void SearchFileResult::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void SearchFileResult::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void SearchFileResult::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchFileResult::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* SearchFileResult::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchFileResult::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.AudioFileTag filetag = 2;
inline bool SearchFileResult::has_filetag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchFileResult::set_has_filetag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchFileResult::clear_has_filetag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchFileResult::clear_filetag() {
  filetag_ = 0;
  clear_has_filetag();
}
inline ::PBMidLayer::AudioFileTag SearchFileResult::filetag() const {
  return static_cast< ::PBMidLayer::AudioFileTag >(filetag_);
}
inline void SearchFileResult::set_filetag(::PBMidLayer::AudioFileTag value) {
  assert(::PBMidLayer::AudioFileTag_IsValid(value));
  set_has_filetag();
  filetag_ = value;
}

// optional float score = 3;
inline bool SearchFileResult::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchFileResult::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchFileResult::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchFileResult::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float SearchFileResult::score() const {
  return score_;
}
inline void SearchFileResult::set_score(float value) {
  set_has_score();
  score_ = value;
}

// repeated .PBMidLayer.SpeakerItem speakers = 4;
inline int SearchFileResult::speakers_size() const {
  return speakers_.size();
}
inline void SearchFileResult::clear_speakers() {
  speakers_.Clear();
}
inline const ::PBMidLayer::SpeakerItem& SearchFileResult::speakers(int index) const {
  return speakers_.Get(index);
}
inline ::PBMidLayer::SpeakerItem* SearchFileResult::mutable_speakers(int index) {
  return speakers_.Mutable(index);
}
inline ::PBMidLayer::SpeakerItem* SearchFileResult::add_speakers() {
  return speakers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerItem >&
SearchFileResult::speakers() const {
  return speakers_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeakerItem >*
SearchFileResult::mutable_speakers() {
  return &speakers_;
}

// repeated .PBMidLayer.KeywordSnippet keywords = 5;
inline int SearchFileResult::keywords_size() const {
  return keywords_.size();
}
inline void SearchFileResult::clear_keywords() {
  keywords_.Clear();
}
inline const ::PBMidLayer::KeywordSnippet& SearchFileResult::keywords(int index) const {
  return keywords_.Get(index);
}
inline ::PBMidLayer::KeywordSnippet* SearchFileResult::mutable_keywords(int index) {
  return keywords_.Mutable(index);
}
inline ::PBMidLayer::KeywordSnippet* SearchFileResult::add_keywords() {
  return keywords_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordSnippet >&
SearchFileResult::keywords() const {
  return keywords_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::KeywordSnippet >*
SearchFileResult::mutable_keywords() {
  return &keywords_;
}

// repeated .PBMidLayer.SpeechSegItem speechsegs = 6;
inline int SearchFileResult::speechsegs_size() const {
  return speechsegs_.size();
}
inline void SearchFileResult::clear_speechsegs() {
  speechsegs_.Clear();
}
inline const ::PBMidLayer::SpeechSegItem& SearchFileResult::speechsegs(int index) const {
  return speechsegs_.Get(index);
}
inline ::PBMidLayer::SpeechSegItem* SearchFileResult::mutable_speechsegs(int index) {
  return speechsegs_.Mutable(index);
}
inline ::PBMidLayer::SpeechSegItem* SearchFileResult::add_speechsegs() {
  return speechsegs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegItem >&
SearchFileResult::speechsegs() const {
  return speechsegs_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegItem >*
SearchFileResult::mutable_speechsegs() {
  return &speechsegs_;
}

// required string datasource = 7;
inline bool SearchFileResult::has_datasource() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SearchFileResult::set_has_datasource() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SearchFileResult::clear_has_datasource() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SearchFileResult::clear_datasource() {
  if (datasource_ != &::google::protobuf::internal::kEmptyString) {
    datasource_->clear();
  }
  clear_has_datasource();
}
inline const ::std::string& SearchFileResult::datasource() const {
  return *datasource_;
}
inline void SearchFileResult::set_datasource(const ::std::string& value) {
  set_has_datasource();
  if (datasource_ == &::google::protobuf::internal::kEmptyString) {
    datasource_ = new ::std::string;
  }
  datasource_->assign(value);
}
inline void SearchFileResult::set_datasource(const char* value) {
  set_has_datasource();
  if (datasource_ == &::google::protobuf::internal::kEmptyString) {
    datasource_ = new ::std::string;
  }
  datasource_->assign(value);
}
inline void SearchFileResult::set_datasource(const char* value, size_t size) {
  set_has_datasource();
  if (datasource_ == &::google::protobuf::internal::kEmptyString) {
    datasource_ = new ::std::string;
  }
  datasource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchFileResult::mutable_datasource() {
  set_has_datasource();
  if (datasource_ == &::google::protobuf::internal::kEmptyString) {
    datasource_ = new ::std::string;
  }
  return datasource_;
}
inline ::std::string* SearchFileResult::release_datasource() {
  clear_has_datasource();
  if (datasource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datasource_;
    datasource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchFileResult::set_allocated_datasource(::std::string* datasource) {
  if (datasource_ != &::google::protobuf::internal::kEmptyString) {
    delete datasource_;
  }
  if (datasource) {
    set_has_datasource();
    datasource_ = datasource;
  } else {
    clear_has_datasource();
    datasource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SpeechSegResult

// repeated .PBMidLayer.SpeechSegItem speechsegs = 1;
inline int SpeechSegResult::speechsegs_size() const {
  return speechsegs_.size();
}
inline void SpeechSegResult::clear_speechsegs() {
  speechsegs_.Clear();
}
inline const ::PBMidLayer::SpeechSegItem& SpeechSegResult::speechsegs(int index) const {
  return speechsegs_.Get(index);
}
inline ::PBMidLayer::SpeechSegItem* SpeechSegResult::mutable_speechsegs(int index) {
  return speechsegs_.Mutable(index);
}
inline ::PBMidLayer::SpeechSegItem* SpeechSegResult::add_speechsegs() {
  return speechsegs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegItem >&
SpeechSegResult::speechsegs() const {
  return speechsegs_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::SpeechSegItem >*
SpeechSegResult::mutable_speechsegs() {
  return &speechsegs_;
}

// optional string callid = 2;
inline bool SpeechSegResult::has_callid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpeechSegResult::set_has_callid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpeechSegResult::clear_has_callid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpeechSegResult::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& SpeechSegResult::callid() const {
  return *callid_;
}
inline void SpeechSegResult::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void SpeechSegResult::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void SpeechSegResult::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpeechSegResult::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* SpeechSegResult::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpeechSegResult::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .PBMidLayer.AudioFileTag filetag = 3;
inline bool SpeechSegResult::has_filetag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpeechSegResult::set_has_filetag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpeechSegResult::clear_has_filetag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpeechSegResult::clear_filetag() {
  filetag_ = 0;
  clear_has_filetag();
}
inline ::PBMidLayer::AudioFileTag SpeechSegResult::filetag() const {
  return static_cast< ::PBMidLayer::AudioFileTag >(filetag_);
}
inline void SpeechSegResult::set_filetag(::PBMidLayer::AudioFileTag value) {
  assert(::PBMidLayer::AudioFileTag_IsValid(value));
  set_has_filetag();
  filetag_ = value;
}

// -------------------------------------------------------------------

// SpeechSegItem

// required string speechsegcode = 1;
inline bool SpeechSegItem::has_speechsegcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeechSegItem::set_has_speechsegcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeechSegItem::clear_has_speechsegcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeechSegItem::clear_speechsegcode() {
  if (speechsegcode_ != &::google::protobuf::internal::kEmptyString) {
    speechsegcode_->clear();
  }
  clear_has_speechsegcode();
}
inline const ::std::string& SpeechSegItem::speechsegcode() const {
  return *speechsegcode_;
}
inline void SpeechSegItem::set_speechsegcode(const ::std::string& value) {
  set_has_speechsegcode();
  if (speechsegcode_ == &::google::protobuf::internal::kEmptyString) {
    speechsegcode_ = new ::std::string;
  }
  speechsegcode_->assign(value);
}
inline void SpeechSegItem::set_speechsegcode(const char* value) {
  set_has_speechsegcode();
  if (speechsegcode_ == &::google::protobuf::internal::kEmptyString) {
    speechsegcode_ = new ::std::string;
  }
  speechsegcode_->assign(value);
}
inline void SpeechSegItem::set_speechsegcode(const char* value, size_t size) {
  set_has_speechsegcode();
  if (speechsegcode_ == &::google::protobuf::internal::kEmptyString) {
    speechsegcode_ = new ::std::string;
  }
  speechsegcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpeechSegItem::mutable_speechsegcode() {
  set_has_speechsegcode();
  if (speechsegcode_ == &::google::protobuf::internal::kEmptyString) {
    speechsegcode_ = new ::std::string;
  }
  return speechsegcode_;
}
inline ::std::string* SpeechSegItem::release_speechsegcode() {
  clear_has_speechsegcode();
  if (speechsegcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = speechsegcode_;
    speechsegcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpeechSegItem::set_allocated_speechsegcode(::std::string* speechsegcode) {
  if (speechsegcode_ != &::google::protobuf::internal::kEmptyString) {
    delete speechsegcode_;
  }
  if (speechsegcode) {
    set_has_speechsegcode();
    speechsegcode_ = speechsegcode;
  } else {
    clear_has_speechsegcode();
    speechsegcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 begin = 2;
inline bool SpeechSegItem::has_begin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpeechSegItem::set_has_begin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpeechSegItem::clear_has_begin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpeechSegItem::clear_begin() {
  begin_ = 0;
  clear_has_begin();
}
inline ::google::protobuf::int32 SpeechSegItem::begin() const {
  return begin_;
}
inline void SpeechSegItem::set_begin(::google::protobuf::int32 value) {
  set_has_begin();
  begin_ = value;
}

// required int32 end = 3;
inline bool SpeechSegItem::has_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpeechSegItem::set_has_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpeechSegItem::clear_has_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpeechSegItem::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline ::google::protobuf::int32 SpeechSegItem::end() const {
  return end_;
}
inline void SpeechSegItem::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
}

// required int32 hitbegin = 4;
inline bool SpeechSegItem::has_hitbegin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpeechSegItem::set_has_hitbegin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpeechSegItem::clear_has_hitbegin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SpeechSegItem::clear_hitbegin() {
  hitbegin_ = 0;
  clear_has_hitbegin();
}
inline ::google::protobuf::int32 SpeechSegItem::hitbegin() const {
  return hitbegin_;
}
inline void SpeechSegItem::set_hitbegin(::google::protobuf::int32 value) {
  set_has_hitbegin();
  hitbegin_ = value;
}

// required int32 hitend = 5;
inline bool SpeechSegItem::has_hitend() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SpeechSegItem::set_has_hitend() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SpeechSegItem::clear_has_hitend() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SpeechSegItem::clear_hitend() {
  hitend_ = 0;
  clear_has_hitend();
}
inline ::google::protobuf::int32 SpeechSegItem::hitend() const {
  return hitend_;
}
inline void SpeechSegItem::set_hitend(::google::protobuf::int32 value) {
  set_has_hitend();
  hitend_ = value;
}

// required float score = 6;
inline bool SpeechSegItem::has_score() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SpeechSegItem::set_has_score() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SpeechSegItem::clear_has_score() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SpeechSegItem::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float SpeechSegItem::score() const {
  return score_;
}
inline void SpeechSegItem::set_score(float value) {
  set_has_score();
  score_ = value;
}

// optional string spyid = 7;
inline bool SpeechSegItem::has_spyid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SpeechSegItem::set_has_spyid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SpeechSegItem::clear_has_spyid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SpeechSegItem::clear_spyid() {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    spyid_->clear();
  }
  clear_has_spyid();
}
inline const ::std::string& SpeechSegItem::spyid() const {
  return *spyid_;
}
inline void SpeechSegItem::set_spyid(const ::std::string& value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void SpeechSegItem::set_spyid(const char* value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void SpeechSegItem::set_spyid(const char* value, size_t size) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpeechSegItem::mutable_spyid() {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  return spyid_;
}
inline ::std::string* SpeechSegItem::release_spyid() {
  clear_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spyid_;
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpeechSegItem::set_allocated_spyid(::std::string* spyid) {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    delete spyid_;
  }
  if (spyid) {
    set_has_spyid();
    spyid_ = spyid;
  } else {
    clear_has_spyid();
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// VADResult

// repeated .PBMidLayer.VADItem vads = 1;
inline int VADResult::vads_size() const {
  return vads_.size();
}
inline void VADResult::clear_vads() {
  vads_.Clear();
}
inline const ::PBMidLayer::VADItem& VADResult::vads(int index) const {
  return vads_.Get(index);
}
inline ::PBMidLayer::VADItem* VADResult::mutable_vads(int index) {
  return vads_.Mutable(index);
}
inline ::PBMidLayer::VADItem* VADResult::add_vads() {
  return vads_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::VADItem >&
VADResult::vads() const {
  return vads_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::VADItem >*
VADResult::mutable_vads() {
  return &vads_;
}

// optional string callid = 2;
inline bool VADResult::has_callid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VADResult::set_has_callid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VADResult::clear_has_callid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VADResult::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& VADResult::callid() const {
  return *callid_;
}
inline void VADResult::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void VADResult::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void VADResult::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VADResult::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* VADResult::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VADResult::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .PBMidLayer.AudioFileTag filetag = 3;
inline bool VADResult::has_filetag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VADResult::set_has_filetag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VADResult::clear_has_filetag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VADResult::clear_filetag() {
  filetag_ = 0;
  clear_has_filetag();
}
inline ::PBMidLayer::AudioFileTag VADResult::filetag() const {
  return static_cast< ::PBMidLayer::AudioFileTag >(filetag_);
}
inline void VADResult::set_filetag(::PBMidLayer::AudioFileTag value) {
  assert(::PBMidLayer::AudioFileTag_IsValid(value));
  set_has_filetag();
  filetag_ = value;
}

// -------------------------------------------------------------------

// VADItem

// required int32 begin = 1;
inline bool VADItem::has_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VADItem::set_has_begin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VADItem::clear_has_begin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VADItem::clear_begin() {
  begin_ = 0;
  clear_has_begin();
}
inline ::google::protobuf::int32 VADItem::begin() const {
  return begin_;
}
inline void VADItem::set_begin(::google::protobuf::int32 value) {
  set_has_begin();
  begin_ = value;
}

// required int32 end = 2;
inline bool VADItem::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VADItem::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VADItem::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VADItem::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline ::google::protobuf::int32 VADItem::end() const {
  return end_;
}
inline void VADItem::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
}

// optional string spk = 3;
inline bool VADItem::has_spk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VADItem::set_has_spk() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VADItem::clear_has_spk() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VADItem::clear_spk() {
  if (spk_ != &::google::protobuf::internal::kEmptyString) {
    spk_->clear();
  }
  clear_has_spk();
}
inline const ::std::string& VADItem::spk() const {
  return *spk_;
}
inline void VADItem::set_spk(const ::std::string& value) {
  set_has_spk();
  if (spk_ == &::google::protobuf::internal::kEmptyString) {
    spk_ = new ::std::string;
  }
  spk_->assign(value);
}
inline void VADItem::set_spk(const char* value) {
  set_has_spk();
  if (spk_ == &::google::protobuf::internal::kEmptyString) {
    spk_ = new ::std::string;
  }
  spk_->assign(value);
}
inline void VADItem::set_spk(const char* value, size_t size) {
  set_has_spk();
  if (spk_ == &::google::protobuf::internal::kEmptyString) {
    spk_ = new ::std::string;
  }
  spk_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VADItem::mutable_spk() {
  set_has_spk();
  if (spk_ == &::google::protobuf::internal::kEmptyString) {
    spk_ = new ::std::string;
  }
  return spk_;
}
inline ::std::string* VADItem::release_spk() {
  clear_has_spk();
  if (spk_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spk_;
    spk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VADItem::set_allocated_spk(::std::string* spk) {
  if (spk_ != &::google::protobuf::internal::kEmptyString) {
    delete spk_;
  }
  if (spk) {
    set_has_spk();
    spk_ = spk;
  } else {
    clear_has_spk();
    spk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DTMFResult

// repeated .PBMidLayer.DTMFItem dtms = 1;
inline int DTMFResult::dtms_size() const {
  return dtms_.size();
}
inline void DTMFResult::clear_dtms() {
  dtms_.Clear();
}
inline const ::PBMidLayer::DTMFItem& DTMFResult::dtms(int index) const {
  return dtms_.Get(index);
}
inline ::PBMidLayer::DTMFItem* DTMFResult::mutable_dtms(int index) {
  return dtms_.Mutable(index);
}
inline ::PBMidLayer::DTMFItem* DTMFResult::add_dtms() {
  return dtms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMidLayer::DTMFItem >&
DTMFResult::dtms() const {
  return dtms_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBMidLayer::DTMFItem >*
DTMFResult::mutable_dtms() {
  return &dtms_;
}

// optional string callid = 2;
inline bool DTMFResult::has_callid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DTMFResult::set_has_callid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DTMFResult::clear_has_callid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DTMFResult::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& DTMFResult::callid() const {
  return *callid_;
}
inline void DTMFResult::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void DTMFResult::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void DTMFResult::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DTMFResult::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* DTMFResult::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DTMFResult::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .PBMidLayer.AudioFileTag filetag = 3;
inline bool DTMFResult::has_filetag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DTMFResult::set_has_filetag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DTMFResult::clear_has_filetag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DTMFResult::clear_filetag() {
  filetag_ = 0;
  clear_has_filetag();
}
inline ::PBMidLayer::AudioFileTag DTMFResult::filetag() const {
  return static_cast< ::PBMidLayer::AudioFileTag >(filetag_);
}
inline void DTMFResult::set_filetag(::PBMidLayer::AudioFileTag value) {
  assert(::PBMidLayer::AudioFileTag_IsValid(value));
  set_has_filetag();
  filetag_ = value;
}

// -------------------------------------------------------------------

// DTMFItem

// required int32 code = 1;
inline bool DTMFItem::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DTMFItem::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DTMFItem::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DTMFItem::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 DTMFItem::code() const {
  return code_;
}
inline void DTMFItem::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required int32 begin = 2;
inline bool DTMFItem::has_begin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DTMFItem::set_has_begin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DTMFItem::clear_has_begin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DTMFItem::clear_begin() {
  begin_ = 0;
  clear_has_begin();
}
inline ::google::protobuf::int32 DTMFItem::begin() const {
  return begin_;
}
inline void DTMFItem::set_begin(::google::protobuf::int32 value) {
  set_has_begin();
  begin_ = value;
}

// required int32 end = 3;
inline bool DTMFItem::has_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DTMFItem::set_has_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DTMFItem::clear_has_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DTMFItem::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline ::google::protobuf::int32 DTMFItem::end() const {
  return end_;
}
inline void DTMFItem::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
}

// -------------------------------------------------------------------

// SystemStateItem

// required string statename = 1;
inline bool SystemStateItem::has_statename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemStateItem::set_has_statename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemStateItem::clear_has_statename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemStateItem::clear_statename() {
  if (statename_ != &::google::protobuf::internal::kEmptyString) {
    statename_->clear();
  }
  clear_has_statename();
}
inline const ::std::string& SystemStateItem::statename() const {
  return *statename_;
}
inline void SystemStateItem::set_statename(const ::std::string& value) {
  set_has_statename();
  if (statename_ == &::google::protobuf::internal::kEmptyString) {
    statename_ = new ::std::string;
  }
  statename_->assign(value);
}
inline void SystemStateItem::set_statename(const char* value) {
  set_has_statename();
  if (statename_ == &::google::protobuf::internal::kEmptyString) {
    statename_ = new ::std::string;
  }
  statename_->assign(value);
}
inline void SystemStateItem::set_statename(const char* value, size_t size) {
  set_has_statename();
  if (statename_ == &::google::protobuf::internal::kEmptyString) {
    statename_ = new ::std::string;
  }
  statename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemStateItem::mutable_statename() {
  set_has_statename();
  if (statename_ == &::google::protobuf::internal::kEmptyString) {
    statename_ = new ::std::string;
  }
  return statename_;
}
inline ::std::string* SystemStateItem::release_statename() {
  clear_has_statename();
  if (statename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = statename_;
    statename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SystemStateItem::set_allocated_statename(::std::string* statename) {
  if (statename_ != &::google::protobuf::internal::kEmptyString) {
    delete statename_;
  }
  if (statename) {
    set_has_statename();
    statename_ = statename;
  } else {
    clear_has_statename();
    statename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string statevalue = 2;
inline bool SystemStateItem::has_statevalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemStateItem::set_has_statevalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemStateItem::clear_has_statevalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemStateItem::clear_statevalue() {
  if (statevalue_ != &::google::protobuf::internal::kEmptyString) {
    statevalue_->clear();
  }
  clear_has_statevalue();
}
inline const ::std::string& SystemStateItem::statevalue() const {
  return *statevalue_;
}
inline void SystemStateItem::set_statevalue(const ::std::string& value) {
  set_has_statevalue();
  if (statevalue_ == &::google::protobuf::internal::kEmptyString) {
    statevalue_ = new ::std::string;
  }
  statevalue_->assign(value);
}
inline void SystemStateItem::set_statevalue(const char* value) {
  set_has_statevalue();
  if (statevalue_ == &::google::protobuf::internal::kEmptyString) {
    statevalue_ = new ::std::string;
  }
  statevalue_->assign(value);
}
inline void SystemStateItem::set_statevalue(const char* value, size_t size) {
  set_has_statevalue();
  if (statevalue_ == &::google::protobuf::internal::kEmptyString) {
    statevalue_ = new ::std::string;
  }
  statevalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemStateItem::mutable_statevalue() {
  set_has_statevalue();
  if (statevalue_ == &::google::protobuf::internal::kEmptyString) {
    statevalue_ = new ::std::string;
  }
  return statevalue_;
}
inline ::std::string* SystemStateItem::release_statevalue() {
  clear_has_statevalue();
  if (statevalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = statevalue_;
    statevalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SystemStateItem::set_allocated_statevalue(::std::string* statevalue) {
  if (statevalue_ != &::google::protobuf::internal::kEmptyString) {
    delete statevalue_;
  }
  if (statevalue) {
    set_has_statevalue();
    statevalue_ = statevalue;
  } else {
    clear_has_statevalue();
    statevalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string remark = 3;
inline bool SystemStateItem::has_remark() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemStateItem::set_has_remark() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemStateItem::clear_has_remark() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemStateItem::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& SystemStateItem::remark() const {
  return *remark_;
}
inline void SystemStateItem::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void SystemStateItem::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void SystemStateItem::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemStateItem::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* SystemStateItem::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SystemStateItem::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FileDataNotify

// required string callid = 1;
inline bool FileDataNotify::has_callid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileDataNotify::set_has_callid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileDataNotify::clear_has_callid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileDataNotify::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& FileDataNotify::callid() const {
  return *callid_;
}
inline void FileDataNotify::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void FileDataNotify::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void FileDataNotify::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileDataNotify::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* FileDataNotify::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileDataNotify::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.AudioFileTag filetag = 2;
inline bool FileDataNotify::has_filetag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileDataNotify::set_has_filetag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileDataNotify::clear_has_filetag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileDataNotify::clear_filetag() {
  filetag_ = 0;
  clear_has_filetag();
}
inline ::PBMidLayer::AudioFileTag FileDataNotify::filetag() const {
  return static_cast< ::PBMidLayer::AudioFileTag >(filetag_);
}
inline void FileDataNotify::set_filetag(::PBMidLayer::AudioFileTag value) {
  assert(::PBMidLayer::AudioFileTag_IsValid(value));
  set_has_filetag();
  filetag_ = value;
}

// required .PBMidLayer.AudioEncodingTag code = 3;
inline bool FileDataNotify::has_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileDataNotify::set_has_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileDataNotify::clear_has_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileDataNotify::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::PBMidLayer::AudioEncodingTag FileDataNotify::code() const {
  return static_cast< ::PBMidLayer::AudioEncodingTag >(code_);
}
inline void FileDataNotify::set_code(::PBMidLayer::AudioEncodingTag value) {
  assert(::PBMidLayer::AudioEncodingTag_IsValid(value));
  set_has_code();
  code_ = value;
}

// required bytes voice = 4;
inline bool FileDataNotify::has_voice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileDataNotify::set_has_voice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileDataNotify::clear_has_voice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileDataNotify::clear_voice() {
  if (voice_ != &::google::protobuf::internal::kEmptyString) {
    voice_->clear();
  }
  clear_has_voice();
}
inline const ::std::string& FileDataNotify::voice() const {
  return *voice_;
}
inline void FileDataNotify::set_voice(const ::std::string& value) {
  set_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    voice_ = new ::std::string;
  }
  voice_->assign(value);
}
inline void FileDataNotify::set_voice(const char* value) {
  set_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    voice_ = new ::std::string;
  }
  voice_->assign(value);
}
inline void FileDataNotify::set_voice(const void* value, size_t size) {
  set_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    voice_ = new ::std::string;
  }
  voice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileDataNotify::mutable_voice() {
  set_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    voice_ = new ::std::string;
  }
  return voice_;
}
inline ::std::string* FileDataNotify::release_voice() {
  clear_has_voice();
  if (voice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = voice_;
    voice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileDataNotify::set_allocated_voice(::std::string* voice) {
  if (voice_ != &::google::protobuf::internal::kEmptyString) {
    delete voice_;
  }
  if (voice) {
    set_has_voice();
    voice_ = voice;
  } else {
    clear_has_voice();
    voice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBMidLayer.SystemCode syscode = 5;
inline bool FileDataNotify::has_syscode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileDataNotify::set_has_syscode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileDataNotify::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileDataNotify::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBMidLayer::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBMidLayer::SystemCode& FileDataNotify::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBMidLayer::SystemCode* FileDataNotify::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBMidLayer::SystemCode;
  return syscode_;
}
inline ::PBMidLayer::SystemCode* FileDataNotify::release_syscode() {
  clear_has_syscode();
  ::PBMidLayer::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void FileDataNotify::set_allocated_syscode(::PBMidLayer::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace PBMidLayer

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::MsgType>() {
  return ::PBMidLayer::MsgType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::AudioRecordMode>() {
  return ::PBMidLayer::AudioRecordMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::AudioChannelType>() {
  return ::PBMidLayer::AudioChannelType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::AudioTransFlag>() {
  return ::PBMidLayer::AudioTransFlag_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::AudioFileTag>() {
  return ::PBMidLayer::AudioFileTag_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::RecognitionType>() {
  return ::PBMidLayer::RecognitionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::PriorityType>() {
  return ::PBMidLayer::PriorityType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::SearchCondition>() {
  return ::PBMidLayer::SearchCondition_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::SpeechType>() {
  return ::PBMidLayer::SpeechType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::AudioEncodingTag>() {
  return ::PBMidLayer::AudioEncodingTag_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::OperationType>() {
  return ::PBMidLayer::OperationType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::RuleType>() {
  return ::PBMidLayer::RuleType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::SystemParaType>() {
  return ::PBMidLayer::SystemParaType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::AlarmLevel>() {
  return ::PBMidLayer::AlarmLevel_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::AudioRecogFlag>() {
  return ::PBMidLayer::AudioRecogFlag_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::FileAcquireMethod>() {
  return ::PBMidLayer::FileAcquireMethod_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::SearchTaskType>() {
  return ::PBMidLayer::SearchTaskType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::SearchTaskRunState>() {
  return ::PBMidLayer::SearchTaskRunState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMidLayer::GenderType>() {
  return ::PBMidLayer::GenderType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PBMidLayer_2eproto__INCLUDED
