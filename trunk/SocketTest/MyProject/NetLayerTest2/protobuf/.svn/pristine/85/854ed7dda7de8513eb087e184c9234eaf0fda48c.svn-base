// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PBNetTest.proto

#ifndef PROTOBUF_PBNetTest_2eproto__INCLUDED
#define PROTOBUF_PBNetTest_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace PBNetTest {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_PBNetTest_2eproto();
void protobuf_AssignDesc_PBNetTest_2eproto();
void protobuf_ShutdownFile_PBNetTest_2eproto();

class HeadMsg;
class ConnectRequest;
class ConnectResponse;
class ConnectRelease;
class EchoReqRes;
class CallProcessRequest;
class FileLocationNotify;
class SearchAbortRequest;
class SearchResponse;
class AlarmNotify;
class OperationStatus;
class SystemCode;
class PhoneNumber;

enum MsgType {
  MSG_UNKNOWN = 0,
  MSG_CONNECT_REQ = 1,
  MSG_CONNECT_RESP = 2,
  MSG_CONNECT_RELEASE = 8,
  MSG_ECHO_REQ = 17,
  MSG_ECHO_RESP = 18,
  MSG_CALL_PROCESS_REQ = 33,
  MSG_CALL_PROCESS_RESP = 34,
  MSG_HISTORY_SEARCH_REQ = 65,
  MSG_HISTORY_SEARCH_RESP = 66,
  MSG_HISTORY_TRANS_REQ = 67,
  MSG_HISTORY_TRANS_RESP = 68,
  MSG_FILE_LOCATION_NOTIFY = 69,
  MSG_TARGET_QUERY_REQ = 71,
  MSG_TARGET_QUERY_RESP = 72,
  MSG_SET_RULE_REQ = 4097,
  MSG_SET_RULE_RESP = 4098,
  MSG_QUERY_RULE_REQ = 4099,
  MSG_QUERY_RULE_RESP = 4100,
  MSG_SET_SYSPARA_REQ = 4105,
  MSG_SET_SYSPARA_RESP = 4112,
  MSG_QUERY_SYSPARA_REQ = 4113,
  MSG_QUERY_SYSPARA_RESP = 4114,
  MSG_ALARM_NOTIFY = 4116,
  MSG_STAT_NOTIFY = 4118,
  MSG_OBJECT_MANAGE_REQ = 4119,
  MSG_OBJECT_MANAGE_RESP = 4120,
  MSG_FEED_BACK_NOTIFY = 4121,
  MSG_SEARCH_REQ = 1025,
  MSG_SEARCH_ABORT_REQ = 1026,
  MSG_SEARCH_RESULT = 1027,
  MSG_SEARCH_RESP = 1028,
  MSG_SEARCH_STATE_REQ = 1029,
  MSG_SEARCH_STATE_RESP = 1030,
  MSG_GET_FILE_REQ = 1031,
  MSG_GET_FILE_RESP = 1032,
  MSG_ADD_LANG_SAMP_REQ = 1033,
  MSG_ADD_LANG_SAMP_RESP = 1034,
  MSG_OBJECT_MANAGE_NOTIFY = 1035
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = MSG_UNKNOWN;
const MsgType MsgType_MAX = MSG_FEED_BACK_NOTIFY;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum AudioEncodingTag {
  AET_Unknown = 0,
  AET_ALaw = 1,
  AET_Gsm610 = 2,
  AET_G726 = 3,
  AET_LinearPCM = 4,
  AET_G723_16 = 5,
  AET_G723_15 = 6,
  AET_G729 = 7,
  AET_ULaw = 8,
  AET_INTEL_G723 = 9,
  AET_INTEL_G729 = 10,
  AET_INTEL_GSM690 = 11,
  AET_AMR_NB = 12,
  AET_GSM_EFR = 13
};
bool AudioEncodingTag_IsValid(int value);
const AudioEncodingTag AudioEncodingTag_MIN = AET_Unknown;
const AudioEncodingTag AudioEncodingTag_MAX = AET_GSM_EFR;
const int AudioEncodingTag_ARRAYSIZE = AudioEncodingTag_MAX + 1;

const ::google::protobuf::EnumDescriptor* AudioEncodingTag_descriptor();
inline const ::std::string& AudioEncodingTag_Name(AudioEncodingTag value) {
  return ::google::protobuf::internal::NameOfEnum(
    AudioEncodingTag_descriptor(), value);
}
inline bool AudioEncodingTag_Parse(
    const ::std::string& name, AudioEncodingTag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioEncodingTag>(
    AudioEncodingTag_descriptor(), name, value);
}
enum AudioFileTag {
  AFT_Unknown = 0,
  AFT_Combination = 1,
  AFT_Caller_ClusterA = 2,
  AFT_Callee_ClusterB = 3,
  AFT_Third_ClusterC = 4,
  AFT_NoTag = 5
};
bool AudioFileTag_IsValid(int value);
const AudioFileTag AudioFileTag_MIN = AFT_Unknown;
const AudioFileTag AudioFileTag_MAX = AFT_NoTag;
const int AudioFileTag_ARRAYSIZE = AudioFileTag_MAX + 1;

const ::google::protobuf::EnumDescriptor* AudioFileTag_descriptor();
inline const ::std::string& AudioFileTag_Name(AudioFileTag value) {
  return ::google::protobuf::internal::NameOfEnum(
    AudioFileTag_descriptor(), value);
}
inline bool AudioFileTag_Parse(
    const ::std::string& name, AudioFileTag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioFileTag>(
    AudioFileTag_descriptor(), name, value);
}
enum AlarmLevel {
  AL_Unknown = 0,
  AL_General = 1,
  AL_Important = 2,
  AL_Urgent = 3
};
bool AlarmLevel_IsValid(int value);
const AlarmLevel AlarmLevel_MIN = AL_Unknown;
const AlarmLevel AlarmLevel_MAX = AL_Urgent;
const int AlarmLevel_ARRAYSIZE = AlarmLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* AlarmLevel_descriptor();
inline const ::std::string& AlarmLevel_Name(AlarmLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    AlarmLevel_descriptor(), value);
}
inline bool AlarmLevel_Parse(
    const ::std::string& name, AlarmLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AlarmLevel>(
    AlarmLevel_descriptor(), name, value);
}
enum AudioRecordMode {
  ARM_Unknown = 0,
  ARM_Combination = 1,
  ARM_Separation = 2
};
bool AudioRecordMode_IsValid(int value);
const AudioRecordMode AudioRecordMode_MIN = ARM_Unknown;
const AudioRecordMode AudioRecordMode_MAX = ARM_Separation;
const int AudioRecordMode_ARRAYSIZE = AudioRecordMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* AudioRecordMode_descriptor();
inline const ::std::string& AudioRecordMode_Name(AudioRecordMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    AudioRecordMode_descriptor(), value);
}
inline bool AudioRecordMode_Parse(
    const ::std::string& name, AudioRecordMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioRecordMode>(
    AudioRecordMode_descriptor(), name, value);
}
enum AudioChannelType {
  ACT_Unknown = 0,
  ACT_Pcm = 1,
  ACT_Voip = 2,
  ACT_TwoLines = 3,
  ACT_AirSignal = 4,
  ACT_WX = 5
};
bool AudioChannelType_IsValid(int value);
const AudioChannelType AudioChannelType_MIN = ACT_Unknown;
const AudioChannelType AudioChannelType_MAX = ACT_WX;
const int AudioChannelType_ARRAYSIZE = AudioChannelType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AudioChannelType_descriptor();
inline const ::std::string& AudioChannelType_Name(AudioChannelType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AudioChannelType_descriptor(), value);
}
inline bool AudioChannelType_Parse(
    const ::std::string& name, AudioChannelType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioChannelType>(
    AudioChannelType_descriptor(), name, value);
}
enum AudioTransFlag {
  ATF_Unknown = 0,
  ATF_Trans = 1,
  ATF_NotTrans = 2
};
bool AudioTransFlag_IsValid(int value);
const AudioTransFlag AudioTransFlag_MIN = ATF_Unknown;
const AudioTransFlag AudioTransFlag_MAX = ATF_NotTrans;
const int AudioTransFlag_ARRAYSIZE = AudioTransFlag_MAX + 1;

const ::google::protobuf::EnumDescriptor* AudioTransFlag_descriptor();
inline const ::std::string& AudioTransFlag_Name(AudioTransFlag value) {
  return ::google::protobuf::internal::NameOfEnum(
    AudioTransFlag_descriptor(), value);
}
inline bool AudioTransFlag_Parse(
    const ::std::string& name, AudioTransFlag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioTransFlag>(
    AudioTransFlag_descriptor(), name, value);
}
enum FileAcquireMethod {
  FAM_Unknown = 0,
  FAM_URL = 1,
  FAM_Data = 2
};
bool FileAcquireMethod_IsValid(int value);
const FileAcquireMethod FileAcquireMethod_MIN = FAM_Unknown;
const FileAcquireMethod FileAcquireMethod_MAX = FAM_Data;
const int FileAcquireMethod_ARRAYSIZE = FileAcquireMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileAcquireMethod_descriptor();
inline const ::std::string& FileAcquireMethod_Name(FileAcquireMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileAcquireMethod_descriptor(), value);
}
inline bool FileAcquireMethod_Parse(
    const ::std::string& name, FileAcquireMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileAcquireMethod>(
    FileAcquireMethod_descriptor(), name, value);
}
enum PriorityType {
  PT_Unknown = 0,
  PT_High = 1,
  PT_Normal = 2,
  PT_Low = 3
};
bool PriorityType_IsValid(int value);
const PriorityType PriorityType_MIN = PT_Unknown;
const PriorityType PriorityType_MAX = PT_Low;
const int PriorityType_ARRAYSIZE = PriorityType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PriorityType_descriptor();
inline const ::std::string& PriorityType_Name(PriorityType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PriorityType_descriptor(), value);
}
inline bool PriorityType_Parse(
    const ::std::string& name, PriorityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PriorityType>(
    PriorityType_descriptor(), name, value);
}
// ===================================================================

class HeadMsg : public ::google::protobuf::Message {
 public:
  HeadMsg();
  virtual ~HeadMsg();

  HeadMsg(const HeadMsg& from);

  inline HeadMsg& operator=(const HeadMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeadMsg& default_instance();

  void Swap(HeadMsg* other);

  // implements Message ----------------------------------------------

  HeadMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeadMsg& from);
  void MergeFrom(const HeadMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 syn = 1 [default = 255];
  inline bool has_syn() const;
  inline void clear_syn();
  static const int kSynFieldNumber = 1;
  inline ::google::protobuf::uint32 syn() const;
  inline void set_syn(::google::protobuf::uint32 value);

  // required fixed32 pro = 2 [default = 100];
  inline bool has_pro() const;
  inline void clear_pro();
  static const int kProFieldNumber = 2;
  inline ::google::protobuf::uint32 pro() const;
  inline void set_pro(::google::protobuf::uint32 value);

  // required fixed32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required fixed64 seqno = 4;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 4;
  inline ::google::protobuf::uint64 seqno() const;
  inline void set_seqno(::google::protobuf::uint64 value);

  // required fixed32 len = 5;
  inline bool has_len() const;
  inline void clear_len();
  static const int kLenFieldNumber = 5;
  inline ::google::protobuf::uint32 len() const;
  inline void set_len(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PBNetTest.HeadMsg)
 private:
  inline void set_has_syn();
  inline void clear_has_syn();
  inline void set_has_pro();
  inline void clear_has_pro();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_len();
  inline void clear_has_len();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 syn_;
  ::google::protobuf::uint32 pro_;
  ::google::protobuf::uint64 seqno_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PBNetTest_2eproto();
  friend void protobuf_AssignDesc_PBNetTest_2eproto();
  friend void protobuf_ShutdownFile_PBNetTest_2eproto();

  void InitAsDefaultInstance();
  static HeadMsg* default_instance_;
};
// -------------------------------------------------------------------

class ConnectRequest : public ::google::protobuf::Message {
 public:
  ConnectRequest();
  virtual ~ConnectRequest();

  ConnectRequest(const ConnectRequest& from);

  inline ConnectRequest& operator=(const ConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectRequest& default_instance();

  void Swap(ConnectRequest* other);

  // implements Message ----------------------------------------------

  ConnectRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectRequest& from);
  void MergeFrom(const ConnectRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string spyid = 1;
  inline bool has_spyid() const;
  inline void clear_spyid();
  static const int kSpyidFieldNumber = 1;
  inline const ::std::string& spyid() const;
  inline void set_spyid(const ::std::string& value);
  inline void set_spyid(const char* value);
  inline void set_spyid(const char* value, size_t size);
  inline ::std::string* mutable_spyid();
  inline ::std::string* release_spyid();
  inline void set_allocated_spyid(::std::string* spyid);

  // optional string srid = 2;
  inline bool has_srid() const;
  inline void clear_srid();
  static const int kSridFieldNumber = 2;
  inline const ::std::string& srid() const;
  inline void set_srid(const ::std::string& value);
  inline void set_srid(const char* value);
  inline void set_srid(const char* value, size_t size);
  inline ::std::string* mutable_srid();
  inline ::std::string* release_srid();
  inline void set_allocated_srid(::std::string* srid);

  // @@protoc_insertion_point(class_scope:PBNetTest.ConnectRequest)
 private:
  inline void set_has_spyid();
  inline void clear_has_spyid();
  inline void set_has_srid();
  inline void clear_has_srid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* spyid_;
  ::std::string* srid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_PBNetTest_2eproto();
  friend void protobuf_AssignDesc_PBNetTest_2eproto();
  friend void protobuf_ShutdownFile_PBNetTest_2eproto();

  void InitAsDefaultInstance();
  static ConnectRequest* default_instance_;
};
// -------------------------------------------------------------------

class ConnectResponse : public ::google::protobuf::Message {
 public:
  ConnectResponse();
  virtual ~ConnectResponse();

  ConnectResponse(const ConnectResponse& from);

  inline ConnectResponse& operator=(const ConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectResponse& default_instance();

  void Swap(ConnectResponse* other);

  // implements Message ----------------------------------------------

  ConnectResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectResponse& from);
  void MergeFrom(const ConnectResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBNetTest.OperationStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::PBNetTest::OperationStatus& status() const;
  inline ::PBNetTest::OperationStatus* mutable_status();
  inline ::PBNetTest::OperationStatus* release_status();
  inline void set_allocated_status(::PBNetTest::OperationStatus* status);

  // required string spyid = 2;
  inline bool has_spyid() const;
  inline void clear_spyid();
  static const int kSpyidFieldNumber = 2;
  inline const ::std::string& spyid() const;
  inline void set_spyid(const ::std::string& value);
  inline void set_spyid(const char* value);
  inline void set_spyid(const char* value, size_t size);
  inline ::std::string* mutable_spyid();
  inline ::std::string* release_spyid();
  inline void set_allocated_spyid(::std::string* spyid);

  // optional string srid = 3;
  inline bool has_srid() const;
  inline void clear_srid();
  static const int kSridFieldNumber = 3;
  inline const ::std::string& srid() const;
  inline void set_srid(const ::std::string& value);
  inline void set_srid(const char* value);
  inline void set_srid(const char* value, size_t size);
  inline ::std::string* mutable_srid();
  inline ::std::string* release_srid();
  inline void set_allocated_srid(::std::string* srid);

  // @@protoc_insertion_point(class_scope:PBNetTest.ConnectResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_spyid();
  inline void clear_has_spyid();
  inline void set_has_srid();
  inline void clear_has_srid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PBNetTest::OperationStatus* status_;
  ::std::string* spyid_;
  ::std::string* srid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBNetTest_2eproto();
  friend void protobuf_AssignDesc_PBNetTest_2eproto();
  friend void protobuf_ShutdownFile_PBNetTest_2eproto();

  void InitAsDefaultInstance();
  static ConnectResponse* default_instance_;
};
// -------------------------------------------------------------------

class ConnectRelease : public ::google::protobuf::Message {
 public:
  ConnectRelease();
  virtual ~ConnectRelease();

  ConnectRelease(const ConnectRelease& from);

  inline ConnectRelease& operator=(const ConnectRelease& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectRelease& default_instance();

  void Swap(ConnectRelease* other);

  // implements Message ----------------------------------------------

  ConnectRelease* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectRelease& from);
  void MergeFrom(const ConnectRelease& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBNetTest.OperationStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::PBNetTest::OperationStatus& status() const;
  inline ::PBNetTest::OperationStatus* mutable_status();
  inline ::PBNetTest::OperationStatus* release_status();
  inline void set_allocated_status(::PBNetTest::OperationStatus* status);

  // required string spyid = 2;
  inline bool has_spyid() const;
  inline void clear_spyid();
  static const int kSpyidFieldNumber = 2;
  inline const ::std::string& spyid() const;
  inline void set_spyid(const ::std::string& value);
  inline void set_spyid(const char* value);
  inline void set_spyid(const char* value, size_t size);
  inline ::std::string* mutable_spyid();
  inline ::std::string* release_spyid();
  inline void set_allocated_spyid(::std::string* spyid);

  // optional string srid = 3;
  inline bool has_srid() const;
  inline void clear_srid();
  static const int kSridFieldNumber = 3;
  inline const ::std::string& srid() const;
  inline void set_srid(const ::std::string& value);
  inline void set_srid(const char* value);
  inline void set_srid(const char* value, size_t size);
  inline ::std::string* mutable_srid();
  inline ::std::string* release_srid();
  inline void set_allocated_srid(::std::string* srid);

  // @@protoc_insertion_point(class_scope:PBNetTest.ConnectRelease)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_spyid();
  inline void clear_has_spyid();
  inline void set_has_srid();
  inline void clear_has_srid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PBNetTest::OperationStatus* status_;
  ::std::string* spyid_;
  ::std::string* srid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBNetTest_2eproto();
  friend void protobuf_AssignDesc_PBNetTest_2eproto();
  friend void protobuf_ShutdownFile_PBNetTest_2eproto();

  void InitAsDefaultInstance();
  static ConnectRelease* default_instance_;
};
// -------------------------------------------------------------------

class EchoReqRes : public ::google::protobuf::Message {
 public:
  EchoReqRes();
  virtual ~EchoReqRes();

  EchoReqRes(const EchoReqRes& from);

  inline EchoReqRes& operator=(const EchoReqRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EchoReqRes& default_instance();

  void Swap(EchoReqRes* other);

  // implements Message ----------------------------------------------

  EchoReqRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EchoReqRes& from);
  void MergeFrom(const EchoReqRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PBNetTest.EchoReqRes)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_PBNetTest_2eproto();
  friend void protobuf_AssignDesc_PBNetTest_2eproto();
  friend void protobuf_ShutdownFile_PBNetTest_2eproto();

  void InitAsDefaultInstance();
  static EchoReqRes* default_instance_;
};
// -------------------------------------------------------------------

class CallProcessRequest : public ::google::protobuf::Message {
 public:
  CallProcessRequest();
  virtual ~CallProcessRequest();

  CallProcessRequest(const CallProcessRequest& from);

  inline CallProcessRequest& operator=(const CallProcessRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CallProcessRequest& default_instance();

  void Swap(CallProcessRequest* other);

  // implements Message ----------------------------------------------

  CallProcessRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CallProcessRequest& from);
  void MergeFrom(const CallProcessRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string callid = 1;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 1;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // required .PBNetTest.AudioRecordMode flag = 2;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 2;
  inline ::PBNetTest::AudioRecordMode flag() const;
  inline void set_flag(::PBNetTest::AudioRecordMode value);

  // required int32 terminals = 3;
  inline bool has_terminals() const;
  inline void clear_terminals();
  static const int kTerminalsFieldNumber = 3;
  inline ::google::protobuf::int32 terminals() const;
  inline void set_terminals(::google::protobuf::int32 value);

  // required .PBNetTest.AudioChannelType channeltype = 4;
  inline bool has_channeltype() const;
  inline void clear_channeltype();
  static const int kChanneltypeFieldNumber = 4;
  inline ::PBNetTest::AudioChannelType channeltype() const;
  inline void set_channeltype(::PBNetTest::AudioChannelType value);

  // required .PBNetTest.AudioTransFlag transflag = 5 [default = ATF_NotTrans];
  inline bool has_transflag() const;
  inline void clear_transflag();
  static const int kTransflagFieldNumber = 5;
  inline ::PBNetTest::AudioTransFlag transflag() const;
  inline void set_transflag(::PBNetTest::AudioTransFlag value);

  // optional string caller = 6;
  inline bool has_caller() const;
  inline void clear_caller();
  static const int kCallerFieldNumber = 6;
  inline const ::std::string& caller() const;
  inline void set_caller(const ::std::string& value);
  inline void set_caller(const char* value);
  inline void set_caller(const char* value, size_t size);
  inline ::std::string* mutable_caller();
  inline ::std::string* release_caller();
  inline void set_allocated_caller(::std::string* caller);

  // optional string callee = 7;
  inline bool has_callee() const;
  inline void clear_callee();
  static const int kCalleeFieldNumber = 7;
  inline const ::std::string& callee() const;
  inline void set_callee(const ::std::string& value);
  inline void set_callee(const char* value);
  inline void set_callee(const char* value, size_t size);
  inline ::std::string* mutable_callee();
  inline ::std::string* release_callee();
  inline void set_allocated_callee(::std::string* callee);

  // optional string third = 8;
  inline bool has_third() const;
  inline void clear_third();
  static const int kThirdFieldNumber = 8;
  inline const ::std::string& third() const;
  inline void set_third(const ::std::string& value);
  inline void set_third(const char* value);
  inline void set_third(const char* value, size_t size);
  inline ::std::string* mutable_third();
  inline ::std::string* release_third();
  inline void set_allocated_third(::std::string* third);

  // optional uint64 starttime = 9;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 9;
  inline ::google::protobuf::uint64 starttime() const;
  inline void set_starttime(::google::protobuf::uint64 value);

  // optional uint64 endtime = 10;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 10;
  inline ::google::protobuf::uint64 endtime() const;
  inline void set_endtime(::google::protobuf::uint64 value);

  // optional uint32 recogflag = 11 [default = 7];
  inline bool has_recogflag() const;
  inline void clear_recogflag();
  static const int kRecogflagFieldNumber = 11;
  inline ::google::protobuf::uint32 recogflag() const;
  inline void set_recogflag(::google::protobuf::uint32 value);

  // optional .PBNetTest.FileAcquireMethod method = 12 [default = FAM_URL];
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 12;
  inline ::PBNetTest::FileAcquireMethod method() const;
  inline void set_method(::PBNetTest::FileAcquireMethod value);

  // optional .PBNetTest.PhoneNumber callerappendix = 13;
  inline bool has_callerappendix() const;
  inline void clear_callerappendix();
  static const int kCallerappendixFieldNumber = 13;
  inline const ::PBNetTest::PhoneNumber& callerappendix() const;
  inline ::PBNetTest::PhoneNumber* mutable_callerappendix();
  inline ::PBNetTest::PhoneNumber* release_callerappendix();
  inline void set_allocated_callerappendix(::PBNetTest::PhoneNumber* callerappendix);

  // optional .PBNetTest.PhoneNumber calleeappendix = 14;
  inline bool has_calleeappendix() const;
  inline void clear_calleeappendix();
  static const int kCalleeappendixFieldNumber = 14;
  inline const ::PBNetTest::PhoneNumber& calleeappendix() const;
  inline ::PBNetTest::PhoneNumber* mutable_calleeappendix();
  inline ::PBNetTest::PhoneNumber* release_calleeappendix();
  inline void set_allocated_calleeappendix(::PBNetTest::PhoneNumber* calleeappendix);

  // optional .PBNetTest.PhoneNumber thirdappendix = 15;
  inline bool has_thirdappendix() const;
  inline void clear_thirdappendix();
  static const int kThirdappendixFieldNumber = 15;
  inline const ::PBNetTest::PhoneNumber& thirdappendix() const;
  inline ::PBNetTest::PhoneNumber* mutable_thirdappendix();
  inline ::PBNetTest::PhoneNumber* release_thirdappendix();
  inline void set_allocated_thirdappendix(::PBNetTest::PhoneNumber* thirdappendix);

  // optional .PBNetTest.PriorityType priority = 16 [default = PT_Normal];
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 16;
  inline ::PBNetTest::PriorityType priority() const;
  inline void set_priority(::PBNetTest::PriorityType value);

  // optional .PBNetTest.SystemCode syscode = 17;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 17;
  inline const ::PBNetTest::SystemCode& syscode() const;
  inline ::PBNetTest::SystemCode* mutable_syscode();
  inline ::PBNetTest::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBNetTest::SystemCode* syscode);

  // optional bool isimport = 18;
  inline bool has_isimport() const;
  inline void clear_isimport();
  static const int kIsimportFieldNumber = 18;
  inline bool isimport() const;
  inline void set_isimport(bool value);

  // repeated .PBNetTest.FileLocationNotify voicefiles = 19;
  inline int voicefiles_size() const;
  inline void clear_voicefiles();
  static const int kVoicefilesFieldNumber = 19;
  inline const ::PBNetTest::FileLocationNotify& voicefiles(int index) const;
  inline ::PBNetTest::FileLocationNotify* mutable_voicefiles(int index);
  inline ::PBNetTest::FileLocationNotify* add_voicefiles();
  inline const ::google::protobuf::RepeatedPtrField< ::PBNetTest::FileLocationNotify >&
      voicefiles() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBNetTest::FileLocationNotify >*
      mutable_voicefiles();

  // @@protoc_insertion_point(class_scope:PBNetTest.CallProcessRequest)
 private:
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_terminals();
  inline void clear_has_terminals();
  inline void set_has_channeltype();
  inline void clear_has_channeltype();
  inline void set_has_transflag();
  inline void clear_has_transflag();
  inline void set_has_caller();
  inline void clear_has_caller();
  inline void set_has_callee();
  inline void clear_has_callee();
  inline void set_has_third();
  inline void clear_has_third();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_recogflag();
  inline void clear_has_recogflag();
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_callerappendix();
  inline void clear_has_callerappendix();
  inline void set_has_calleeappendix();
  inline void clear_has_calleeappendix();
  inline void set_has_thirdappendix();
  inline void clear_has_thirdappendix();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_syscode();
  inline void clear_has_syscode();
  inline void set_has_isimport();
  inline void clear_has_isimport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* callid_;
  int flag_;
  ::google::protobuf::int32 terminals_;
  int channeltype_;
  int transflag_;
  ::std::string* caller_;
  ::std::string* callee_;
  ::std::string* third_;
  ::google::protobuf::uint64 starttime_;
  ::google::protobuf::uint64 endtime_;
  ::google::protobuf::uint32 recogflag_;
  int method_;
  ::PBNetTest::PhoneNumber* callerappendix_;
  ::PBNetTest::PhoneNumber* calleeappendix_;
  ::PBNetTest::PhoneNumber* thirdappendix_;
  ::PBNetTest::SystemCode* syscode_;
  int priority_;
  bool isimport_;
  ::google::protobuf::RepeatedPtrField< ::PBNetTest::FileLocationNotify > voicefiles_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_PBNetTest_2eproto();
  friend void protobuf_AssignDesc_PBNetTest_2eproto();
  friend void protobuf_ShutdownFile_PBNetTest_2eproto();

  void InitAsDefaultInstance();
  static CallProcessRequest* default_instance_;
};
// -------------------------------------------------------------------

class FileLocationNotify : public ::google::protobuf::Message {
 public:
  FileLocationNotify();
  virtual ~FileLocationNotify();

  FileLocationNotify(const FileLocationNotify& from);

  inline FileLocationNotify& operator=(const FileLocationNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileLocationNotify& default_instance();

  void Swap(FileLocationNotify* other);

  // implements Message ----------------------------------------------

  FileLocationNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileLocationNotify& from);
  void MergeFrom(const FileLocationNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string callid = 1;
  inline bool has_callid() const;
  inline void clear_callid();
  static const int kCallidFieldNumber = 1;
  inline const ::std::string& callid() const;
  inline void set_callid(const ::std::string& value);
  inline void set_callid(const char* value);
  inline void set_callid(const char* value, size_t size);
  inline ::std::string* mutable_callid();
  inline ::std::string* release_callid();
  inline void set_allocated_callid(::std::string* callid);

  // required .PBNetTest.AudioFileTag filetag = 2;
  inline bool has_filetag() const;
  inline void clear_filetag();
  static const int kFiletagFieldNumber = 2;
  inline ::PBNetTest::AudioFileTag filetag() const;
  inline void set_filetag(::PBNetTest::AudioFileTag value);

  // required string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required .PBNetTest.AudioEncodingTag code = 4;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 4;
  inline ::PBNetTest::AudioEncodingTag code() const;
  inline void set_code(::PBNetTest::AudioEncodingTag value);

  // optional .PBNetTest.SystemCode syscode = 5;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 5;
  inline const ::PBNetTest::SystemCode& syscode() const;
  inline ::PBNetTest::SystemCode* mutable_syscode();
  inline ::PBNetTest::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBNetTest::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBNetTest.FileLocationNotify)
 private:
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_filetag();
  inline void clear_has_filetag();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* callid_;
  ::std::string* path_;
  int filetag_;
  int code_;
  ::PBNetTest::SystemCode* syscode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PBNetTest_2eproto();
  friend void protobuf_AssignDesc_PBNetTest_2eproto();
  friend void protobuf_ShutdownFile_PBNetTest_2eproto();

  void InitAsDefaultInstance();
  static FileLocationNotify* default_instance_;
};
// -------------------------------------------------------------------

class SearchAbortRequest : public ::google::protobuf::Message {
 public:
  SearchAbortRequest();
  virtual ~SearchAbortRequest();

  SearchAbortRequest(const SearchAbortRequest& from);

  inline SearchAbortRequest& operator=(const SearchAbortRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchAbortRequest& default_instance();

  void Swap(SearchAbortRequest* other);

  // implements Message ----------------------------------------------

  SearchAbortRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchAbortRequest& from);
  void MergeFrom(const SearchAbortRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required .PBNetTest.SystemCode syscode = 2;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 2;
  inline const ::PBNetTest::SystemCode& syscode() const;
  inline ::PBNetTest::SystemCode* mutable_syscode();
  inline ::PBNetTest::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBNetTest::SystemCode* syscode);

  // required string aborttaskid = 3;
  inline bool has_aborttaskid() const;
  inline void clear_aborttaskid();
  static const int kAborttaskidFieldNumber = 3;
  inline const ::std::string& aborttaskid() const;
  inline void set_aborttaskid(const ::std::string& value);
  inline void set_aborttaskid(const char* value);
  inline void set_aborttaskid(const char* value, size_t size);
  inline ::std::string* mutable_aborttaskid();
  inline ::std::string* release_aborttaskid();
  inline void set_allocated_aborttaskid(::std::string* aborttaskid);

  // @@protoc_insertion_point(class_scope:PBNetTest.SearchAbortRequest)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_syscode();
  inline void clear_has_syscode();
  inline void set_has_aborttaskid();
  inline void clear_has_aborttaskid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::PBNetTest::SystemCode* syscode_;
  ::std::string* aborttaskid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBNetTest_2eproto();
  friend void protobuf_AssignDesc_PBNetTest_2eproto();
  friend void protobuf_ShutdownFile_PBNetTest_2eproto();

  void InitAsDefaultInstance();
  static SearchAbortRequest* default_instance_;
};
// -------------------------------------------------------------------

class SearchResponse : public ::google::protobuf::Message {
 public:
  SearchResponse();
  virtual ~SearchResponse();

  SearchResponse(const SearchResponse& from);

  inline SearchResponse& operator=(const SearchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchResponse& default_instance();

  void Swap(SearchResponse* other);

  // implements Message ----------------------------------------------

  SearchResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchResponse& from);
  void MergeFrom(const SearchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required .PBNetTest.SystemCode syscode = 2;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 2;
  inline const ::PBNetTest::SystemCode& syscode() const;
  inline ::PBNetTest::SystemCode* mutable_syscode();
  inline ::PBNetTest::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBNetTest::SystemCode* syscode);

  // required .PBNetTest.OperationStatus status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline const ::PBNetTest::OperationStatus& status() const;
  inline ::PBNetTest::OperationStatus* mutable_status();
  inline ::PBNetTest::OperationStatus* release_status();
  inline void set_allocated_status(::PBNetTest::OperationStatus* status);

  // @@protoc_insertion_point(class_scope:PBNetTest.SearchResponse)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_syscode();
  inline void clear_has_syscode();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::PBNetTest::SystemCode* syscode_;
  ::PBNetTest::OperationStatus* status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBNetTest_2eproto();
  friend void protobuf_AssignDesc_PBNetTest_2eproto();
  friend void protobuf_ShutdownFile_PBNetTest_2eproto();

  void InitAsDefaultInstance();
  static SearchResponse* default_instance_;
};
// -------------------------------------------------------------------

class AlarmNotify : public ::google::protobuf::Message {
 public:
  AlarmNotify();
  virtual ~AlarmNotify();

  AlarmNotify(const AlarmNotify& from);

  inline AlarmNotify& operator=(const AlarmNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlarmNotify& default_instance();

  void Swap(AlarmNotify* other);

  // implements Message ----------------------------------------------

  AlarmNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlarmNotify& from);
  void MergeFrom(const AlarmNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string alarmtime = 1;
  inline bool has_alarmtime() const;
  inline void clear_alarmtime();
  static const int kAlarmtimeFieldNumber = 1;
  inline const ::std::string& alarmtime() const;
  inline void set_alarmtime(const ::std::string& value);
  inline void set_alarmtime(const char* value);
  inline void set_alarmtime(const char* value, size_t size);
  inline ::std::string* mutable_alarmtime();
  inline ::std::string* release_alarmtime();
  inline void set_allocated_alarmtime(::std::string* alarmtime);

  // required .PBNetTest.AlarmLevel level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::PBNetTest::AlarmLevel level() const;
  inline void set_level(::PBNetTest::AlarmLevel value);

  // required string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // required string modulename = 4;
  inline bool has_modulename() const;
  inline void clear_modulename();
  static const int kModulenameFieldNumber = 4;
  inline const ::std::string& modulename() const;
  inline void set_modulename(const ::std::string& value);
  inline void set_modulename(const char* value);
  inline void set_modulename(const char* value, size_t size);
  inline ::std::string* mutable_modulename();
  inline ::std::string* release_modulename();
  inline void set_allocated_modulename(::std::string* modulename);

  // optional .PBNetTest.SystemCode syscode = 5;
  inline bool has_syscode() const;
  inline void clear_syscode();
  static const int kSyscodeFieldNumber = 5;
  inline const ::PBNetTest::SystemCode& syscode() const;
  inline ::PBNetTest::SystemCode* mutable_syscode();
  inline ::PBNetTest::SystemCode* release_syscode();
  inline void set_allocated_syscode(::PBNetTest::SystemCode* syscode);

  // @@protoc_insertion_point(class_scope:PBNetTest.AlarmNotify)
 private:
  inline void set_has_alarmtime();
  inline void clear_has_alarmtime();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_modulename();
  inline void clear_has_modulename();
  inline void set_has_syscode();
  inline void clear_has_syscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* alarmtime_;
  ::std::string* content_;
  ::std::string* modulename_;
  ::PBNetTest::SystemCode* syscode_;
  int level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PBNetTest_2eproto();
  friend void protobuf_AssignDesc_PBNetTest_2eproto();
  friend void protobuf_ShutdownFile_PBNetTest_2eproto();

  void InitAsDefaultInstance();
  static AlarmNotify* default_instance_;
};
// -------------------------------------------------------------------

class OperationStatus : public ::google::protobuf::Message {
 public:
  OperationStatus();
  virtual ~OperationStatus();

  OperationStatus(const OperationStatus& from);

  inline OperationStatus& operator=(const OperationStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationStatus& default_instance();

  void Swap(OperationStatus* other);

  // implements Message ----------------------------------------------

  OperationStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationStatus& from);
  void MergeFrom(const OperationStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:PBNetTest.OperationStatus)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* description_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_PBNetTest_2eproto();
  friend void protobuf_AssignDesc_PBNetTest_2eproto();
  friend void protobuf_ShutdownFile_PBNetTest_2eproto();

  void InitAsDefaultInstance();
  static OperationStatus* default_instance_;
};
// -------------------------------------------------------------------

class SystemCode : public ::google::protobuf::Message {
 public:
  SystemCode();
  virtual ~SystemCode();

  SystemCode(const SystemCode& from);

  inline SystemCode& operator=(const SystemCode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemCode& default_instance();

  void Swap(SystemCode* other);

  // implements Message ----------------------------------------------

  SystemCode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemCode& from);
  void MergeFrom(const SystemCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string spyid = 1;
  inline bool has_spyid() const;
  inline void clear_spyid();
  static const int kSpyidFieldNumber = 1;
  inline const ::std::string& spyid() const;
  inline void set_spyid(const ::std::string& value);
  inline void set_spyid(const char* value);
  inline void set_spyid(const char* value, size_t size);
  inline ::std::string* mutable_spyid();
  inline ::std::string* release_spyid();
  inline void set_allocated_spyid(::std::string* spyid);

  // optional string srid = 2;
  inline bool has_srid() const;
  inline void clear_srid();
  static const int kSridFieldNumber = 2;
  inline const ::std::string& srid() const;
  inline void set_srid(const ::std::string& value);
  inline void set_srid(const char* value);
  inline void set_srid(const char* value, size_t size);
  inline ::std::string* mutable_srid();
  inline ::std::string* release_srid();
  inline void set_allocated_srid(::std::string* srid);

  // repeated string datasource = 3;
  inline int datasource_size() const;
  inline void clear_datasource();
  static const int kDatasourceFieldNumber = 3;
  inline const ::std::string& datasource(int index) const;
  inline ::std::string* mutable_datasource(int index);
  inline void set_datasource(int index, const ::std::string& value);
  inline void set_datasource(int index, const char* value);
  inline void set_datasource(int index, const char* value, size_t size);
  inline ::std::string* add_datasource();
  inline void add_datasource(const ::std::string& value);
  inline void add_datasource(const char* value);
  inline void add_datasource(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& datasource() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_datasource();

  // @@protoc_insertion_point(class_scope:PBNetTest.SystemCode)
 private:
  inline void set_has_spyid();
  inline void clear_has_spyid();
  inline void set_has_srid();
  inline void clear_has_srid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* spyid_;
  ::std::string* srid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> datasource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PBNetTest_2eproto();
  friend void protobuf_AssignDesc_PBNetTest_2eproto();
  friend void protobuf_ShutdownFile_PBNetTest_2eproto();

  void InitAsDefaultInstance();
  static SystemCode* default_instance_;
};
// -------------------------------------------------------------------

class PhoneNumber : public ::google::protobuf::Message {
 public:
  PhoneNumber();
  virtual ~PhoneNumber();

  PhoneNumber(const PhoneNumber& from);

  inline PhoneNumber& operator=(const PhoneNumber& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PhoneNumber& default_instance();

  void Swap(PhoneNumber* other);

  // implements Message ----------------------------------------------

  PhoneNumber* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PhoneNumber& from);
  void MergeFrom(const PhoneNumber& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string telnumber = 1;
  inline bool has_telnumber() const;
  inline void clear_telnumber();
  static const int kTelnumberFieldNumber = 1;
  inline const ::std::string& telnumber() const;
  inline void set_telnumber(const ::std::string& value);
  inline void set_telnumber(const char* value);
  inline void set_telnumber(const char* value, size_t size);
  inline ::std::string* mutable_telnumber();
  inline ::std::string* release_telnumber();
  inline void set_allocated_telnumber(::std::string* telnumber);

  // optional string countrycode = 2;
  inline bool has_countrycode() const;
  inline void clear_countrycode();
  static const int kCountrycodeFieldNumber = 2;
  inline const ::std::string& countrycode() const;
  inline void set_countrycode(const ::std::string& value);
  inline void set_countrycode(const char* value);
  inline void set_countrycode(const char* value, size_t size);
  inline ::std::string* mutable_countrycode();
  inline ::std::string* release_countrycode();
  inline void set_allocated_countrycode(::std::string* countrycode);

  // optional string provincecode = 3;
  inline bool has_provincecode() const;
  inline void clear_provincecode();
  static const int kProvincecodeFieldNumber = 3;
  inline const ::std::string& provincecode() const;
  inline void set_provincecode(const ::std::string& value);
  inline void set_provincecode(const char* value);
  inline void set_provincecode(const char* value, size_t size);
  inline ::std::string* mutable_provincecode();
  inline ::std::string* release_provincecode();
  inline void set_allocated_provincecode(::std::string* provincecode);

  // optional string areacode = 4;
  inline bool has_areacode() const;
  inline void clear_areacode();
  static const int kAreacodeFieldNumber = 4;
  inline const ::std::string& areacode() const;
  inline void set_areacode(const ::std::string& value);
  inline void set_areacode(const char* value);
  inline void set_areacode(const char* value, size_t size);
  inline ::std::string* mutable_areacode();
  inline ::std::string* release_areacode();
  inline void set_allocated_areacode(::std::string* areacode);

  // @@protoc_insertion_point(class_scope:PBNetTest.PhoneNumber)
 private:
  inline void set_has_telnumber();
  inline void clear_has_telnumber();
  inline void set_has_countrycode();
  inline void clear_has_countrycode();
  inline void set_has_provincecode();
  inline void clear_has_provincecode();
  inline void set_has_areacode();
  inline void clear_has_areacode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* telnumber_;
  ::std::string* countrycode_;
  ::std::string* provincecode_;
  ::std::string* areacode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_PBNetTest_2eproto();
  friend void protobuf_AssignDesc_PBNetTest_2eproto();
  friend void protobuf_ShutdownFile_PBNetTest_2eproto();

  void InitAsDefaultInstance();
  static PhoneNumber* default_instance_;
};
// ===================================================================


// ===================================================================

// HeadMsg

// required fixed32 syn = 1 [default = 255];
inline bool HeadMsg::has_syn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeadMsg::set_has_syn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeadMsg::clear_has_syn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeadMsg::clear_syn() {
  syn_ = 255u;
  clear_has_syn();
}
inline ::google::protobuf::uint32 HeadMsg::syn() const {
  return syn_;
}
inline void HeadMsg::set_syn(::google::protobuf::uint32 value) {
  set_has_syn();
  syn_ = value;
}

// required fixed32 pro = 2 [default = 100];
inline bool HeadMsg::has_pro() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeadMsg::set_has_pro() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeadMsg::clear_has_pro() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeadMsg::clear_pro() {
  pro_ = 100u;
  clear_has_pro();
}
inline ::google::protobuf::uint32 HeadMsg::pro() const {
  return pro_;
}
inline void HeadMsg::set_pro(::google::protobuf::uint32 value) {
  set_has_pro();
  pro_ = value;
}

// required fixed32 type = 3;
inline bool HeadMsg::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeadMsg::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeadMsg::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeadMsg::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 HeadMsg::type() const {
  return type_;
}
inline void HeadMsg::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required fixed64 seqno = 4;
inline bool HeadMsg::has_seqno() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeadMsg::set_has_seqno() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeadMsg::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeadMsg::clear_seqno() {
  seqno_ = GOOGLE_ULONGLONG(0);
  clear_has_seqno();
}
inline ::google::protobuf::uint64 HeadMsg::seqno() const {
  return seqno_;
}
inline void HeadMsg::set_seqno(::google::protobuf::uint64 value) {
  set_has_seqno();
  seqno_ = value;
}

// required fixed32 len = 5;
inline bool HeadMsg::has_len() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HeadMsg::set_has_len() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HeadMsg::clear_has_len() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HeadMsg::clear_len() {
  len_ = 0u;
  clear_has_len();
}
inline ::google::protobuf::uint32 HeadMsg::len() const {
  return len_;
}
inline void HeadMsg::set_len(::google::protobuf::uint32 value) {
  set_has_len();
  len_ = value;
}

// -------------------------------------------------------------------

// ConnectRequest

// required string spyid = 1;
inline bool ConnectRequest::has_spyid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectRequest::set_has_spyid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectRequest::clear_has_spyid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectRequest::clear_spyid() {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    spyid_->clear();
  }
  clear_has_spyid();
}
inline const ::std::string& ConnectRequest::spyid() const {
  return *spyid_;
}
inline void ConnectRequest::set_spyid(const ::std::string& value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void ConnectRequest::set_spyid(const char* value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void ConnectRequest::set_spyid(const char* value, size_t size) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectRequest::mutable_spyid() {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  return spyid_;
}
inline ::std::string* ConnectRequest::release_spyid() {
  clear_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spyid_;
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectRequest::set_allocated_spyid(::std::string* spyid) {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    delete spyid_;
  }
  if (spyid) {
    set_has_spyid();
    spyid_ = spyid;
  } else {
    clear_has_spyid();
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string srid = 2;
inline bool ConnectRequest::has_srid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectRequest::set_has_srid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectRequest::clear_has_srid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectRequest::clear_srid() {
  if (srid_ != &::google::protobuf::internal::kEmptyString) {
    srid_->clear();
  }
  clear_has_srid();
}
inline const ::std::string& ConnectRequest::srid() const {
  return *srid_;
}
inline void ConnectRequest::set_srid(const ::std::string& value) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(value);
}
inline void ConnectRequest::set_srid(const char* value) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(value);
}
inline void ConnectRequest::set_srid(const char* value, size_t size) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectRequest::mutable_srid() {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  return srid_;
}
inline ::std::string* ConnectRequest::release_srid() {
  clear_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srid_;
    srid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectRequest::set_allocated_srid(::std::string* srid) {
  if (srid_ != &::google::protobuf::internal::kEmptyString) {
    delete srid_;
  }
  if (srid) {
    set_has_srid();
    srid_ = srid;
  } else {
    clear_has_srid();
    srid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ConnectResponse

// required .PBNetTest.OperationStatus status = 1;
inline bool ConnectResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectResponse::clear_status() {
  if (status_ != NULL) status_->::PBNetTest::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBNetTest::OperationStatus& ConnectResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBNetTest::OperationStatus* ConnectResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBNetTest::OperationStatus;
  return status_;
}
inline ::PBNetTest::OperationStatus* ConnectResponse::release_status() {
  clear_has_status();
  ::PBNetTest::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void ConnectResponse::set_allocated_status(::PBNetTest::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// required string spyid = 2;
inline bool ConnectResponse::has_spyid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectResponse::set_has_spyid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectResponse::clear_has_spyid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectResponse::clear_spyid() {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    spyid_->clear();
  }
  clear_has_spyid();
}
inline const ::std::string& ConnectResponse::spyid() const {
  return *spyid_;
}
inline void ConnectResponse::set_spyid(const ::std::string& value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void ConnectResponse::set_spyid(const char* value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void ConnectResponse::set_spyid(const char* value, size_t size) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectResponse::mutable_spyid() {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  return spyid_;
}
inline ::std::string* ConnectResponse::release_spyid() {
  clear_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spyid_;
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectResponse::set_allocated_spyid(::std::string* spyid) {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    delete spyid_;
  }
  if (spyid) {
    set_has_spyid();
    spyid_ = spyid;
  } else {
    clear_has_spyid();
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string srid = 3;
inline bool ConnectResponse::has_srid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectResponse::set_has_srid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectResponse::clear_has_srid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectResponse::clear_srid() {
  if (srid_ != &::google::protobuf::internal::kEmptyString) {
    srid_->clear();
  }
  clear_has_srid();
}
inline const ::std::string& ConnectResponse::srid() const {
  return *srid_;
}
inline void ConnectResponse::set_srid(const ::std::string& value) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(value);
}
inline void ConnectResponse::set_srid(const char* value) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(value);
}
inline void ConnectResponse::set_srid(const char* value, size_t size) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectResponse::mutable_srid() {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  return srid_;
}
inline ::std::string* ConnectResponse::release_srid() {
  clear_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srid_;
    srid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectResponse::set_allocated_srid(::std::string* srid) {
  if (srid_ != &::google::protobuf::internal::kEmptyString) {
    delete srid_;
  }
  if (srid) {
    set_has_srid();
    srid_ = srid;
  } else {
    clear_has_srid();
    srid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ConnectRelease

// required .PBNetTest.OperationStatus status = 1;
inline bool ConnectRelease::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectRelease::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectRelease::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectRelease::clear_status() {
  if (status_ != NULL) status_->::PBNetTest::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBNetTest::OperationStatus& ConnectRelease::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBNetTest::OperationStatus* ConnectRelease::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBNetTest::OperationStatus;
  return status_;
}
inline ::PBNetTest::OperationStatus* ConnectRelease::release_status() {
  clear_has_status();
  ::PBNetTest::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void ConnectRelease::set_allocated_status(::PBNetTest::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// required string spyid = 2;
inline bool ConnectRelease::has_spyid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectRelease::set_has_spyid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectRelease::clear_has_spyid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectRelease::clear_spyid() {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    spyid_->clear();
  }
  clear_has_spyid();
}
inline const ::std::string& ConnectRelease::spyid() const {
  return *spyid_;
}
inline void ConnectRelease::set_spyid(const ::std::string& value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void ConnectRelease::set_spyid(const char* value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void ConnectRelease::set_spyid(const char* value, size_t size) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectRelease::mutable_spyid() {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  return spyid_;
}
inline ::std::string* ConnectRelease::release_spyid() {
  clear_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spyid_;
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectRelease::set_allocated_spyid(::std::string* spyid) {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    delete spyid_;
  }
  if (spyid) {
    set_has_spyid();
    spyid_ = spyid;
  } else {
    clear_has_spyid();
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string srid = 3;
inline bool ConnectRelease::has_srid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectRelease::set_has_srid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectRelease::clear_has_srid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectRelease::clear_srid() {
  if (srid_ != &::google::protobuf::internal::kEmptyString) {
    srid_->clear();
  }
  clear_has_srid();
}
inline const ::std::string& ConnectRelease::srid() const {
  return *srid_;
}
inline void ConnectRelease::set_srid(const ::std::string& value) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(value);
}
inline void ConnectRelease::set_srid(const char* value) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(value);
}
inline void ConnectRelease::set_srid(const char* value, size_t size) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectRelease::mutable_srid() {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  return srid_;
}
inline ::std::string* ConnectRelease::release_srid() {
  clear_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srid_;
    srid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectRelease::set_allocated_srid(::std::string* srid) {
  if (srid_ != &::google::protobuf::internal::kEmptyString) {
    delete srid_;
  }
  if (srid) {
    set_has_srid();
    srid_ = srid;
  } else {
    clear_has_srid();
    srid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EchoReqRes

// required uint32 timestamp = 1;
inline bool EchoReqRes::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EchoReqRes::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EchoReqRes::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EchoReqRes::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 EchoReqRes::timestamp() const {
  return timestamp_;
}
inline void EchoReqRes::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// CallProcessRequest

// required string callid = 1;
inline bool CallProcessRequest::has_callid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CallProcessRequest::set_has_callid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CallProcessRequest::clear_has_callid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CallProcessRequest::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& CallProcessRequest::callid() const {
  return *callid_;
}
inline void CallProcessRequest::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void CallProcessRequest::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void CallProcessRequest::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CallProcessRequest::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* CallProcessRequest::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CallProcessRequest::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBNetTest.AudioRecordMode flag = 2;
inline bool CallProcessRequest::has_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CallProcessRequest::set_has_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CallProcessRequest::clear_has_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CallProcessRequest::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::PBNetTest::AudioRecordMode CallProcessRequest::flag() const {
  return static_cast< ::PBNetTest::AudioRecordMode >(flag_);
}
inline void CallProcessRequest::set_flag(::PBNetTest::AudioRecordMode value) {
  assert(::PBNetTest::AudioRecordMode_IsValid(value));
  set_has_flag();
  flag_ = value;
}

// required int32 terminals = 3;
inline bool CallProcessRequest::has_terminals() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CallProcessRequest::set_has_terminals() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CallProcessRequest::clear_has_terminals() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CallProcessRequest::clear_terminals() {
  terminals_ = 0;
  clear_has_terminals();
}
inline ::google::protobuf::int32 CallProcessRequest::terminals() const {
  return terminals_;
}
inline void CallProcessRequest::set_terminals(::google::protobuf::int32 value) {
  set_has_terminals();
  terminals_ = value;
}

// required .PBNetTest.AudioChannelType channeltype = 4;
inline bool CallProcessRequest::has_channeltype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CallProcessRequest::set_has_channeltype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CallProcessRequest::clear_has_channeltype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CallProcessRequest::clear_channeltype() {
  channeltype_ = 0;
  clear_has_channeltype();
}
inline ::PBNetTest::AudioChannelType CallProcessRequest::channeltype() const {
  return static_cast< ::PBNetTest::AudioChannelType >(channeltype_);
}
inline void CallProcessRequest::set_channeltype(::PBNetTest::AudioChannelType value) {
  assert(::PBNetTest::AudioChannelType_IsValid(value));
  set_has_channeltype();
  channeltype_ = value;
}

// required .PBNetTest.AudioTransFlag transflag = 5 [default = ATF_NotTrans];
inline bool CallProcessRequest::has_transflag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CallProcessRequest::set_has_transflag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CallProcessRequest::clear_has_transflag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CallProcessRequest::clear_transflag() {
  transflag_ = 2;
  clear_has_transflag();
}
inline ::PBNetTest::AudioTransFlag CallProcessRequest::transflag() const {
  return static_cast< ::PBNetTest::AudioTransFlag >(transflag_);
}
inline void CallProcessRequest::set_transflag(::PBNetTest::AudioTransFlag value) {
  assert(::PBNetTest::AudioTransFlag_IsValid(value));
  set_has_transflag();
  transflag_ = value;
}

// optional string caller = 6;
inline bool CallProcessRequest::has_caller() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CallProcessRequest::set_has_caller() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CallProcessRequest::clear_has_caller() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CallProcessRequest::clear_caller() {
  if (caller_ != &::google::protobuf::internal::kEmptyString) {
    caller_->clear();
  }
  clear_has_caller();
}
inline const ::std::string& CallProcessRequest::caller() const {
  return *caller_;
}
inline void CallProcessRequest::set_caller(const ::std::string& value) {
  set_has_caller();
  if (caller_ == &::google::protobuf::internal::kEmptyString) {
    caller_ = new ::std::string;
  }
  caller_->assign(value);
}
inline void CallProcessRequest::set_caller(const char* value) {
  set_has_caller();
  if (caller_ == &::google::protobuf::internal::kEmptyString) {
    caller_ = new ::std::string;
  }
  caller_->assign(value);
}
inline void CallProcessRequest::set_caller(const char* value, size_t size) {
  set_has_caller();
  if (caller_ == &::google::protobuf::internal::kEmptyString) {
    caller_ = new ::std::string;
  }
  caller_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CallProcessRequest::mutable_caller() {
  set_has_caller();
  if (caller_ == &::google::protobuf::internal::kEmptyString) {
    caller_ = new ::std::string;
  }
  return caller_;
}
inline ::std::string* CallProcessRequest::release_caller() {
  clear_has_caller();
  if (caller_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = caller_;
    caller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CallProcessRequest::set_allocated_caller(::std::string* caller) {
  if (caller_ != &::google::protobuf::internal::kEmptyString) {
    delete caller_;
  }
  if (caller) {
    set_has_caller();
    caller_ = caller;
  } else {
    clear_has_caller();
    caller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string callee = 7;
inline bool CallProcessRequest::has_callee() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CallProcessRequest::set_has_callee() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CallProcessRequest::clear_has_callee() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CallProcessRequest::clear_callee() {
  if (callee_ != &::google::protobuf::internal::kEmptyString) {
    callee_->clear();
  }
  clear_has_callee();
}
inline const ::std::string& CallProcessRequest::callee() const {
  return *callee_;
}
inline void CallProcessRequest::set_callee(const ::std::string& value) {
  set_has_callee();
  if (callee_ == &::google::protobuf::internal::kEmptyString) {
    callee_ = new ::std::string;
  }
  callee_->assign(value);
}
inline void CallProcessRequest::set_callee(const char* value) {
  set_has_callee();
  if (callee_ == &::google::protobuf::internal::kEmptyString) {
    callee_ = new ::std::string;
  }
  callee_->assign(value);
}
inline void CallProcessRequest::set_callee(const char* value, size_t size) {
  set_has_callee();
  if (callee_ == &::google::protobuf::internal::kEmptyString) {
    callee_ = new ::std::string;
  }
  callee_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CallProcessRequest::mutable_callee() {
  set_has_callee();
  if (callee_ == &::google::protobuf::internal::kEmptyString) {
    callee_ = new ::std::string;
  }
  return callee_;
}
inline ::std::string* CallProcessRequest::release_callee() {
  clear_has_callee();
  if (callee_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callee_;
    callee_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CallProcessRequest::set_allocated_callee(::std::string* callee) {
  if (callee_ != &::google::protobuf::internal::kEmptyString) {
    delete callee_;
  }
  if (callee) {
    set_has_callee();
    callee_ = callee;
  } else {
    clear_has_callee();
    callee_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string third = 8;
inline bool CallProcessRequest::has_third() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CallProcessRequest::set_has_third() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CallProcessRequest::clear_has_third() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CallProcessRequest::clear_third() {
  if (third_ != &::google::protobuf::internal::kEmptyString) {
    third_->clear();
  }
  clear_has_third();
}
inline const ::std::string& CallProcessRequest::third() const {
  return *third_;
}
inline void CallProcessRequest::set_third(const ::std::string& value) {
  set_has_third();
  if (third_ == &::google::protobuf::internal::kEmptyString) {
    third_ = new ::std::string;
  }
  third_->assign(value);
}
inline void CallProcessRequest::set_third(const char* value) {
  set_has_third();
  if (third_ == &::google::protobuf::internal::kEmptyString) {
    third_ = new ::std::string;
  }
  third_->assign(value);
}
inline void CallProcessRequest::set_third(const char* value, size_t size) {
  set_has_third();
  if (third_ == &::google::protobuf::internal::kEmptyString) {
    third_ = new ::std::string;
  }
  third_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CallProcessRequest::mutable_third() {
  set_has_third();
  if (third_ == &::google::protobuf::internal::kEmptyString) {
    third_ = new ::std::string;
  }
  return third_;
}
inline ::std::string* CallProcessRequest::release_third() {
  clear_has_third();
  if (third_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = third_;
    third_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CallProcessRequest::set_allocated_third(::std::string* third) {
  if (third_ != &::google::protobuf::internal::kEmptyString) {
    delete third_;
  }
  if (third) {
    set_has_third();
    third_ = third;
  } else {
    clear_has_third();
    third_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 starttime = 9;
inline bool CallProcessRequest::has_starttime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CallProcessRequest::set_has_starttime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CallProcessRequest::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CallProcessRequest::clear_starttime() {
  starttime_ = GOOGLE_ULONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::uint64 CallProcessRequest::starttime() const {
  return starttime_;
}
inline void CallProcessRequest::set_starttime(::google::protobuf::uint64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional uint64 endtime = 10;
inline bool CallProcessRequest::has_endtime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CallProcessRequest::set_has_endtime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CallProcessRequest::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CallProcessRequest::clear_endtime() {
  endtime_ = GOOGLE_ULONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::uint64 CallProcessRequest::endtime() const {
  return endtime_;
}
inline void CallProcessRequest::set_endtime(::google::protobuf::uint64 value) {
  set_has_endtime();
  endtime_ = value;
}

// optional uint32 recogflag = 11 [default = 7];
inline bool CallProcessRequest::has_recogflag() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CallProcessRequest::set_has_recogflag() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CallProcessRequest::clear_has_recogflag() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CallProcessRequest::clear_recogflag() {
  recogflag_ = 7u;
  clear_has_recogflag();
}
inline ::google::protobuf::uint32 CallProcessRequest::recogflag() const {
  return recogflag_;
}
inline void CallProcessRequest::set_recogflag(::google::protobuf::uint32 value) {
  set_has_recogflag();
  recogflag_ = value;
}

// optional .PBNetTest.FileAcquireMethod method = 12 [default = FAM_URL];
inline bool CallProcessRequest::has_method() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CallProcessRequest::set_has_method() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CallProcessRequest::clear_has_method() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CallProcessRequest::clear_method() {
  method_ = 1;
  clear_has_method();
}
inline ::PBNetTest::FileAcquireMethod CallProcessRequest::method() const {
  return static_cast< ::PBNetTest::FileAcquireMethod >(method_);
}
inline void CallProcessRequest::set_method(::PBNetTest::FileAcquireMethod value) {
  assert(::PBNetTest::FileAcquireMethod_IsValid(value));
  set_has_method();
  method_ = value;
}

// optional .PBNetTest.PhoneNumber callerappendix = 13;
inline bool CallProcessRequest::has_callerappendix() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CallProcessRequest::set_has_callerappendix() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CallProcessRequest::clear_has_callerappendix() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CallProcessRequest::clear_callerappendix() {
  if (callerappendix_ != NULL) callerappendix_->::PBNetTest::PhoneNumber::Clear();
  clear_has_callerappendix();
}
inline const ::PBNetTest::PhoneNumber& CallProcessRequest::callerappendix() const {
  return callerappendix_ != NULL ? *callerappendix_ : *default_instance_->callerappendix_;
}
inline ::PBNetTest::PhoneNumber* CallProcessRequest::mutable_callerappendix() {
  set_has_callerappendix();
  if (callerappendix_ == NULL) callerappendix_ = new ::PBNetTest::PhoneNumber;
  return callerappendix_;
}
inline ::PBNetTest::PhoneNumber* CallProcessRequest::release_callerappendix() {
  clear_has_callerappendix();
  ::PBNetTest::PhoneNumber* temp = callerappendix_;
  callerappendix_ = NULL;
  return temp;
}
inline void CallProcessRequest::set_allocated_callerappendix(::PBNetTest::PhoneNumber* callerappendix) {
  delete callerappendix_;
  callerappendix_ = callerappendix;
  if (callerappendix) {
    set_has_callerappendix();
  } else {
    clear_has_callerappendix();
  }
}

// optional .PBNetTest.PhoneNumber calleeappendix = 14;
inline bool CallProcessRequest::has_calleeappendix() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CallProcessRequest::set_has_calleeappendix() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CallProcessRequest::clear_has_calleeappendix() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CallProcessRequest::clear_calleeappendix() {
  if (calleeappendix_ != NULL) calleeappendix_->::PBNetTest::PhoneNumber::Clear();
  clear_has_calleeappendix();
}
inline const ::PBNetTest::PhoneNumber& CallProcessRequest::calleeappendix() const {
  return calleeappendix_ != NULL ? *calleeappendix_ : *default_instance_->calleeappendix_;
}
inline ::PBNetTest::PhoneNumber* CallProcessRequest::mutable_calleeappendix() {
  set_has_calleeappendix();
  if (calleeappendix_ == NULL) calleeappendix_ = new ::PBNetTest::PhoneNumber;
  return calleeappendix_;
}
inline ::PBNetTest::PhoneNumber* CallProcessRequest::release_calleeappendix() {
  clear_has_calleeappendix();
  ::PBNetTest::PhoneNumber* temp = calleeappendix_;
  calleeappendix_ = NULL;
  return temp;
}
inline void CallProcessRequest::set_allocated_calleeappendix(::PBNetTest::PhoneNumber* calleeappendix) {
  delete calleeappendix_;
  calleeappendix_ = calleeappendix;
  if (calleeappendix) {
    set_has_calleeappendix();
  } else {
    clear_has_calleeappendix();
  }
}

// optional .PBNetTest.PhoneNumber thirdappendix = 15;
inline bool CallProcessRequest::has_thirdappendix() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CallProcessRequest::set_has_thirdappendix() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CallProcessRequest::clear_has_thirdappendix() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CallProcessRequest::clear_thirdappendix() {
  if (thirdappendix_ != NULL) thirdappendix_->::PBNetTest::PhoneNumber::Clear();
  clear_has_thirdappendix();
}
inline const ::PBNetTest::PhoneNumber& CallProcessRequest::thirdappendix() const {
  return thirdappendix_ != NULL ? *thirdappendix_ : *default_instance_->thirdappendix_;
}
inline ::PBNetTest::PhoneNumber* CallProcessRequest::mutable_thirdappendix() {
  set_has_thirdappendix();
  if (thirdappendix_ == NULL) thirdappendix_ = new ::PBNetTest::PhoneNumber;
  return thirdappendix_;
}
inline ::PBNetTest::PhoneNumber* CallProcessRequest::release_thirdappendix() {
  clear_has_thirdappendix();
  ::PBNetTest::PhoneNumber* temp = thirdappendix_;
  thirdappendix_ = NULL;
  return temp;
}
inline void CallProcessRequest::set_allocated_thirdappendix(::PBNetTest::PhoneNumber* thirdappendix) {
  delete thirdappendix_;
  thirdappendix_ = thirdappendix;
  if (thirdappendix) {
    set_has_thirdappendix();
  } else {
    clear_has_thirdappendix();
  }
}

// optional .PBNetTest.PriorityType priority = 16 [default = PT_Normal];
inline bool CallProcessRequest::has_priority() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CallProcessRequest::set_has_priority() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CallProcessRequest::clear_has_priority() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CallProcessRequest::clear_priority() {
  priority_ = 2;
  clear_has_priority();
}
inline ::PBNetTest::PriorityType CallProcessRequest::priority() const {
  return static_cast< ::PBNetTest::PriorityType >(priority_);
}
inline void CallProcessRequest::set_priority(::PBNetTest::PriorityType value) {
  assert(::PBNetTest::PriorityType_IsValid(value));
  set_has_priority();
  priority_ = value;
}

// optional .PBNetTest.SystemCode syscode = 17;
inline bool CallProcessRequest::has_syscode() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CallProcessRequest::set_has_syscode() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CallProcessRequest::clear_has_syscode() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CallProcessRequest::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBNetTest::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBNetTest::SystemCode& CallProcessRequest::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBNetTest::SystemCode* CallProcessRequest::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBNetTest::SystemCode;
  return syscode_;
}
inline ::PBNetTest::SystemCode* CallProcessRequest::release_syscode() {
  clear_has_syscode();
  ::PBNetTest::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void CallProcessRequest::set_allocated_syscode(::PBNetTest::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// optional bool isimport = 18;
inline bool CallProcessRequest::has_isimport() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CallProcessRequest::set_has_isimport() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CallProcessRequest::clear_has_isimport() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CallProcessRequest::clear_isimport() {
  isimport_ = false;
  clear_has_isimport();
}
inline bool CallProcessRequest::isimport() const {
  return isimport_;
}
inline void CallProcessRequest::set_isimport(bool value) {
  set_has_isimport();
  isimport_ = value;
}

// repeated .PBNetTest.FileLocationNotify voicefiles = 19;
inline int CallProcessRequest::voicefiles_size() const {
  return voicefiles_.size();
}
inline void CallProcessRequest::clear_voicefiles() {
  voicefiles_.Clear();
}
inline const ::PBNetTest::FileLocationNotify& CallProcessRequest::voicefiles(int index) const {
  return voicefiles_.Get(index);
}
inline ::PBNetTest::FileLocationNotify* CallProcessRequest::mutable_voicefiles(int index) {
  return voicefiles_.Mutable(index);
}
inline ::PBNetTest::FileLocationNotify* CallProcessRequest::add_voicefiles() {
  return voicefiles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBNetTest::FileLocationNotify >&
CallProcessRequest::voicefiles() const {
  return voicefiles_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBNetTest::FileLocationNotify >*
CallProcessRequest::mutable_voicefiles() {
  return &voicefiles_;
}

// -------------------------------------------------------------------

// FileLocationNotify

// required string callid = 1;
inline bool FileLocationNotify::has_callid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileLocationNotify::set_has_callid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileLocationNotify::clear_has_callid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileLocationNotify::clear_callid() {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    callid_->clear();
  }
  clear_has_callid();
}
inline const ::std::string& FileLocationNotify::callid() const {
  return *callid_;
}
inline void FileLocationNotify::set_callid(const ::std::string& value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void FileLocationNotify::set_callid(const char* value) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(value);
}
inline void FileLocationNotify::set_callid(const char* value, size_t size) {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  callid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileLocationNotify::mutable_callid() {
  set_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    callid_ = new ::std::string;
  }
  return callid_;
}
inline ::std::string* FileLocationNotify::release_callid() {
  clear_has_callid();
  if (callid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callid_;
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileLocationNotify::set_allocated_callid(::std::string* callid) {
  if (callid_ != &::google::protobuf::internal::kEmptyString) {
    delete callid_;
  }
  if (callid) {
    set_has_callid();
    callid_ = callid;
  } else {
    clear_has_callid();
    callid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBNetTest.AudioFileTag filetag = 2;
inline bool FileLocationNotify::has_filetag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileLocationNotify::set_has_filetag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileLocationNotify::clear_has_filetag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileLocationNotify::clear_filetag() {
  filetag_ = 0;
  clear_has_filetag();
}
inline ::PBNetTest::AudioFileTag FileLocationNotify::filetag() const {
  return static_cast< ::PBNetTest::AudioFileTag >(filetag_);
}
inline void FileLocationNotify::set_filetag(::PBNetTest::AudioFileTag value) {
  assert(::PBNetTest::AudioFileTag_IsValid(value));
  set_has_filetag();
  filetag_ = value;
}

// required string path = 3;
inline bool FileLocationNotify::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileLocationNotify::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileLocationNotify::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileLocationNotify::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& FileLocationNotify::path() const {
  return *path_;
}
inline void FileLocationNotify::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FileLocationNotify::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FileLocationNotify::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileLocationNotify::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* FileLocationNotify::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileLocationNotify::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBNetTest.AudioEncodingTag code = 4;
inline bool FileLocationNotify::has_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileLocationNotify::set_has_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileLocationNotify::clear_has_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileLocationNotify::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::PBNetTest::AudioEncodingTag FileLocationNotify::code() const {
  return static_cast< ::PBNetTest::AudioEncodingTag >(code_);
}
inline void FileLocationNotify::set_code(::PBNetTest::AudioEncodingTag value) {
  assert(::PBNetTest::AudioEncodingTag_IsValid(value));
  set_has_code();
  code_ = value;
}

// optional .PBNetTest.SystemCode syscode = 5;
inline bool FileLocationNotify::has_syscode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileLocationNotify::set_has_syscode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileLocationNotify::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileLocationNotify::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBNetTest::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBNetTest::SystemCode& FileLocationNotify::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBNetTest::SystemCode* FileLocationNotify::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBNetTest::SystemCode;
  return syscode_;
}
inline ::PBNetTest::SystemCode* FileLocationNotify::release_syscode() {
  clear_has_syscode();
  ::PBNetTest::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void FileLocationNotify::set_allocated_syscode(::PBNetTest::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// SearchAbortRequest

// required string taskid = 1;
inline bool SearchAbortRequest::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchAbortRequest::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchAbortRequest::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchAbortRequest::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& SearchAbortRequest::taskid() const {
  return *taskid_;
}
inline void SearchAbortRequest::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SearchAbortRequest::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SearchAbortRequest::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchAbortRequest::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* SearchAbortRequest::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchAbortRequest::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBNetTest.SystemCode syscode = 2;
inline bool SearchAbortRequest::has_syscode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchAbortRequest::set_has_syscode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchAbortRequest::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchAbortRequest::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBNetTest::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBNetTest::SystemCode& SearchAbortRequest::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBNetTest::SystemCode* SearchAbortRequest::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBNetTest::SystemCode;
  return syscode_;
}
inline ::PBNetTest::SystemCode* SearchAbortRequest::release_syscode() {
  clear_has_syscode();
  ::PBNetTest::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void SearchAbortRequest::set_allocated_syscode(::PBNetTest::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// required string aborttaskid = 3;
inline bool SearchAbortRequest::has_aborttaskid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchAbortRequest::set_has_aborttaskid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchAbortRequest::clear_has_aborttaskid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchAbortRequest::clear_aborttaskid() {
  if (aborttaskid_ != &::google::protobuf::internal::kEmptyString) {
    aborttaskid_->clear();
  }
  clear_has_aborttaskid();
}
inline const ::std::string& SearchAbortRequest::aborttaskid() const {
  return *aborttaskid_;
}
inline void SearchAbortRequest::set_aborttaskid(const ::std::string& value) {
  set_has_aborttaskid();
  if (aborttaskid_ == &::google::protobuf::internal::kEmptyString) {
    aborttaskid_ = new ::std::string;
  }
  aborttaskid_->assign(value);
}
inline void SearchAbortRequest::set_aborttaskid(const char* value) {
  set_has_aborttaskid();
  if (aborttaskid_ == &::google::protobuf::internal::kEmptyString) {
    aborttaskid_ = new ::std::string;
  }
  aborttaskid_->assign(value);
}
inline void SearchAbortRequest::set_aborttaskid(const char* value, size_t size) {
  set_has_aborttaskid();
  if (aborttaskid_ == &::google::protobuf::internal::kEmptyString) {
    aborttaskid_ = new ::std::string;
  }
  aborttaskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchAbortRequest::mutable_aborttaskid() {
  set_has_aborttaskid();
  if (aborttaskid_ == &::google::protobuf::internal::kEmptyString) {
    aborttaskid_ = new ::std::string;
  }
  return aborttaskid_;
}
inline ::std::string* SearchAbortRequest::release_aborttaskid() {
  clear_has_aborttaskid();
  if (aborttaskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = aborttaskid_;
    aborttaskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchAbortRequest::set_allocated_aborttaskid(::std::string* aborttaskid) {
  if (aborttaskid_ != &::google::protobuf::internal::kEmptyString) {
    delete aborttaskid_;
  }
  if (aborttaskid) {
    set_has_aborttaskid();
    aborttaskid_ = aborttaskid;
  } else {
    clear_has_aborttaskid();
    aborttaskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SearchResponse

// required string taskid = 1;
inline bool SearchResponse::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchResponse::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchResponse::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchResponse::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& SearchResponse::taskid() const {
  return *taskid_;
}
inline void SearchResponse::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SearchResponse::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SearchResponse::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchResponse::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* SearchResponse::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchResponse::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBNetTest.SystemCode syscode = 2;
inline bool SearchResponse::has_syscode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchResponse::set_has_syscode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchResponse::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchResponse::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBNetTest::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBNetTest::SystemCode& SearchResponse::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBNetTest::SystemCode* SearchResponse::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBNetTest::SystemCode;
  return syscode_;
}
inline ::PBNetTest::SystemCode* SearchResponse::release_syscode() {
  clear_has_syscode();
  ::PBNetTest::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void SearchResponse::set_allocated_syscode(::PBNetTest::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// required .PBNetTest.OperationStatus status = 3;
inline bool SearchResponse::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchResponse::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchResponse::clear_status() {
  if (status_ != NULL) status_->::PBNetTest::OperationStatus::Clear();
  clear_has_status();
}
inline const ::PBNetTest::OperationStatus& SearchResponse::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::PBNetTest::OperationStatus* SearchResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBNetTest::OperationStatus;
  return status_;
}
inline ::PBNetTest::OperationStatus* SearchResponse::release_status() {
  clear_has_status();
  ::PBNetTest::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void SearchResponse::set_allocated_status(::PBNetTest::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// -------------------------------------------------------------------

// AlarmNotify

// required string alarmtime = 1;
inline bool AlarmNotify::has_alarmtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlarmNotify::set_has_alarmtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlarmNotify::clear_has_alarmtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlarmNotify::clear_alarmtime() {
  if (alarmtime_ != &::google::protobuf::internal::kEmptyString) {
    alarmtime_->clear();
  }
  clear_has_alarmtime();
}
inline const ::std::string& AlarmNotify::alarmtime() const {
  return *alarmtime_;
}
inline void AlarmNotify::set_alarmtime(const ::std::string& value) {
  set_has_alarmtime();
  if (alarmtime_ == &::google::protobuf::internal::kEmptyString) {
    alarmtime_ = new ::std::string;
  }
  alarmtime_->assign(value);
}
inline void AlarmNotify::set_alarmtime(const char* value) {
  set_has_alarmtime();
  if (alarmtime_ == &::google::protobuf::internal::kEmptyString) {
    alarmtime_ = new ::std::string;
  }
  alarmtime_->assign(value);
}
inline void AlarmNotify::set_alarmtime(const char* value, size_t size) {
  set_has_alarmtime();
  if (alarmtime_ == &::google::protobuf::internal::kEmptyString) {
    alarmtime_ = new ::std::string;
  }
  alarmtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AlarmNotify::mutable_alarmtime() {
  set_has_alarmtime();
  if (alarmtime_ == &::google::protobuf::internal::kEmptyString) {
    alarmtime_ = new ::std::string;
  }
  return alarmtime_;
}
inline ::std::string* AlarmNotify::release_alarmtime() {
  clear_has_alarmtime();
  if (alarmtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alarmtime_;
    alarmtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AlarmNotify::set_allocated_alarmtime(::std::string* alarmtime) {
  if (alarmtime_ != &::google::protobuf::internal::kEmptyString) {
    delete alarmtime_;
  }
  if (alarmtime) {
    set_has_alarmtime();
    alarmtime_ = alarmtime;
  } else {
    clear_has_alarmtime();
    alarmtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PBNetTest.AlarmLevel level = 2;
inline bool AlarmNotify::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AlarmNotify::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AlarmNotify::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AlarmNotify::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::PBNetTest::AlarmLevel AlarmNotify::level() const {
  return static_cast< ::PBNetTest::AlarmLevel >(level_);
}
inline void AlarmNotify::set_level(::PBNetTest::AlarmLevel value) {
  assert(::PBNetTest::AlarmLevel_IsValid(value));
  set_has_level();
  level_ = value;
}

// required string content = 3;
inline bool AlarmNotify::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AlarmNotify::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AlarmNotify::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AlarmNotify::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& AlarmNotify::content() const {
  return *content_;
}
inline void AlarmNotify::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void AlarmNotify::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void AlarmNotify::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AlarmNotify::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* AlarmNotify::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AlarmNotify::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string modulename = 4;
inline bool AlarmNotify::has_modulename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AlarmNotify::set_has_modulename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AlarmNotify::clear_has_modulename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AlarmNotify::clear_modulename() {
  if (modulename_ != &::google::protobuf::internal::kEmptyString) {
    modulename_->clear();
  }
  clear_has_modulename();
}
inline const ::std::string& AlarmNotify::modulename() const {
  return *modulename_;
}
inline void AlarmNotify::set_modulename(const ::std::string& value) {
  set_has_modulename();
  if (modulename_ == &::google::protobuf::internal::kEmptyString) {
    modulename_ = new ::std::string;
  }
  modulename_->assign(value);
}
inline void AlarmNotify::set_modulename(const char* value) {
  set_has_modulename();
  if (modulename_ == &::google::protobuf::internal::kEmptyString) {
    modulename_ = new ::std::string;
  }
  modulename_->assign(value);
}
inline void AlarmNotify::set_modulename(const char* value, size_t size) {
  set_has_modulename();
  if (modulename_ == &::google::protobuf::internal::kEmptyString) {
    modulename_ = new ::std::string;
  }
  modulename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AlarmNotify::mutable_modulename() {
  set_has_modulename();
  if (modulename_ == &::google::protobuf::internal::kEmptyString) {
    modulename_ = new ::std::string;
  }
  return modulename_;
}
inline ::std::string* AlarmNotify::release_modulename() {
  clear_has_modulename();
  if (modulename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modulename_;
    modulename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AlarmNotify::set_allocated_modulename(::std::string* modulename) {
  if (modulename_ != &::google::protobuf::internal::kEmptyString) {
    delete modulename_;
  }
  if (modulename) {
    set_has_modulename();
    modulename_ = modulename;
  } else {
    clear_has_modulename();
    modulename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .PBNetTest.SystemCode syscode = 5;
inline bool AlarmNotify::has_syscode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AlarmNotify::set_has_syscode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AlarmNotify::clear_has_syscode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AlarmNotify::clear_syscode() {
  if (syscode_ != NULL) syscode_->::PBNetTest::SystemCode::Clear();
  clear_has_syscode();
}
inline const ::PBNetTest::SystemCode& AlarmNotify::syscode() const {
  return syscode_ != NULL ? *syscode_ : *default_instance_->syscode_;
}
inline ::PBNetTest::SystemCode* AlarmNotify::mutable_syscode() {
  set_has_syscode();
  if (syscode_ == NULL) syscode_ = new ::PBNetTest::SystemCode;
  return syscode_;
}
inline ::PBNetTest::SystemCode* AlarmNotify::release_syscode() {
  clear_has_syscode();
  ::PBNetTest::SystemCode* temp = syscode_;
  syscode_ = NULL;
  return temp;
}
inline void AlarmNotify::set_allocated_syscode(::PBNetTest::SystemCode* syscode) {
  delete syscode_;
  syscode_ = syscode;
  if (syscode) {
    set_has_syscode();
  } else {
    clear_has_syscode();
  }
}

// -------------------------------------------------------------------

// OperationStatus

// required int32 code = 1;
inline bool OperationStatus::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationStatus::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationStatus::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationStatus::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 OperationStatus::code() const {
  return code_;
}
inline void OperationStatus::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional string description = 2;
inline bool OperationStatus::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationStatus::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationStatus::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationStatus::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& OperationStatus::description() const {
  return *description_;
}
inline void OperationStatus::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void OperationStatus::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void OperationStatus::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationStatus::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* OperationStatus::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationStatus::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SystemCode

// optional string spyid = 1;
inline bool SystemCode::has_spyid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemCode::set_has_spyid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemCode::clear_has_spyid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemCode::clear_spyid() {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    spyid_->clear();
  }
  clear_has_spyid();
}
inline const ::std::string& SystemCode::spyid() const {
  return *spyid_;
}
inline void SystemCode::set_spyid(const ::std::string& value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void SystemCode::set_spyid(const char* value) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(value);
}
inline void SystemCode::set_spyid(const char* value, size_t size) {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  spyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemCode::mutable_spyid() {
  set_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    spyid_ = new ::std::string;
  }
  return spyid_;
}
inline ::std::string* SystemCode::release_spyid() {
  clear_has_spyid();
  if (spyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spyid_;
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SystemCode::set_allocated_spyid(::std::string* spyid) {
  if (spyid_ != &::google::protobuf::internal::kEmptyString) {
    delete spyid_;
  }
  if (spyid) {
    set_has_spyid();
    spyid_ = spyid;
  } else {
    clear_has_spyid();
    spyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string srid = 2;
inline bool SystemCode::has_srid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemCode::set_has_srid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemCode::clear_has_srid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemCode::clear_srid() {
  if (srid_ != &::google::protobuf::internal::kEmptyString) {
    srid_->clear();
  }
  clear_has_srid();
}
inline const ::std::string& SystemCode::srid() const {
  return *srid_;
}
inline void SystemCode::set_srid(const ::std::string& value) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(value);
}
inline void SystemCode::set_srid(const char* value) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(value);
}
inline void SystemCode::set_srid(const char* value, size_t size) {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  srid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemCode::mutable_srid() {
  set_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    srid_ = new ::std::string;
  }
  return srid_;
}
inline ::std::string* SystemCode::release_srid() {
  clear_has_srid();
  if (srid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srid_;
    srid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SystemCode::set_allocated_srid(::std::string* srid) {
  if (srid_ != &::google::protobuf::internal::kEmptyString) {
    delete srid_;
  }
  if (srid) {
    set_has_srid();
    srid_ = srid;
  } else {
    clear_has_srid();
    srid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string datasource = 3;
inline int SystemCode::datasource_size() const {
  return datasource_.size();
}
inline void SystemCode::clear_datasource() {
  datasource_.Clear();
}
inline const ::std::string& SystemCode::datasource(int index) const {
  return datasource_.Get(index);
}
inline ::std::string* SystemCode::mutable_datasource(int index) {
  return datasource_.Mutable(index);
}
inline void SystemCode::set_datasource(int index, const ::std::string& value) {
  datasource_.Mutable(index)->assign(value);
}
inline void SystemCode::set_datasource(int index, const char* value) {
  datasource_.Mutable(index)->assign(value);
}
inline void SystemCode::set_datasource(int index, const char* value, size_t size) {
  datasource_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemCode::add_datasource() {
  return datasource_.Add();
}
inline void SystemCode::add_datasource(const ::std::string& value) {
  datasource_.Add()->assign(value);
}
inline void SystemCode::add_datasource(const char* value) {
  datasource_.Add()->assign(value);
}
inline void SystemCode::add_datasource(const char* value, size_t size) {
  datasource_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SystemCode::datasource() const {
  return datasource_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SystemCode::mutable_datasource() {
  return &datasource_;
}

// -------------------------------------------------------------------

// PhoneNumber

// required string telnumber = 1;
inline bool PhoneNumber::has_telnumber() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PhoneNumber::set_has_telnumber() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PhoneNumber::clear_has_telnumber() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PhoneNumber::clear_telnumber() {
  if (telnumber_ != &::google::protobuf::internal::kEmptyString) {
    telnumber_->clear();
  }
  clear_has_telnumber();
}
inline const ::std::string& PhoneNumber::telnumber() const {
  return *telnumber_;
}
inline void PhoneNumber::set_telnumber(const ::std::string& value) {
  set_has_telnumber();
  if (telnumber_ == &::google::protobuf::internal::kEmptyString) {
    telnumber_ = new ::std::string;
  }
  telnumber_->assign(value);
}
inline void PhoneNumber::set_telnumber(const char* value) {
  set_has_telnumber();
  if (telnumber_ == &::google::protobuf::internal::kEmptyString) {
    telnumber_ = new ::std::string;
  }
  telnumber_->assign(value);
}
inline void PhoneNumber::set_telnumber(const char* value, size_t size) {
  set_has_telnumber();
  if (telnumber_ == &::google::protobuf::internal::kEmptyString) {
    telnumber_ = new ::std::string;
  }
  telnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneNumber::mutable_telnumber() {
  set_has_telnumber();
  if (telnumber_ == &::google::protobuf::internal::kEmptyString) {
    telnumber_ = new ::std::string;
  }
  return telnumber_;
}
inline ::std::string* PhoneNumber::release_telnumber() {
  clear_has_telnumber();
  if (telnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = telnumber_;
    telnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneNumber::set_allocated_telnumber(::std::string* telnumber) {
  if (telnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete telnumber_;
  }
  if (telnumber) {
    set_has_telnumber();
    telnumber_ = telnumber;
  } else {
    clear_has_telnumber();
    telnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string countrycode = 2;
inline bool PhoneNumber::has_countrycode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PhoneNumber::set_has_countrycode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PhoneNumber::clear_has_countrycode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PhoneNumber::clear_countrycode() {
  if (countrycode_ != &::google::protobuf::internal::kEmptyString) {
    countrycode_->clear();
  }
  clear_has_countrycode();
}
inline const ::std::string& PhoneNumber::countrycode() const {
  return *countrycode_;
}
inline void PhoneNumber::set_countrycode(const ::std::string& value) {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::kEmptyString) {
    countrycode_ = new ::std::string;
  }
  countrycode_->assign(value);
}
inline void PhoneNumber::set_countrycode(const char* value) {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::kEmptyString) {
    countrycode_ = new ::std::string;
  }
  countrycode_->assign(value);
}
inline void PhoneNumber::set_countrycode(const char* value, size_t size) {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::kEmptyString) {
    countrycode_ = new ::std::string;
  }
  countrycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneNumber::mutable_countrycode() {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::kEmptyString) {
    countrycode_ = new ::std::string;
  }
  return countrycode_;
}
inline ::std::string* PhoneNumber::release_countrycode() {
  clear_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = countrycode_;
    countrycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneNumber::set_allocated_countrycode(::std::string* countrycode) {
  if (countrycode_ != &::google::protobuf::internal::kEmptyString) {
    delete countrycode_;
  }
  if (countrycode) {
    set_has_countrycode();
    countrycode_ = countrycode;
  } else {
    clear_has_countrycode();
    countrycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string provincecode = 3;
inline bool PhoneNumber::has_provincecode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PhoneNumber::set_has_provincecode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PhoneNumber::clear_has_provincecode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PhoneNumber::clear_provincecode() {
  if (provincecode_ != &::google::protobuf::internal::kEmptyString) {
    provincecode_->clear();
  }
  clear_has_provincecode();
}
inline const ::std::string& PhoneNumber::provincecode() const {
  return *provincecode_;
}
inline void PhoneNumber::set_provincecode(const ::std::string& value) {
  set_has_provincecode();
  if (provincecode_ == &::google::protobuf::internal::kEmptyString) {
    provincecode_ = new ::std::string;
  }
  provincecode_->assign(value);
}
inline void PhoneNumber::set_provincecode(const char* value) {
  set_has_provincecode();
  if (provincecode_ == &::google::protobuf::internal::kEmptyString) {
    provincecode_ = new ::std::string;
  }
  provincecode_->assign(value);
}
inline void PhoneNumber::set_provincecode(const char* value, size_t size) {
  set_has_provincecode();
  if (provincecode_ == &::google::protobuf::internal::kEmptyString) {
    provincecode_ = new ::std::string;
  }
  provincecode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneNumber::mutable_provincecode() {
  set_has_provincecode();
  if (provincecode_ == &::google::protobuf::internal::kEmptyString) {
    provincecode_ = new ::std::string;
  }
  return provincecode_;
}
inline ::std::string* PhoneNumber::release_provincecode() {
  clear_has_provincecode();
  if (provincecode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = provincecode_;
    provincecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneNumber::set_allocated_provincecode(::std::string* provincecode) {
  if (provincecode_ != &::google::protobuf::internal::kEmptyString) {
    delete provincecode_;
  }
  if (provincecode) {
    set_has_provincecode();
    provincecode_ = provincecode;
  } else {
    clear_has_provincecode();
    provincecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string areacode = 4;
inline bool PhoneNumber::has_areacode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PhoneNumber::set_has_areacode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PhoneNumber::clear_has_areacode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PhoneNumber::clear_areacode() {
  if (areacode_ != &::google::protobuf::internal::kEmptyString) {
    areacode_->clear();
  }
  clear_has_areacode();
}
inline const ::std::string& PhoneNumber::areacode() const {
  return *areacode_;
}
inline void PhoneNumber::set_areacode(const ::std::string& value) {
  set_has_areacode();
  if (areacode_ == &::google::protobuf::internal::kEmptyString) {
    areacode_ = new ::std::string;
  }
  areacode_->assign(value);
}
inline void PhoneNumber::set_areacode(const char* value) {
  set_has_areacode();
  if (areacode_ == &::google::protobuf::internal::kEmptyString) {
    areacode_ = new ::std::string;
  }
  areacode_->assign(value);
}
inline void PhoneNumber::set_areacode(const char* value, size_t size) {
  set_has_areacode();
  if (areacode_ == &::google::protobuf::internal::kEmptyString) {
    areacode_ = new ::std::string;
  }
  areacode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhoneNumber::mutable_areacode() {
  set_has_areacode();
  if (areacode_ == &::google::protobuf::internal::kEmptyString) {
    areacode_ = new ::std::string;
  }
  return areacode_;
}
inline ::std::string* PhoneNumber::release_areacode() {
  clear_has_areacode();
  if (areacode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = areacode_;
    areacode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PhoneNumber::set_allocated_areacode(::std::string* areacode) {
  if (areacode_ != &::google::protobuf::internal::kEmptyString) {
    delete areacode_;
  }
  if (areacode) {
    set_has_areacode();
    areacode_ = areacode;
  } else {
    clear_has_areacode();
    areacode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace PBNetTest

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBNetTest::MsgType>() {
  return ::PBNetTest::MsgType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBNetTest::AudioEncodingTag>() {
  return ::PBNetTest::AudioEncodingTag_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBNetTest::AudioFileTag>() {
  return ::PBNetTest::AudioFileTag_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBNetTest::AlarmLevel>() {
  return ::PBNetTest::AlarmLevel_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBNetTest::AudioRecordMode>() {
  return ::PBNetTest::AudioRecordMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBNetTest::AudioChannelType>() {
  return ::PBNetTest::AudioChannelType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBNetTest::AudioTransFlag>() {
  return ::PBNetTest::AudioTransFlag_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBNetTest::FileAcquireMethod>() {
  return ::PBNetTest::FileAcquireMethod_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBNetTest::PriorityType>() {
  return ::PBNetTest::PriorityType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PBNetTest_2eproto__INCLUDED
